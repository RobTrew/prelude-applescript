{
  "title": "sortOn",
  "cells": [
    {
      "type": "code",
      "language": "applescript",
      "data": "-- Sort a list by comparing the results of a key function applied to each\r-- element. sortOn f is equivalent to sortBy(comparing(f), xs), but has the\r-- performance advantage of only evaluating f once for each element in\r-- the input list. This is called the decorate-sort-undecorate paradigm,\r-- or Schwartzian transform.\r-- Elements are arranged from from lowest to highest.\r\r-- In this Applescript implementation, f can optionally be [(a -> b)]\r-- or [((a -> b), Bool)]) to specify a compound sort order\r\r--    xs:  List of items to be sorted. \r--          (The items can be records, lists, or simple values).\r--\r--    f:    A single (a -> b) function (Applescript handler),\r--          or a list of such functions.\r--          if the argument is a list, any function can \r--          optionally be followed by a bool. \r--          (False -> descending sort)\r--\r--          (Subgrouping in the list is optional and ignored)\r--          Each function (Item -> Value) in the list should \r--          take an item (of the type contained by xs) \r--          as its input and return a simple orderable value \r--          (Number, String, or Date).\r--\r--          The sequence of key functions and optional \r--          direction bools defines primary to N-ary sort keys."
    },
    {
      "type": "code",
      "language": "applescript",
      "data": "-- sortOn :: Ord b => (a -> b) -> [a] -> [a]\r-- sortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\ron sortOn(f, xs)\r    script keyBool\r        on |λ|(x, a)\r            if class of x is boolean then\r                {asc:x, fbs:fbs of a}\r            else\r                {asc:true, fbs:({Tuple(x, asc of a)} & fbs of a)}\r            end if\r        end |λ|\r    end script\r    set {fs, bs} to {|1|, |2|} of unzip(fbs of foldr(keyBool, ¬\r        {asc:true, fbs:{}}, flatten({f})))\r    \r    set intKeys to length of fs\r    set ca to current application\r    script dec\r        property gs : map(my mReturn, fs)\r        on |λ|(x)\r            set nsDct to (ca's NSMutableDictionary's ¬\r                dictionaryWithDictionary:{val:x})\r            repeat with i from 1 to intKeys\r                (nsDct's setValue:((item i of gs)'s |λ|(x)) ¬\r                    forKey:(character id (96 + i)))\r            end repeat\r            nsDct as record\r        end |λ|\r    end script\r    \r    script descrip\r        on |λ|(bool, i)\r            ca's NSSortDescriptor's ¬\r                sortDescriptorWithKey:(character id (96 + i)) ¬\r                    ascending:bool\r        end |λ|\r    end script\r    \r    script undec\r        on |λ|(x)\r            val of x\r        end |λ|\r    end script\r    \r    map(undec, ((ca's NSArray's arrayWithArray:map(dec, xs))'s ¬\r        sortedArrayUsingDescriptors:map(descrip, bs)) as list)\rend sortOn"
    }
  ]
}