{
  "title": "sortOn",
  "cells": [
    {
      "type": "code",
      "language": "applescript",
      "data": "-- Sort a list by comparing the results of a key function applied to each\n-- element. sortOn f is equivalent to sortBy(comparing(f), xs), but has the\n-- performance advantage of only evaluating f once for each element in\n-- the input list. This is called the decorate-sort-undecorate paradigm,\n-- or Schwartzian transform.\n-- Elements are arranged from from lowest to highest.\n\n-- In this Applescript implementation, f can optionally be [(a -> b)]\n-- or [((a -> b), Bool)]) to specify a compound sort order\n\n--    xs:  List of items to be sorted. \n--          (The items can be records, lists, or simple values).\n--\n--    f:    A single (a -> b) function (Applescript handler),\n--          or a list of such functions.\n--          if the argument is a list, any function can \n--          optionally be followed by a bool. \n--          (False -> descending sort)\n--\n--          (Subgrouping in the list is optional and ignored)\n--          Each function (Item -> Value) in the list should \n--          take an item (of the type contained by xs) \n--          as its input and return a simple orderable value \n--          (Number, String, or Date).\n--\n--          The sequence of key functions and optional \n--          direction bools defines primary to N-ary sort keys."
    },
    {
      "type": "code",
      "language": "applescript",
      "data": "-- sortOn :: Ord b => (a -> b) -> [a] -> [a]\n-- sortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\non sortOn(f, xs)\n    script keyBool\n        on |λ|(x, a)\n            if class of x is boolean then\n                {asc:x, fbs:fbs of a}\n            else\n                {asc:true, fbs:({Tuple(x, asc of a)} & fbs of a)}\n            end if\n        end |λ|\n    end script\n    set {fs, bs} to {|1|, |2|} of unzip(fbs of foldr(keyBool, ¬\n        {asc:true, fbs:{}}, flatten({f})))\n    \n    set intKeys to length of fs\n    set ca to current application\n    script dec\n        property gs : map(my mReturn, fs)\n        on |λ|(x)\n            set nsDct to (ca's NSMutableDictionary's ¬\n                dictionaryWithDictionary:{val:x})\n            repeat with i from 1 to intKeys\n                (nsDct's setValue:((item i of gs)'s |λ|(x)) ¬\n                    forKey:(character id (96 + i)))\n            end repeat\n            nsDct as record\n        end |λ|\n    end script\n    \n    script descrip\n        on |λ|(bool, i)\n            ca's NSSortDescriptor's ¬\n                sortDescriptorWithKey:(character id (96 + i)) ¬\n                    ascending:bool\n        end |λ|\n    end script\n    \n    script undec\n        on |λ|(x)\n            val of x\n        end |λ|\n    end script\n    \n    map(undec, ((ca's NSArray's arrayWithArray:map(dec, xs))'s ¬\n        sortedArrayUsingDescriptors:map(descrip, bs)) as list)\nend sortOn"
    }
  ]
}