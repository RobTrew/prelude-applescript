{
  "abs": "-- Absolute value.\n-- abs :: Num -> Num\ron abs(x)\r\tif x < 0 then\r\t\t-x\r\telse\r\t\tx\r\tend if\t\rend abs",
  "all": "-- Applied to a predicate and a list, `all` determines if all elements \n-- of the list satisfy the predicate.\n-- all :: (a -> Bool) -> [a] -> Bool\ron all(f, xs)\r\ttell mReturn(f)\r\t\tset lng to length of xs\r\t\trepeat with i from 1 to lng\r\t\t\tif not |λ|(item i of xs, i, xs) then return false\r\t\tend repeat\r\t\ttrue\r\tend tell\rend all",
  "and": "-- Returns the conjunction of a Boolean \n-- list. For the result to be true, \n-- all values in the list must be true.\n-- and :: [Bool] -> Bool\ron |and|(xs)\r\trepeat with x in xs\r\t\tif not (contents of x) then return false\r\tend repeat\r\treturn true\rend |and|",
  "any": "-- Applied to a predicate and a list, \n-- |any| returns true if at least one element of the \n-- list satisfies the predicate.\n-- any :: (a -> Bool) -> [a] -> Bool\ron |any|(f, xs)\r\ttell mReturn(f)\r\t\tset lng to length of xs\r\t\trepeat with i from 1 to lng\r\t\t\tif |λ|(item i of xs) then return true\r\t\tend repeat\r\t\tfalse\r\tend tell\rend |any|",
  "ap": "-- Applies wrapped functions to wrapped values, \n-- for example applying a list of functions to a list of values\n-- or applying Just(f) to Just(x), Right(f) to Right(x), etc\n-- ap (<*>) :: Monad m => m (a -> b) -> m a -> m b\ron ap(mf, mx)\r\tif class of mx is list then\r\t\tapList(mf, mx)\r\telse if class of mf is record then\r\t\tset ks to keys(mf)\r\t\tif ks contains \"type\" then\r\t\t\tset t to type of mx\r\t\t\tif t = \"Either\" then\r\t\t\t\tapEither(mf, mx)\r\t\t\telse if t = \"Maybe\" then\r\t\t\t\tapMaybe(mf, mx)\r\t\t\telse if t = \"Tuple\" then\r\t\t\t\tapTuple(mf, mx)\r\t\t\telse\r\t\t\t\tmissing value\r\t\t\tend if\r\t\telse\r\t\t\tmissing value\r\t\tend if\r\tend if\rend ap",
  "apList": "-- e.g. [(*2),(/2), sqrt] <*> [1,2,3]\r-- -->  ap([dbl, hlf, root], [1, 2, 3])\r-- -->  [2,4,6,0.5,1,1.5,1,1.4142135623730951,1.7320508075688772]\r\r-- Each member of a list of functions applied to\r-- each of a list of arguments, deriving a list of new values\n-- apList (<*>) :: [(a -> b)] -> [a] -> [b]\ron apList(fs, xs)\r\tset lst to {}\r\trepeat with f in fs\r\t\ttell mReturn(contents of f)\r\t\t\trepeat with x in xs\r\t\t\t\tset end of lst to |λ|(contents of x)\r\t\t\tend repeat\r\t\tend tell\r\tend repeat\r\treturn lst\rend apList",
  "apLR": "-- apLR (<*>) :: Either e (a -> b) -> Either e a -> Either e b\ron apLR(flr, lr)\r\tif isRight(flr) then\r\t\tif isRight(lr) then\r\t\t\t|Right|(|λ|(|Right| of lr) of mReturn(|Right| of flr))\r\t\telse\r\t\t\tlr\r\t\tend if\r\telse\r\t\tflr\r\tend if\rend apLR",
  "apMaybe": "-- Maybe f applied to Maybe x, deriving a Maybe y\n-- apMaybe (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\ron apMaybe(mf, mx)\r\tif Nothing of mf or Nothing of mx then\r\t\tNothing()\r\telse\r\t\tJust(|λ|(Just of mx) of mReturn(Just of mf))\r\tend if\rend apMaybe",
  "append": "-- Append two lists.\n-- append (++) :: [a] -> [a] -> [a]\r-- append (++) :: String -> String -> String\ron append(xs, ys)\r\txs & ys\rend append",
  "appendFile": "-- Write a string to the end of a file. \n-- Returns true if the path exists \n-- and the write succeeded. \n-- Otherwise returns false.\n-- appendFile :: FilePath -> String -> IO Bool\ron appendFile(strPath, txt)\r\tset ca to current application\r\tset oFullPath to (ca's NSString's stringWithString:strPath)'s ¬\r\t\tstringByStandardizingPath\r\tset {blnExists, intFolder} to (ca's NSFileManager's defaultManager()'s ¬\r\t\tfileExistsAtPath:oFullPath isDirectory:(reference))\r\tif blnExists then\r\t\tif intFolder = 0 then\r\t\t\tset oData to (ca's NSString's stringWithString:txt)'s ¬\r\t\t\t\tdataUsingEncoding:(ca's NSUTF8StringEncoding)\r\t\t\tset h to ca's NSFileHandle's fileHandleForWritingAtPath:oFullPath\r\t\t\th's seekToEndOfFile\r\t\t\th's writeData:oData\r\t\t\th's closeFile()\r\t\t\ttrue\r\t\telse\r\t\t\t-- text appended to folder is undefined\r\t\t\tfalse\r\t\tend if\r\telse\r\t\tif doesDirectoryExist(takeDirectory(oFullPath as string)) then\r\t\t\twriteFile(oFullPath, txt)\r\t\t\ttrue\r\t\telse\r\t\t\tfalse\r\t\tend if\r\tend if\rend appendFile",
  "appendFileMay": "-- Write a string to the end of a file. \n-- Returns a Just FilePath value if the \n-- path exists and the write succeeded. \n-- Otherwise returns Nothing.\n-- appendFileMay :: FilePath -> String -> Maybe IO FilePath\ron appendFileMay(strPath, txt)\r\tset ca to current application\r\tset oFullPath to (ca's NSString's stringWithString:strPath)'s ¬\r\t\tstringByStandardizingPath\r\tset strFullPath to oFullPath as string\r\tset {blnExists, intFolder} to (ca's NSFileManager's defaultManager()'s ¬\r\t\tfileExistsAtPath:oFullPath isDirectory:(reference))\r\tif blnExists then\r\t\tif intFolder = 0 then -- Not a directory\r\t\t\tset oData to (ca's NSString's stringWithString:txt)'s ¬\r\t\t\t\tdataUsingEncoding:(ca's NSUTF8StringEncoding)\r\t\t\tset h to ca's NSFileHandle's fileHandleForWritingAtPath:oFullPath\r\t\t\th's seekToEndOfFile\r\t\t\th's writeData:oData\r\t\t\th's closeFile()\r\t\t\tJust(strFullPath)\r\t\telse\r\t\t\tNothing()\r\t\tend if\r\telse\r\t\tif doesDirectoryExist(takeDirectory(strFullPath)) then\r\t\t\twriteFile(oFullPath, txt)\r\t\t\tJust(strFullPath)\r\t\telse\r\t\t\tNothing()\r\t\tend if\r\tend if\rend appendFileMay",
  "apply": "-- apply ($) :: (a -> b) -> a -> b\ron apply(f, x)\r\tmReturn(f)'s |λ|(x)\rend apply",
  "approxRatio": "-- approxRatio :: Real -> Real -> Ratio\ron approxRatio(epsilon, n)\r\tif epsilon is missing value then\r\t\tset e to 1 / 10000\r\telse\r\t\tset e to epsilon\r\tend if\r\t\r\tscript gcde\r\t\ton |λ|(e, x, y)\r\t\t\tscript _gcd\r\t\t\t\ton |λ|(a, b)\r\t\t\t\t\tif b < e then\r\t\t\t\t\t\ta\r\t\t\t\t\telse\r\t\t\t\t\t\t|λ|(b, a mod b)\r\t\t\t\t\tend if\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\t|λ|(abs(x), abs(y)) of _gcd\r\t\tend |λ|\r\tend script\r\t\r\tset c to |λ|(e, 1, n) of gcde\r\tRatio((n div c), (1 div c))\rend approxRatio",
  "apTuple": "-- apTuple (<*>) :: Monoid m => (m, (a -> b)) -> (m, a) -> (m, b)\ron apTuple(tf, tx)\r\tTuple(mappend(|1| of tf, |1| of tx), |λ|(|2| of tx) of mReturn(|2| of tf))\rend apTuple",
  "argvLength": "-- argvLength :: Function -> Int\non argvLength(h)\n    try\n        mReturn(h)'s |λ|()\n        0\n    on error errMsg\n        set {dlm, my text item delimiters} to {my text item delimiters, \",\"}\n        set xs to text items of errMsg\n        set my text item delimiters to dlm\n        length of xs\n    end try\nend argvLength",
  "assocs": "-- assocs :: Map k a -> [(k, a)]\ron assocs(m)\r\tset c to class of m\r\tif c is list then\r\t  zip(enumFromTo(1, length of m), m)\r\telse if c is record then\r\t\tset dict to (current application's ¬\r\t\t\tNSDictionary's ¬\r\t\t\tdictionaryWithDictionary:(m))\r\t\tzip((dict's allKeys()'s ¬\r\t\t\tsortedArrayUsingSelector:\"compare:\") as list, ¬\r\t\t\tdict's allValues() as list)\r\telse\r\t\t{}\r\tend if\rend assocs",
  "bind": "-- bind (>>=) :: Monad m => m a -> (a -> m b) -> m b\ron bind(m, mf)\r\tset c to class of m\r\tif c = list then\r\t\tbindList(m, mf)\r\telse if c = record then\r\t\tset ks to keys(m)\r\t\tif ks contains \"type\" then\r\t\t\tset t to type of m\r\t\t\tif t = \"Maybe\" then\r\t\t\t\tbindMay(m, mf)\r\t\t\telse if t = \"Either\" then\r\t\t\t\tbindEither(m, mf)\r\t\t\telse if t = \"Tuple\" then\r\t\t\t\tbindTuple(m, mf)\r\t\t\telse\r\t\t\t\tNothing()\r\t\t\tend if\r\t\telse\r\t\t\tNothing()\r\t\tend if\r\telse\r\t\tNothing()\r\tend if\rend bind",
  "bindList": "-- bindList (>>=) :: [a] -> (a -> [b]) -> [b]\ron bindList(xs, f)\r\tset acc to {}\r\ttell mReturn(f)\r\t\trepeat with x in xs\r\t\t\tset acc to acc & |λ|(contents of x)\r\t\tend repeat\r\tend tell\r\treturn acc\rend bindList",
  "bindLR": "-- bindLR (>>=) :: Either a -> (a -> Either b) -> Either b\ron bindLR(m, mf)\r\tif isRight(m) then\r\t\tmReturn(mf)'s |λ|(|Right| of m)\r\telse\r\t\tm\r\tend if\rend bindLR",
  "bindMay": "-- bindMay (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\ron bindMay(mb, mf)\r\tif Nothing of mb then\r\t\tmb\r\telse\r\t\ttell mReturn(mf) to |λ|(Just of mb)\r\tend if\rend bindMay",
  "bindTuple": "-- bindTuple (>>=) :: Monoid a => (a, a) -> (a -> (a, b)) -> (a, b)\ron bindTuple(tpl, f)\r\tset t2 to mReturn(f)'s |λ|(|2| of tpl)\r\tTuple(mappend(|1| of tpl, |1| of t2), |2| of t2)\rend bindTuple",
  "break": "-- break :: (a -> Bool) -> [a] -> ([a], [a])\non break(p, xs)\n\tset bln to false\n\ttell mReturn(p)\n\t\tset lng to length of xs\n\t\trepeat with i from 1 to lng\n\t\t\tif |λ|(item i of xs) then\n\t\t\t\tset bln to true\n\t\t\t\texit repeat\n\t\t\tend if\n\t\tend repeat\n\tend tell\n\tif bln then\n\t\tif i > 1 then\n\t\t\tTuple(items 1 thru (i - 1) of xs, items i thru -1 of xs)\n\t\telse\n\t\t\tTuple({}, xs)\n\t\tend if\n\telse\n\t\tTuple(xs, {})\n\tend if\nend break",
  "breakOn": "-- non null needle -> haystack -> (prefix before match, match + rest)\n-- breakOn :: String -> String -> (String, String)\ron breakOn(pat, src)\r\tif pat ≠ \"\" then\r\t\tset {dlm, my text item delimiters} to {my text item delimiters, pat}\r\t\t\r\t\tset lstParts to text items of src\r\t\tset lngParts to length of lstParts\r\t\t\r\t\tif lngParts > 1 then\r\t\t\tset tpl to Tuple(item 1 of lstParts, pat & ¬\r\t\t\t\t((items 2 thru -1 of lstParts) as text))\r\t\telse\r\t\t\tset tpl to Tuple(src, \"\")\r\t\tend if\r\t\t\r\t\tset my text item delimiters to dlm\r\t\treturn tpl\r\telse\r\t\tmissing value\r\tend if\rend breakOn",
  "breakOnAll": "-- breakOnAll \"::\" \"\"\n-- ==> []\n-- breakOnAll \"/\" \"a/b/c/\"\n-- ==> [(\"a\", \"/b/c/\"), (\"a/b\", \"/c/\"), (\"a/b/c\", \"/\")]\n-- breakOnAll :: String -> String -> [(String, String)]\ron breakOnAll(pat, src)\r\tif pat ≠ \"\" then\r\t\tscript\r\t\t\ton |λ|(a, _, i, xs)\r\t\t\t\tif i > 1 then\r\t\t\t\t\ta & {Tuple(intercalate(pat, take(i - 1, xs)), ¬\r\t\t\t\t\t\tpat & intercalate(pat, drop(i - 1, xs)))}\r\t\t\t\telse\r\t\t\t\t\ta\r\t\t\t\tend if\r\t\t\tend |λ|\r\t\tend script\r\t\tfoldl(result, {}, splitOn(pat, src))\r\telse\r\t\tmissing value\r\tend if\rend breakOnAll",
  "breakOnMay": "-- needle -> haystack -> maybe (prefix before match, match + rest)\n-- breakOnMay :: String -> String -> Maybe (String, String)\ron breakOnMay(pat, src)\r\tif pat ≠ \"\" then\r\t\tset {dlm, my text item delimiters} to {my text item delimiters, pat}\r\t\t\r\t\tset lstParts to text items of src\r\t\tif length of lstParts > 1 then\r\t\t\tset mbTuple to Just(Tuple(item 1 of lstParts, pat & ¬\r\t\t\t\t((items 2 thru -1 of lstParts) as text)))\r\t\telse\r\t\t\tset mbTuple to Just(Tuple(src, \"\"))\r\t\tend if\r\t\t\r\t\tset my text item delimiters to dlm\r\t\treturn mbTuple\r\telse\r\t\tNothing()\r\tend if\rend breakOnMay",
  "cartesianProduct": "-- cartesianProduct :: [a] -> [b] -> [(a, b)]\ron cartesianProduct(xs, ys)\r\tscript\r\t\ton |λ|(x)\r\t\t\tscript\r\t\t\t\ton |λ|(y)\r\t\t\t\t\t{Tuple(x, y)}\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tconcatMap(result, ys)\r\t\tend |λ|\r\tend script\r\tconcatMap(result, xs)\rend cartesianProduct",
  "caseOf": "-- List of (Predicate, value) tuples -> Default value -> Value to test -> Output value\n-- caseOf :: [(a -> Bool, b)] -> b -> a ->  b\ron caseOf (pvs, otherwise, x)\r\trepeat with tpl in pvs\r\t\tif mReturn(|1| of tpl)'s |λ|(x) then return |2| of tpl\r\tend repeat\r\treturn otherwise\rend caseOf",
  "catMaybes": "-- catMaybes :: [Maybe a] -> [a]\ron catMaybes(mbs)\r\tscript emptyOrListed\r\t\ton |λ|(m)\r\t\t\tif Nothing of m then\r\t\t\t\t{}\r\t\t\telse\r\t\t\t\t{Just of m}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tconcatMap(emptyOrListed, mbs)\rend catMaybes",
  "ceiling": "-- ceiling :: Num -> Int\ron ceiling(x)\r\tset nr to properFraction(x)\r\tset n to |1| of nr\r\tif (|2| of nr) > 0 then\r\t\tn + 1\r\telse\r\t\tn\r\tend if\rend ceiling",
  "center": "-- center :: Int -> Char -> String -> String\ron |center|(n, cFiller, strText)\r\tset lngFill to n - (length of strText)\r\tif lngFill > 0 then\r\t\tset strPad to replicate(lngFill div 2, cFiller) as text\r\t\tset strCenter to strPad & strText & strPad\r\t\tif lngFill mod 2 > 0 then\r\t\t\tcFiller & strCenter\r\t\telse\r\t\t\tstrCenter\r\t\tend if\r\telse\r\t\tstrText\r\tend if\rend |center|",
  "chars": "-- chars :: String -> [Char]\ron chars(s)\r\tcharacters of s\rend chars",
  "chr": "-- chr :: Int -> Char\ron chr(n)\r\tcharacter id n\rend chr",
  "chunksOf": "-- chunksOf :: Int -> [a] -> [[a]]\ron chunksOf(k, xs)\r\tscript\r\t\ton go(ys)\r\t\t\tset ab to splitAt(k, ys)\r\t\t\tset a to |1| of ab\r\t\t\tif isNull(a) then\r\t\t\t\t{}\r\t\t\telse\r\t\t\t\t{a} & go(|2| of ab)\r\t\t\tend if\r\t\tend go\r\tend script\r\tresult's go(xs)\rend chunksOf",
  "compare": "-- Ordering  :: (-1 | 0 | 1)\n-- compare :: a -> a -> Ordering\ron compare(a, b)\r\tif a < b then\r\t\t|LT|\r\telse if a > b then\r\t\t|GT|\r\telse\r\t\t|EQ|\r\tend if\rend compare",
  "comparing": "-- comparing :: (a -> b) -> (a -> a -> Ordering)\ron comparing(f)\r\tscript\r\t\ton |λ|(a, b)\r\t\t\ttell mReturn(f)\r\t\t\t\tset fa to |λ|(a)\r\t\t\t\tset fb to |λ|(b)\r\t\t\t\tif fa < fb then\r\t\t\t\t\t-1\r\t\t\t\telse if fa > fb then\r\t\t\t\t\t1\r\t\t\t\telse\r\t\t\t\t\t0\r\t\t\t\tend if\r\t\t\tend tell\r\t\tend |λ|\r\tend script\rend comparing",
  "compose": "-- compose :: (b -> c) -> (a -> b) -> a -> c\ron compose(f, g)\r\tscript\r\t\ton |λ|(x)\r\t\t\t|λ|(|λ|(x) of mReturn(g)) of mReturn(f)\r\t\tend |λ|\r\tend script\rend compose",
  "composeListLR": "-- composeListLR :: [(a -> a)] -> (a -> a)\ron composeListLR(fs)\r\tscript\r\t\ton |λ|(x)\r\t\t\tscript\r\t\t\t\ton |λ|(a, f)\r\t\t\t\t\tmReturn(f)'s |λ|(a)\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\t\r\t\t\tfoldl(result, x, fs)\r\t\tend |λ|\r\tend script\rend composeListLR",
  "composeListRL": "-- composeListRL :: [(a -> a)] -> (a -> a)\ron composeListRL(fs)\r\tscript\r\t\ton |λ|(x)\r\t\t\tscript\r\t\t\t\ton |λ|(f, a)\r\t\t\t\t\tmReturn(f)'s |λ|(a)\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\t\r\t\t\tfoldr(result, x, fs)\r\t\tend |λ|\r\tend script\rend composeListRL",
  "concat": "-- concat :: [[a]] -> [a]\r-- concat :: [String] -> String\ron concat(xs)\r\tif length of xs > 0 and class of (item 1 of xs) is string then\r\t\tset acc to \"\"\r\telse\r\t\tset acc to {}\r\tend if\r\trepeat with i from 1 to length of xs\r\t\tset acc to acc & item i of xs\r\tend repeat\r\tacc\rend concat",
  "concatMap": "-- concatMap :: (a -> [b]) -> [a] -> [b]\ron concatMap(f, xs)\r\ttell mReturn(f)\r\t\tset lng to length of xs\r\t\tset acc to {}\r\t\trepeat with i from 1 to lng\r\t\t\tset acc to acc & |λ|(item i of xs, i, xs)\r\t\tend repeat\r\tend tell\r\treturn acc\rend concatMap",
  "cons": "-- cons :: a -> [a] -> [a]\ron cons(x, xs)\r\t{x} & xs\rend cons",
  "const_": "-- const_ :: a -> b -> a\ron const_(k, _)\r\tk\rend const_",
  "createDirectoryIfMissingLR": "-- createDirectoryIfMissingLR :: Bool -> FilePath ->\r--      Either String String\ron createDirectoryIfMissingLR(blnParents, fp)\r\tif doesPathExist(fp) then\r\t\t|Right|(\"Found: '\" & fp & \"'\")\r\telse\r\t\tset e to reference\r\t\tset ca to current application\r\t\tset oPath to (ca's NSString's stringWithString:(fp))'s ¬\r\t\t\tstringByStandardizingPath\r\t\tset {blnOK, e} to ca's NSFileManager's ¬\r\t\t\tdefaultManager's createDirectoryAtPath:(oPath) ¬\r\t\t\twithIntermediateDirectories:(blnParents) ¬\r\t\t\tattributes:(missing value) |error|:(e)\r\t\tif blnOK then\r\t\t\t|Right|(fp)\r\t\telse\r\t\t\t|Left|((localizedDescription of e) as string)\r\t\tend if\r\tend if\rend createDirectoryIfMissingLR",
  "curry": "-- curry :: ((a, b) -> c) -> a -> b -> c\non curry(f)\n\tscript\n\t\ton |λ|(a)\n\t\t\tscript\n\t\t\t\ton |λ|(b)\n\t\t\t\t\t|λ|(a, b) of mReturn(f)\n\t\t\t\tend |λ|\n\t\t\tend script\n\t\tend |λ|\n\tend script\nend curry",
  "curry2": "-- Not distinct, in Applescript, from the default curry.\n-- (In JavaScript we have a choice between two-argument and N-argument currying,\n-- but for want of a way of detecting arity at run-time, the arbitrary\n-- N-argument version seems hard to implement in Applescript)\n-- curry2 :: ((a, b) -> c) -> a -> b -> c\non curry2(f)\n\tscript\n\t\ton |λ|(a)\n\t\t\tscript\n\t\t\t\ton |λ|(b)\n\t\t\t\t\t|λ|(a, b) of mReturn(f)\n\t\t\t\tend |λ|\n\t\t\tend script\n\t\tend |λ|\n\tend script\nend curry",
  "delete": "-- delete :: Eq a => a -> [a] -> [a]\ron |delete|(x, xs)\r\tset mbIndex to elemIndex(x, xs)\r\tset lng to length of xs\r\t\r\tif Nothing of mbIndex then\r\t\txs\r\telse\r\t\tif lng > 1 then\r\t\t\tset i to Just of mbIndex\r\t\t\tif i = 1 then\r\t\t\t\titems 2 thru -1 of xs\r\t\t\telse if i = lng then\r\t\t\t\titems 1 thru -2 of xs\r\t\t\telse\r\t\t\t\ttell xs to items 1 thru (i - 1) & items (i + 1) thru -1\r\t\t\tend if\r\t\telse\r\t\t\t{}\r\t\tend if\r\tend if\rend |delete|",
  "deleteAt": "-- deleteAt :: Int -> [a] -> [a]\ron deleteAt(i, xs)\r\tset lr to splitAt(i, xs)\r\tset {l, r} to {|1| of lr, |2| of lr}\r\tif length of r > 1 then\r\t\tl & items 2 thru -1 of r\r\telse\r\t\tl\r\tend if\rend deleteAt",
  "deleteBy": "-- deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\ron deleteBy(fnEq, x, xs)\r\tif length of xs > 0 then\r\t\tset mb to uncons(xs)\r\t\tif Nothing of mb then\r\t\t\txs\r\t\telse\r\t\t\tset ht to Just of mb\r\t\t\tset {h, t} to {|1| of ht, |2| of ht}\r\t\t\tif |λ|(x, h) of mReturn(fnEq) then\r\t\t\t\tt\r\t\t\telse\r\t\t\t\t{h} & deleteBy(fnEq, x, t)\r\t\t\tend if\r\t\tend if\r\telse\r\t\t{}\r\tend if\rend deleteBy",
  "deleteFirst": "-- deleteFirst :: a -> [a] -> [a]\non deleteFirst(x, xs)\n    script Eq\n        on |λ|(a, b)\n            a = b\n        end |λ|\n    end script\n \n    deleteBy(Eq, x, xs)\nend |delete|",
  "deleteFirstsBy": "-- deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\ron deleteFirstsBy(fnEq, xs, ys)\r\tscript\r\t\ton |λ|(x, y)\r\t\t\tdeleteBy(fnEq, y, x)\r\t\tend |λ|\r\tend script\r\tfoldl(result, xs, ys)\rend deleteFirstsBy",
  "deleteMap": "-- deleteMap :: k -> Dict -> Dict\ron deleteMap(k, rec)\r\tset nsDct to (current application's ¬\r\t\tNSMutableDictionary's dictionaryWithDictionary:rec)\r\tnsDct's removeObjectForKey:(k)\r\tnsDct as record\rend deleteMap",
  "difference": "-- difference :: Eq a => [a] -> [a] -> [a]\non difference(xs, ys)\n    script \n        on |λ|(a, y)\n            if a contains y then\n                my |delete|(y, a)\n            else\n                a\n            end if\n        end |λ|\n    end script\n \n    foldl(result, xs, ys)\nend difference",
  "div": "-- div :: Int -> Int -> Int\ron |div|(a, b)\r\ta div b\rend |div|",
  "doesDirectoryExist": "-- doesDirectoryExist :: FilePath -> IO Bool\ron doesDirectoryExist(strPath)\r\tset ca to current application\r\tset oPath to (ca's NSString's stringWithString:strPath)'s ¬\r\t\tstringByStandardizingPath\r\tset {bln, int} to (ca's NSFileManager's defaultManager's ¬\r\t\tfileExistsAtPath:oPath isDirectory:(reference))\r\tbln and (int = 1)\rend doesDirectoryExist",
  "doesFileExist": "-- doesFileExist :: FilePath -> IO Bool\ron doesFileExist(strPath)\r\tset ca to current application\r\tset oPath to (ca's NSString's stringWithString:strPath)'s ¬\r\t\tstringByStandardizingPath\r\tset {bln, int} to (ca's NSFileManager's defaultManager's ¬\r\t\tfileExistsAtPath:oPath isDirectory:(reference))\r\tbln and (int ≠ 1)\rend doesFileExist",
  "doesPathExist": "-- doesPathExist :: FilePath -> IO Bool\ron doesPathExist(strPath)\r\tset ca to current application\r\tca's NSFileManager's defaultManager's ¬\r\t\tfileExistsAtPath:((ca's NSString's ¬\r\t\t\tstringWithString:strPath)'s ¬\r\t\t\tstringByStandardizingPath)\rend doesPathExist",
  "draw": "-- draw :: Tree String -> [String]\ron draw(tree)\r\t\r\t-- shift :: String -> String -> [String] -> [String]\r\tscript shift\r\t\ton |λ|(strFirst, strOther, xs)\r\t\t\tzipWith(my append, ¬\r\t\t\t\tcons(strFirst, replicate((length of xs) - 1, strOther)), xs)\r\t\tend |λ|\r\tend script\r\t\r\t-- drawSubTrees :: [Tree String] -> [String]\r\tscript drawSubTrees\r\t\ton |λ|(xs)\r\t\t\tset lng to length of xs\r\t\t\tif lng > 0 then\r\t\t\t\tif lng > 1 then\r\t\t\t\t\tcons(\"│\", append(shift's |λ|(\"├─ \", \"│  \", draw(item 1 of xs)), ¬\r\t\t\t\t\t\t|λ|(items 2 thru -1 of xs)))\r\t\t\t\telse\r\t\t\t\t\tcons(\"│\", shift's |λ|(\"└─ \", \"   \", draw(item 1 of xs)))\r\t\t\t\tend if\r\t\t\telse\r\t\t\t\t{}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\tparagraphs of (root of tree) & |λ|(nest of tree) of drawSubTrees\rend draw",
  "drawForest": "-- drawForest :: Forest String -> String\ron drawForest(trees)\r\tintercalate(\"\\n\\n\", map(my drawTree, trees))\rend drawForest",
  "drawTree": "-- drawTree :: Tree String -> String\ron drawTree(tree)\r\tunlines(draw(tree))\rend drawTree",
  "drop": "-- drop :: Int -> [a] -> [a]\ron drop(n, xs)\r\tif n < length of xs then\r\t\tif class of xs is text then\r\t\t\ttext (n + 1) thru -1 of xs\r\t\telse\r\t\t\titems (n + 1) thru -1 of xs\r\t\tend if\r\telse\r\t\t{}\r\tend if\rend drop",
  "dropAround": "-- dropAround :: (Char -> Bool) -> String -> String\ron dropAround(p, s)\r\tdropWhile(p, dropWhileEnd(p, s))\rend dropAround",
  "dropFileName": "-- dropFileName :: FilePath -> FilePath\ron dropFileName(strPath)\r\tif strPath ≠ \"\" then\r\t\tif character -1 of strPath = \"/\" then\r\t\t\tstrPath\r\t\telse\r\t\t\tset xs to init(splitOn(\"/\", strPath))\r\t\t\tif xs ≠ {} then\r\t\t\t\tintercalate(\"/\", xs) & \"/\"\r\t\t\telse\r\t\t\t\t\"./\"\r\t\t\tend if\r\t\tend if\r\telse\r\t\t\"./\"\r\tend if\rend dropFileName",
  "dropWhile": "-- dropWhile :: (a -> Bool) -> [a] -> [a]\ron dropWhile(p, xs)\r\tset lng to length of xs\r\tset i to 1\r\ttell mReturn(p)\r\t\trepeat while i ≤ lng and |λ|(item i of xs)\r\t\t\tset i to i + 1\r\t\tend repeat\r\tend tell\r\tif i ≤ lng then\r\t\tif class of xs ≠ string then\r\t\t\titems i thru lng of xs\r\t\telse\r\t\t\ttext i thru lng of xs\r\t\tend if\r\telse\r\t\t{}\r\tend if\rend dropWhile",
  "dropWhileEnd": "-- dropWhileEnd :: (Char -> Bool) -> String -> String\r-- dropWhileEnd :: (a -> Bool) -> [a] -> [a]\ron dropWhileEnd(p, xs)\r\tset i to length of xs\r\ttell mReturn(p)\r\t\trepeat while i > 0 and |λ|(item i of xs)\r\t\t\tset i to i - 1\r\t\tend repeat\r\tend tell\r\tif i > 0 then\r\t\tif class of xs ≠ string then\r\t\t\titems 1 thru i of xs\r\t\telse\r\t\t\ttext 1 thru i of xs\r\t\tend if\r\telse\r\t\t{}\r\tend if\rend dropWhileEnd",
  "either": "-- either :: (a -> c) -> (b -> c) -> Either a b -> c\ron either(lf, rf, e)\r\tif isRight(e) then\r\t\ttell mReturn(rf) to |λ|(|Right| of e)\r\telse\r\t\ttell mReturn(lf) to |λ|(|Left| of e)\r\tend if\rend either",
  "elem": "-- elem :: Eq a => a -> [a] -> Bool\ron elem(x, xs)\r\tconsidering case\r\t\txs contains x\r\tend considering\rend elem",
  "elemAtMay": "-- If x is a Dictionary then reads the Int as an index\n-- into the lexically sorted keys of the Dict, \n-- returning a Maybe (Key, Value) pair.\n-- If x is a list, then return a Maybe a \n-- (In either case, returns Nothing for an Int out of range)\n-- elemAtMay :: Int -> Dict -> Maybe (String, a)\r-- elemAtMay :: Int -> [a] -> Maybe a\ron elemAtMay(i, x)\r\tset bln to class of x is record\r\tif bln then\r\t\tset ks to keys(x)\r\t\tif i ≤ |length|(ks) then\r\t\t\tset k to item i of sort(ks)\r\t\t\tscript pair\r\t\t\t\ton |λ|(v)\r\t\t\t\t\tJust(Tuple(k, v))\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tbindMay(lookup(k, x), pair)\r\t\tend if\r\telse\r\t\tif i ≤ |length|(x) then\r\t\t\tJust(item i of x)\r\t\telse\r\t\t\tNothing()\r\t\tend if\r\tend if\rend elemAtMay",
  "elemIndex": "-- elemIndex :: Eq a => a -> [a] -> Maybe Int\ron elemIndex(x, xs)\r\tset lng to length of xs\r\trepeat with i from 1 to lng\r\t\tif x = (item i of xs) then return Just(i)\r\tend repeat\r\treturn Nothing()\rend elemIndex",
  "elemIndices": "-- elemIndices :: Eq a => a -> [a] -> [Int]\ron elemIndices(x, xs)\r\tscript\r\t\ton |λ|(y, i)\r\t\t\tif y = x then\r\t\t\t\t{i}\r\t\t\telse\r\t\t\t\t{}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tconcatMap(result, xs)\rend elemIndices",
  "elems": "-- elems :: Dict -> [a]\ron elems(rec)\r\tset ca to current application\r\t(ca's NSDictionary's dictionaryWithDictionary:rec)'s allValues() as list\rend elems",
  "enumFromThenTo": "-- enumFromThenTo :: Enum a => a -> a -> a -> [a]\ron enumFromThenTo(x1, x2, y)\r\tif class of x1 is integer then\r\t\tenumFromThenToInt(x1, x2, y)\r\telse\r\t\tenumFromThenToChar(x1, x2, y)\r\tend if\rend enumFromThenTo",
  "enumFromThenToChar": "-- enumFromThenToChar :: Char -> Char -> Char -> [Char]\ron enumFromThenToChar(x1, x2, y)\r\tset {int1, int2, intY} to {id of x1, id of x2, id of y}\r\tset xs to {}\r\trepeat with i from int1 to intY by (int2 - int1)\r\t\tset end of xs to character id i\r\tend repeat\r\treturn xs\rend enumFromThenToChar",
  "enumFromThenToInt": "-- enumFromThenToInt :: Int -> Int -> Int -> [Int]\ron enumFromThenToInt(x1, x2, y)\r\tset xs to {}\r\trepeat with i from x1 to y by (x2 - x1)\r\t\tset end of xs to i\r\tend repeat\r\treturn xs\rend enumFromThenToInt\r",
  "enumFromTo": "-- enumFromTo :: Enum a => a -> a -> [a]\ron enumFromTo(m, n)\r\tif class of m is integer then\r\t\tenumFromToInt(m, n)\r\telse\r\t\tenumFromToChar(m, n)\r\tend if\rend enumFromTo",
  "enumFromToChar": "-- enumFromToChar :: Char -> Char -> [Char]\ron enumFromToChar(m, n)\r\tset {intM, intN} to {id of m, id of n}\r\tif intM ≤ intN then\r\t\tset xs to {}\r\t\trepeat with i from intM to intN\r\t\t\tset end of xs to character id i\r\t\tend repeat\r\t\treturn xs\r\telse\r\t\t{}\r\tend if\rend enumFromToChar",
  "enumFromToInt": "-- enumFromToInt :: Int -> Int -> [Int]\ron enumFromToInt(m, n)\r\tif m ≤ n then\r\t\tset lst to {}\r\t\trepeat with i from m to n\r\t\t\tset end of lst to i\r\t\tend repeat\r\t\treturn lst\r\telse\r\t\treturn {}\r\tend if\rend enumFromToInt",
  "EQ": "-- EQ :: Ordering\rproperty |EQ| : {type:\"Ordering\", value:0}",
  "eq": "-- eq (==) :: Eq a => a -> a -> Bool\ron eq(a, b)\r\ta = b\rend eq",
  "evalJSMay": "-- use framework \"Foundation\"\n-- use framework \"JavaScriptCore\"\n\n-- gJSC can be declared in the global namespace,\n-- but unless the reference is released before the \n-- end of the script (e.g. `set gJSC to null`)\n-- it will persist, and\n-- Script Editor will be unable to save a .scpt file\n-- evalJSMay :: String -> Maybe a\ron evalJSMay(strJS)\r\ttry -- NB if gJSC is global it must be released \r\t\t-- (e.g. set to null) at end of script\r\t\tgJSC's evaluateScript\r\ton error\r\t\tset gJSC to current application's JSContext's new()\r\t\tlog (\"new JSC\")\r\tend try\r\tset v to unwrap((gJSC's evaluateScript:(strJS))'s toObject())\r\tif v is missing value then\r\t\tNothing()\r\telse\r\t\tJust(v)\r\tend if\rend evalJSMay",
  "even": "-- even :: Int -> Bool\ron even(x)\r\tx mod 2 = 0\rend even",
  "exp": "-- exp :: Float -> Float\ron exp(n)\r\tJust of evalJSMay((\"Math.exp(\" & n as string) & \")\")\rend exp",
  "fanArrow": "-- Compose a function from a simple value to a tuple of\n-- the separate outputs of two different functions\n-- fanArrow (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))\ron fanArrow(f, g)\r\tscript\r\t\ton |λ|(x)\r\t\t\tTuple(mReturn(f)'s |λ|(x), mReturn(g)'s |λ|(x))\r\t\tend |λ|\r\tend script\rend fanArrow",
  "filePath": "-- filePath :: String -> FilePath\ron filePath(s)\r\t((current application's ¬\r\t\tNSString's stringWithString:s)'s ¬\r\t\tstringByStandardizingPath()) as string\rend filePath",
  "filePathTree": "-- filePathTree :: filePath -> [Tree String] -> Tree filePath\ron filePathTree(fpAnchor, trees)\r\tscript go\r\t\ton |λ|(fp)\r\t\t\tscript\r\t\t\t\ton |λ|(tree)\r\t\t\t\t\tset strPath to fp & \"/\" & (root of tree)\r\t\t\t\t\t\r\t\t\t\t\tNode(strPath, map(go's |λ|(strPath), nest of tree))\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\tend |λ|\r\tend script\r\t\r\tNode(fpAnchor, map(go's |λ|(fpAnchor), trees))\rend filePathTree",
  "fileSize": "-- fileSize :: FilePath -> Either String Int\ron fileSize(fp)\r\tscript fs\r\t\ton |λ|(rec)\r\t\t\t|Right|(NSFileSize of rec)\r\t\tend |λ|\r\tend script\r\tbindLR(my fileStatus(fp), fs)\rend fileSize",
  "fileStatus": "-- fileStatus :: FilePath -> Either String Dict\ron fileStatus(fp)\r\tset e to reference\r\tset {v, e} to current application's NSFileManager's defaultManager's ¬\r\t\tattributesOfItemAtPath:fp |error|:e\r\tif v is not missing value then\r\t\t|Right|(v as record)\r\telse\r\t\t|Left|((localizedDescription of e) as string)\r\tend if\rend fileStatus",
  "filter": "-- filter :: (a -> Bool) -> [a] -> [a]\ron filter(f, xs)\r\ttell mReturn(f)\r\t\tset lst to {}\r\t\tset lng to length of xs\r\t\trepeat with i from 1 to lng\r\t\t\tset v to item i of xs\r\t\t\tif |λ|(v, i, xs) then set end of lst to v\r\t\tend repeat\r\t\treturn lst\r\tend tell\rend filter",
  "find": "-- find :: (a -> Bool) -> [a] -> Maybe a\ron find(p, xs)\r\ttell mReturn(p)\r\t\tset lng to length of xs\r\t\trepeat with i from 1 to lng\r\t\t\tif |λ|(item i of xs) then return Just(item i of xs)\r\t\tend repeat\r\t\tNothing()\r\tend tell\rend find",
  "findIndex": "-- findIndex :: (a -> Bool) -> [a] -> Maybe Int\non findIndex(f, xs)\n\ttell mReturn(f)\n\t\tset lng to length of xs\n\t\trepeat with i from 1 to lng\n\t\t\tif |λ|(item i of xs) then return Just(i)\n\t\tend repeat\n\t\treturn Nothing()\n\tend tell\nend findIndex",
  "findIndexR": "-- findIndexR :: (a -> Bool) -> [a] -> Maybe Int\ron findIndexR(f, xs)\r\ttell mReturn(f)\r\t\tset lng to length of xs\r\t\trepeat with i from lng to 1 by -1\r\t\t\tif |λ|(item i of xs) then return Just(i)\r\t\tend repeat\r\t\treturn Nothing()\r\tend tell\rend findIndexR",
  "findIndices": "-- findIndices :: (a -> Bool) -> [a] -> [Int]\ron findIndices(p, xs)\r\tscript\r\t\tproperty f : mReturn(p)'s |λ|\r\t\ton |λ|(x, i)\r\t\t\tif f(x) then\r\t\t\t\t{i}\r\t\t\telse\r\t\t\t\t{}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tconcatMap(result, xs)\rend findIndices",
  "firstArrow": "-- Lift a simple function to one which applies to a tuple, \n-- transforming only the first item of the tuple\n-- firstArrow :: (a -> b) -> ((a, c) -> (b, c))\ron firstArrow(f)\r\tscript\r\t\ton |λ|(xy)\r\t\t\tTuple(mReturn(f)'s |λ|(|1| of xy), |2| of xy)\r\t\tend |λ|\r\tend script\rend |first|",
  "flatten": "-- flatten :: NestedList a -> [a]\ron flatten(t)\r\tif list is class of t then\r\t\tconcatMap(my flatten, t)\r\telse\r\t\tt\r\tend if\rend flatten",
  "flip": "-- flip :: (a -> b -> c) -> b -> a -> c\non flip(f)\n\tscript\n\t\tproperty g : f\n\t\ton |λ|(x, y)\n\t\t\tg(y, x)\n\t\tend |λ|\n\tend script\nend flip",
  "floor": "-- floor :: Num -> Int\ron floor(x)\r\tset nr to properFraction(x)\r\tset n to |1| of nr\r\tif (|2| of nr) < 0 then\r\t\tn - 1\r\telse\r\t\tn\r\tend if\rend floor",
  "fmap": "-- fmap (<$>) :: Functor f => (a -> b) -> f a -> f b\ron fmap(f, fa)\r\tif class of fa is record and keys(fa) contains \"type\" then\r\t\tset t to type of fa\r\t\tif t = \"Either\" then\r\t\t\tset fm to my fmapLR\r\t\telse if t = \"Maybe\" then\r\t\t\tset fm to my fmapMay\r\t\telse if t = \"Tree\" then\r\t\t\tset fm to my fmapTree\r\t\telse if t = \"Tuple\" then\r\t\t\tset fm to my fmapTuple\r\t\telse\r\t\t\tset fm to my map\r\t\tend if\r\t\t|λ|(f, fa) of mReturn(fm)\r\telse\r\t\tmap(f, fa)\r\tend if\rend fmap",
  "fmapLR": "-- fmapLR (<$>) :: (a -> b) -> Either a a -> Either a b\ron fmapLR(f, lr)\r\tif isRight(lr) then\r\t\t|Right|(|λ|(|Right| of lr) of mReturn(f))\r\telse\r\t\tlr\r\tend if\rend fmapLR",
  "fmapMay": "-- fmapMay (<$>) :: (a -> b) -> Maybe a -> Maybe b\ron fmapMay(f, mb)\r\tif Nothing of mb then\r\t\tmb\r\telse\r\t\tJust(|λ|(Just of mb) of mReturn(f))\r\tend if\rend fmapMay",
  "fmapTree": "-- fmapTree :: (a -> b) -> Tree a -> Tree b\ron fmapTree(f, tree)\r\tscript go\r\t\tproperty g : |λ| of mReturn(f)\r\t\ton |λ|(x)\r\t\t\tset xs to nest of x\r\t\t\tif xs ≠ {} then\r\t\t\t\tset ys to map(go, xs)\r\t\t\telse\r\t\t\t\tset ys to xs\r\t\t\tend if\r\t\t\tNode(g(root of x), ys)\r\t\tend |λ|\r\tend script\r  |λ|(tree) of go\rend fmapTree",
  "fmapTuple": "-- fmapTuple (<$>) :: (a -> b) -> (a, a) -> (a, b)\ron fmapTuple(f, tpl)\r\tTuple(|1| of tpl, |λ|(|2| of tpl) of mReturn(f))\rend fmapTuple",
  "foldl": "-- foldl :: (a -> b -> a) -> a -> [b] -> a\non foldl(f, startValue, xs)\n\ttell mReturn(f)\n\t  set v to startValue\n\t  set lng to length of xs\n\t  repeat with i from 1 to lng\n\t\t  set v to |λ|(v, item i of xs, i, xs)\n\t  end repeat\n\t  return v\n\t  end tell\nend foldl",
  "foldl1": "-- foldl1 :: (a -> a -> a) -> [a] -> a\non foldl1(f, xs)\n    if length of xs > 1 then\n        tell mReturn(f)\n            set v to {item 1 of xs}\n            set lng to length of xs\n            repeat with i from 2 to lng\n                set v to |λ|(v, item i of xs, i, xs)\n            end repeat\n            return v\n        end tell\n    else\n        item 1 of xs\n    end if\nend foldl1",
  "foldl1May": "-- foldl1May :: (a -> a -> a) -> [a] -> Maybe a\non foldl1May(f, xs)\n    set lng to length of xs\n    if lng > 0 then\n        if lng > 1 then\n            tell mReturn(f)\n                set v to {item 1 of xs}\n                set lng to length of xs\n                repeat with i from 2 to lng\n                    set v to |λ|(v, item i of xs, i, xs)\n                end repeat\n                return Just(v)\n            end tell\n        else\n            Just(item 1 of xs)\n        end if\n    else\n        Nothing()\n    end if\nend foldl1May",
  "foldlTree": "-- foldlTree :: (b -> a -> b) -> b -> Tree a -> b\ron foldlTree(f, acc, tree)\r\tscript go\r\t\tproperty g : |λ| of mReturn(f)\r\t\ton |λ|(a, x)\r\t\t\tset xs to nest of x\r\t\t\tif xs ≠ {} then\r\t\t\t\tfoldl(go, g(a, root of x), xs)\r\t\t\telse\r\t\t\t\tg(a, root of x)\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t|λ|(acc, tree) of go\rend foldlTree",
  "foldMapTree": "-- foldMapTree :: Monoid m => (a -> m) -> Tree a -> m\ron foldMapTree(f, tree)\r\tscript go\r\t\tproperty g : mReturn(f)'s |λ|\r\t\ton |λ|(x)\r\t\t\tif length of (nest of x) > 0 then\r\t\t\t\tmappend(g(root of x), ¬\r\t\t\t\t\tfoldl1(my mappend, (map(go, nest of x))))\r\t\t\telse\r\t\t\t\tg(root of x)\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\t|λ|(tree) of go\rend foldMapTree",
  "foldr": "-- foldr :: (a -> b -> b) -> b -> [a] -> b\ron foldr(f, startValue, xs)\r\ttell mReturn(f)\r\t\tset v to startValue\r\t\tset lng to length of xs\r\t\trepeat with i from lng to 1 by -1\r\t\t\tset v to |λ|(item i of xs, v, i, xs)\r\t\tend repeat\r\t\treturn v\r\tend tell\rend foldr",
  "foldr1": "-- foldr1 :: (a -> a -> a) -> [a] -> a\non foldr1(f, xs)\n\tif length of xs > 1 then\n\t\ttell mReturn(f)\n\t\t\tset v to item -1 of xs\n\t\t\tset lng to length of xs\n\t\t\trepeat with i from lng - 1 to 1 by -1\n\t\t\t\tset v to |λ|(item i of xs, v, i, xs)\n\t\t\tend repeat\n\t\t\treturn v\n\t\tend tell\n\telse\n\t\txs\n\tend if\nend foldr1",
  "foldr1May": "-- foldr1May :: (a -> a -> a) -> [a] -> Maybe a\ron foldr1May(f, xs)\r\tset lng to length of xs\r\tif lng > 0 then\r\t\ttell mReturn(f)\r\t\t\tset v to item -1 of xs\r\t\t\trepeat with i from lng - 1 to 1 by -1\r\t\t\t\tset v to |λ|(item i of xs, v, i, xs)\r\t\t\tend repeat\r\t\t\treturn Just(v)\r\t\tend tell\r\telse\r\t\tNothing()\r\tend if\rend foldr1May",
  "foldTree": "-- foldTree :: (a -> [b] -> b) -> Tree a -> b\ron foldTree(f, tree)\r\tscript go\r\t\tproperty g : mReturn(f)'s |λ|\r\t\ton |λ|(oNode)\r\t\t\tg(root of oNode, map(go, nest of oNode))\r\t\tend |λ|\r\tend script\r\t|λ|(tree) of go\rend foldTree",
  "fromEnum": "-- fromEnum :: Enum a => a -> Int\ron fromEnum(x)\r\tset c to class of x\r\tif c is boolean then\r\t\tif x then\r\t\t\t1\r\t\telse\r\t\t\t0\r\t\tend if\r\telse if c is text then\r\t\tif x ≠ \"\" then\r\t\t\tid of x\r\t\telse\r\t\t\tmissing value\r\t\tend if\r\telse\r\t\tx as integer\r\tend if\rend fromEnum",
  "fromLeft": "-- fromLeft :: a -> Either a b -> a\ron fromLeft(def, lr)\r\tif isLeft(lr) then\r\t\t|Left| of lr\r\telse\r\t\tdef\r\tend if\rend fromLeft",
  "fromMaybe": "-- fromMaybe :: a -> Maybe a -> a\ron fromMaybe(d, mb)\r\tif Nothing of mb then\r\t\tdef\r\telse\r\t\tJust of mb\r\tend if\rend fromMaybe",
  "fromRight": "-- fromRight :: b -> Either a b -> b\ron fromRight(def, lr)\r\tif isRight(lr) then\r\t\t|Right| of lr\r\telse\r\t\tdef\r\tend if\rend fromRight",
  "fst": "-- fst :: (a, b) -> a\ron fst(tpl)\r\tif class of tpl is record then\r\t\t|1| of tpl\r\telse\r\t\titem 1 of tpl\r\tend if\rend fst",
  "gcd": "-- gcd :: Int -> Int -> Int\ron gcd(a, b)\r\tset x to abs(a)\r\tset y to abs(b)\r\trepeat until y = 0\r\t\tif x > y then\r\t\t\tset x to x - y\r\t\telse\r\t\t\tset y to y - x\r\t\tend if\r\tend repeat\r\treturn x\rend gcd",
  "genericIndexMay": "-- genericIndexMay :: [a] -> Int -> Maybe a\ron genericIndexMay(xs, i)\r\tif i < (length of xs) and i ≥ 0 then\r\t\tJust(item (i + 1) of xs)\r\telse\r\t\tNothing()\r\tend if\rend genericIndexMay",
  "getCurrentDirectory": "-- getCurrentDirectory :: IO FilePath\ron getCurrentDirectory()\r\tset ca to current application\r\tca's NSFileManager's defaultManager()'s currentDirectoryPath as string\rend getCurrentDirectory",
  "getDirectoryContents": "-- getDirectoryContents :: FilePath -> IO [FilePath]\ron getDirectoryContents(strPath)\r\tset ca to current application\r\t(ca's NSFileManager's defaultManager()'s ¬\r\t\tcontentsOfDirectoryAtPath:(stringByStandardizingPath of (¬\r\t\t\tca's NSString's stringWithString:(strPath))) ¬\r\t\t\t|error|:(missing value)) as list\rend getDirectoryContents",
  "getFinderDirectory": "-- getFinderDirectory :: IO FilePath\ron getFinderDirectory()\r\ttell application \"Finder\" to POSIX path of (insertion location as alias)\rend getFinderDirectory",
  "getHomeDirectory": "-- getHomeDirectory :: IO FilePath\ron getHomeDirectory()\r\tcurrent application's NSHomeDirectory() as string\rend getHomeDirectory",
  "getTemporaryDirectory": "-- getTemporaryDirectory :: IO FilePath\ron getTemporaryDirectory()\r\tcurrent application's NSTemporaryDirectory() as string\rend getTemporaryDirectory",
  "group": "-- group :: Eq a => [a] -> [[a]]\non group(xs)\n\tscript eq\n\t\ton |λ|(a, b)\n\t\t\ta = b\n\t\tend |λ|\n\tend script\n\t\n\tgroupBy(eq, xs)\nend group",
  "groupBy": "-- Typical usage: groupBy(on(eq, f), xs)\n-- groupBy :: (a -> a -> Bool) -> [a] -> [[a]]\ron groupBy(f, xs)\r\tset mf to mReturn(f)\r\t\r\tscript enGroup\r\t\ton |λ|(a, x)\r\t\t\tif length of (active of a) > 0 then\r\t\t\t\tset h to item 1 of active of a\r\t\t\telse\r\t\t\t\tset h to missing value\r\t\t\tend if\r\t\t\t\r\t\t\tif h is not missing value and mf's |λ|(h, x) then\r\t\t\t\t{active:(active of a) & {x}, sofar:sofar of a}\r\t\t\telse\r\t\t\t\t{active:{x}, sofar:(sofar of a) & {active of a}}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\tif length of xs > 0 then\r\t\tset dct to foldl(enGroup, {active:{item 1 of xs}, sofar:{}}, tail(xs))\r\t\tif length of (active of dct) > 0 then\r\t\t\tsofar of dct & {active of dct}\r\t\telse\r\t\t\tsofar of dct\r\t\tend if\r\telse\r\t\t{}\r\tend if\rend groupBy",
  "groupSortOn": "-- Sort and group a list by comparing the results of a key function\n-- applied to each element. groupSortOn f is equivalent to\n-- groupBy eq $ sortBy (comparing f),\n-- but has the performance advantage of only evaluating f once for each\n-- element in the input list.\n-- This is a decorate-(group.sort)-undecorate pattern, as in the\n-- so-called 'Schwartzian transform'.\n-- Groups are arranged from from lowest to highest.\n-- groupSortOn :: Ord b => (a -> b) -> [a] -> [a]\r-- groupSortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\ron groupSortOn(f, xs)\r\tscript keyBool\r\t\ton |λ|(a, x)\r\t\t\tif class of x is boolean then\r\t\t\t\t{asc:x, fbs:fbs of a}\r\t\t\telse\r\t\t\t\t{asc:true, fbs:({Tuple(x, asc of a)} & fbs of a)}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tset {fs, bs} to {|1|, |2|} of unzip(fbs of foldl(keyBool, ¬\r\t\t{asc:true, fbs:{}}, flatten({f})))\r\t\r\tset intKeys to length of fs\r\tset ca to current application\r\tscript dec\r\t\tproperty gs : map(my mReturn, fs)\r\t\ton |λ|(x)\r\t\t\tset nsDct to (ca's NSMutableDictionary's ¬\r\t\t\t\tdictionaryWithDictionary:{val:x})\r\t\t\trepeat with i from 1 to intKeys\r\t\t\t\t(nsDct's setValue:((item i of gs)'s |λ|(x)) ¬\r\t\t\t\t\tforKey:(character id (96 + i)))\r\t\t\tend repeat\r\t\t\tnsDct as record\r\t\tend |λ|\r\tend script\r\t\r\tscript descrip\r\t\ton |λ|(bool, i)\r\t\t\tca's NSSortDescriptor's ¬\r\t\t\t\tsortDescriptorWithKey:(character id (96 + i)) ¬\r\t\t\t\t\tascending:bool\r\t\tend |λ|\r\tend script\r\t\r\tscript grpUndec\r\t\ton |λ|(grp)\r\t\t\tscript\r\t\t\t\ton |λ|(x)\r\t\t\t\t\tval of x\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tmap(result, grp)\r\t\tend |λ|\r\tend script\r\t\r\tscript aEq\r\t\ton |λ|(p, q)\r\t\t\t(a of p) = (a of q)\r\t\tend |λ|\r\tend script\r\t\r\t-- Sorted, grouped, undecorated\r\tmap(grpUndec, ¬\r\t\tgroupBy(aEq, ((ca's NSArray's arrayWithArray:map(dec, xs))'s ¬\r\t\t\tsortedArrayUsingDescriptors:map(descrip, bs)) as list))\rend groupSortOn",
  "GT": "-- GT :: Ordering\nproperty |GT| : {type:\"Ordering\", value:1}",
  "head": "-- head :: [a] -> a\ron head(xs)\r\tif xs = {} then\r\t\tmissing value\r\telse\r\t\titem 1 of xs\r\tend if\rend head",
  "headMay": "-- headMay :: [a] -> Maybe a\ron headMay(xs)\r\tif xs = {} then\r\t\tNothing()\r\telse\r\t\tJust(item 1 of xs)\r\tend if\rend headMay",
  "id": "-- id :: a -> a\ron |id|(x)\r\tx\rend |id|",
  "indented": "-- indented :: String -> String -> String\ron indented(strIndent, s)\r\tscript\r\t\ton |λ|(x)\r\t\t\tif x ≠ \"\" then\r\t\t\t\tstrIndent & x\r\t\t\telse\r\t\t\t\tx\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tunlines(map(result, |lines|(s)))\rend indented",
  "index": "-- index (!!) :: [a] -> Int -> a\ron |index|(xs, i)\r\titem i of xs\rend |index|",
  "init": "-- init :: [a] -> [a]\r-- init :: [String] -> [String]\ron init(xs)\r\tset blnString to class of xs = string\r\tset lng to length of xs\r\t\r\tif lng > 1 then\r\t\tif blnString then\r\t\t\ttext 1 thru -2 of xs\r\t\telse\r\t\t\titems 1 thru -2 of xs\r\t\tend if\r\telse if lng > 0 then\r\t\tif blnString then\r\t\t\t\"\"\r\t\telse\r\t\t\t{}\r\t\tend if\r\telse\r\t\tmissing value\r\tend if\rend init\r",
  "initMay": "-- initMay :: [a] -> Maybe [a]\r-- initMay :: [String] -> Maybe [String]\ron initMay(xs)\r\tset blnString to class of xs = string\r\tset lng to length of xs\r\tif lng > 1 then\r\t\tif blnString then\r\t\t\tJust(text 1 thru -2 of xs)\r\t\telse\r\t\t\tJust(items 1 thru -2 of xs)\r\t\tend if\r\telse if lng > 0 then\r\t\tif blnString then\r\t\t\tJust(\"\")\r\t\telse\r\t\t\tJust({})\r\t\tend if\r\telse\r\t\tNothing()\r\tend if\rend initMay",
  "inits": "-- inits :: [a] -> [[a]]\n-- inits :: String -> [String]\non inits(xs)\n\tscript elemInit\n\t\ton |λ|(_, i, xs)\n\t\t\titems 1 thru i of xs\n\t\tend |λ|\n\tend script\n\t\n\tscript charInit\n\t\ton |λ|(_, i, xs)\n\t\t\ttext 1 thru i of xs\n\t\tend |λ|\n\tend script\n\t\n\tif class of xs is string then\n\t\t{\"\"} & map(charInit, xs)\n\telse\n\t\t{{}} & map(elemInit, xs)\n\tend if\nend inits",
  "insert": "-- insert :: Ord a => a -> [a] -> [a]\ron insert(x, ys)\r\tinsertBy(my compare, x, ys)\rend insert",
  "insertBy": "-- insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\ron insertBy(cmp, x, ys)\r\tset lng to length of ys\r\tif lng > 0 then\r\t\ttell mReturn(cmp)\r\t\t\tset bln to false\r\t\t\trepeat with i from 1 to lng\r\t\t\t\tif |λ|(item i of ys, x) > 0 then\r\t\t\t\t\tset bln to true\r\t\t\t\t\texit repeat\r\t\t\t\tend if\r\t\t\tend repeat\r\t\tend tell\r\t\tif bln then\r\t\t\tif i > 1 then\r\t\t\t\titems 1 thru (i - 1) of ys & x & items i thru -1 of ys\r\t\t\telse\r\t\t\t\t{x} & ys\r\t\t\tend if\r\t\telse\r\t\t\tys & x\r\t\tend if\r\telse\r\t\t{x}\r\tend if\rend insertBy",
  "insertMap": "-- insertMap :: Dict -> String -> a -> Dict\ron insertMap(rec, k, v)\r\tset ca to current application\r\tset nsDct to (ca's NSMutableDictionary's dictionaryWithDictionary:rec)\r\tnsDct's setValue:v forKey:(k as string)\r\tnsDct as record\rend insertMap",
  "intercalate": "-- intercalate :: [a] -> [[a]] -> [a]\r-- intercalate :: String -> [String] -> String\ron intercalate(sep, xs)\r  concat(intersperse(sep, xs))\rend intercalate",
  "intercalateS": "-- intercalateS :: String -> [String] -> String\non intercalateS(sep, xs)\n    set {dlm, my text item delimiters} to {my text item delimiters, sep}\n    set s to xs as text\n    set my text item delimiters to dlm\n    return s\nend intercalateS",
  "intersect": "-- intersect :: (Eq a) => [a] -> [a] -> [a]\ron intersect(xs, ys)\r\tif length of xs < length of ys then\r\t\tset {shorter, longer} to {xs, ys}\r\telse\r\t\tset {longer, shorter} to {xs, ys}\r\tend if\r\tif shorter ≠ {} then\r\t\tset lst to {}\r\t\trepeat with x in shorter\r\t\t\tif longer contains x then set end of lst to contents of x\r\t\tend repeat\r\t\tlst\r\telse\r\t\t{}\r\tend if\rend intersect",
  "intersectBy": "-- intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\non intersectBy(eq, xs, ys)\n\tif length of xs > 0 and length of ys > 0 then\n\t\tset p to curry(eq)\n\t\tscript matchFound\n\t\t\ton |λ|(x)\n\t\t\t\tany(p's |λ|(x), ys)\n\t\t\tend |λ|\n\t\tend script\n\t\t\n\t\tfilter(matchFound, xs)\n\telse\n\t\t{}\n\tend if\nend intersectBy",
  "intersectionBy": "-- intersectionBy:: (a -> a -> Bool) -> [[a]] -> [a]\ron intersectionBy(fnEq, xs)\r\tscript\r\t\tproperty eq : mReturn(fnEq)\r\t\ton |λ|(a, x)\r\t\t\tintersectBy(eq, a, x)\r\t\tend |λ|\r\tend script\r\tfoldr1(result, xs)\rend intersectionBy",
  "intersperse": "-- intersperse(0, [1,2,3]) -> [1, 0, 2, 0, 3]\n-- intersperse :: Char -> String -> String\r-- intersperse :: a -> [a] -> [a]\ron intersperse(sep, xs)\r\tset lng to length of xs\r\tif lng > 1 then\r\t\tset acc to {item 1 of xs}\r\t\trepeat with i from 2 to lng\r\t\t\tset acc to acc & {sep, item i of xs}\r\t\tend repeat\r\t\tif class of xs is string then\r\t\t\tconcat(acc)\r\t\telse\r\t\t\tacc\r\t\tend if\r\telse\r\t\txs\r\tend if\rend intersperse",
  "intToDigit": "-- intToDigit :: Int -> Char\ron intToDigit(n)\r\tif n ≥ 0 and n < 16 then\r\t\tcharacter (n + 1) of \"0123456789ABCDEF\"\r\telse\r\t\t\"?\"\r\tend if\rend intToDigit",
  "isAlpha": "-- isAlpha::Char - > Bool\ron isAlpha(c)\r\tset ca to current application\r\tset oRgx to ca's NSRegularExpression's ¬\r\t\tregularExpressionWithPattern:(\"[A-Za-z0-9\\\\u00C0-\\\\u00FF]\") ¬\r\t\t\toptions:(ca's NSRegularExpressionAnchorsMatchLines as integer) ¬\r\t\t\t|error|:(missing value)\r\tset oString to ca's NSString's stringWithString:c\r\t0 < (oRgx's numberOfMatchesInString:oString options:0 ¬\r\t\trange:{location:0, |length|:1})\rend isAlpha",
  "isChar": "-- isChar :: a -> Bool\ron isChar(x)\r\tclass of x is string and length of x is 1\rend isChar",
  "isDigit": "-- isDigit :: Char -> Bool\ron isDigit(c)\r\tset d to (id of c) - 48 -- id of \"0\"\r\td ≥ 0 and d ≤ 9\rend isDigit",
  "isInfixOf": "-- isInfixOf :: Eq a => [a] -> [a] -> Bool\r-- isInfixOf :: String -> String -> Bool\ron isInfixOf(needle, haystack)\r\thaystack contains needle\rend isInfixOf",
  "isLeft": "-- isLeft :: Either a b -> Bool\ron isLeft(x)\r\tset dct to current application's ¬\r\t\tNSDictionary's dictionaryWithDictionary:x\r\t(dct's objectForKey:\"type\") as text = \"Either\" and ¬\r\t\t(dct's objectForKey:\"Right\") as list = {missing value}\rend isLeft",
  "isLower": "-- isLower :: Char -> Bool\ron isLower(c)\r\tset d to (id of c) - 97 -- id of \"a\"\r\td ≥ 0 and d < 26\rend isLower",
  "isMaybe": "use framework \"Foundation\"\nuse scripting additions\n-- isMaybe :: a -> Bool\ron isMaybe(x)\r\tif class of x is record then\r\t\tset ca to current application\r\t\tset v to ((ca's NSDictionary's ¬\r\t\t\tdictionaryWithDictionary:x)'s ¬\r\t\t\tobjectForKey:\"type\")\r\t\tv is not missing value ¬\r\t\t\tand (v's isKindOfClass:(ca's NSString)) ¬\r\t\t\tand (v as string = \"Maybe\")\r\telse\r\t  false\r\tend if\rend isMaybe",
  "isNull": "-- isNull :: [a] -> Bool\r-- isNull :: String -> Bool\ron isNull(xs)\r\tif class of xs is string then\r\t\txs = \"\"\r\telse\r\t\txs = {}\r\tend if\rend isNull",
  "iso8601Local": "-- iso8601Local :: Date -> String\ron iso8601Local(dte)\r\t(dte as «class isot» as string)\rend iso8601Local",
  "isPrefixOf": "-- isPrefixOf takes two lists or strings and returns \n--  true if and only if the first is a prefix of the second.\n-- isPrefixOf :: [a] -> [a] -> Bool\r-- isPrefixOf :: String -> String -> Bool\ron isPrefixOf(xs, ys)\r  set intX to length of xs\r\tif intX < 1 then\r\t\ttrue\r\telse if intX > length of ys then\r\t\tfalse\r\telse if class of xs is string then\r\t\t(offset of xs in ys) = 1\r\telse\r\t\tset {xxt, yyt} to {Just of uncons(xs), Just of uncons(ys)}\r\t\t((|1| of xxt) = (|1| of yyt)) and isPrefixOf(|2| of xxt, |2| of yyt)\r\tend if\rend isPrefixOf",
  "isRight": "-- isRight :: Either a b -> Bool\ron isRight(x)\r\tset dct to current application's ¬\r\t\tNSDictionary's dictionaryWithDictionary:x\r\t(dct's objectForKey:\"type\") as text = \"Either\" and ¬\r\t\t(dct's objectForKey:\"Left\") as list = {missing value}\rend isRight",
  "isSortedBy": "-- The 'isSortedBy' function returns true iff the predicate returns true\n-- for all adjacent pairs of elements in the list.\n-- isSortedBy :: (a -> a -> Bool) -> [a] -> Bool\ron isSortedBy(cmp, xs)\r\tscript LE\r\t\ton |λ|(x)\r\t\t\tx < 1\r\t\tend |λ|\r\tend script\r\t(length of xs < 2) or all(LE, zipWith(cmp, xs, tail(xs)))\rend isSortedBy",
  "isSpace": "-- isSpace :: Char -> Bool\ron isSpace(c)\r\tset i to id of c\r\ti = 32 or (i ≥ 9 and i ≤ 13)\rend isSpace",
  "isSubsequenceOf": "-- isSubsequenceOf :: Eq a => [a] -> [a] -> Bool\r-- isSubsequenceOf :: String -> String -> Bool\ron isSubsequenceOf(xs, ys)\r\tscript iss\r\t\ton |λ|(a, b)\r\t\t\tif a ≠ {} then\r\t\t\t\tif b ≠ {} then\r\t\t\t\t\tif item 1 of a = item 1 of b then\r\t\t\t\t\t\t|λ|(rest of a, rest of b)\r\t\t\t\t\telse\r\t\t\t\t\t\t|λ|(a, rest of b)\r\t\t\t\t\tend if\r\t\t\t\telse\r\t\t\t\t\tfalse\r\t\t\t\tend if\r\t\t\telse\r\t\t\t\ttrue\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\tif class of xs = string then\r\t\ttell iss to |λ|(characters of xs, characters of ys)\r\telse\r\t\ttell iss to |λ|(xs, ys)\r\tend if\rend isSubsequenceOf",
  "isSuffixOf": "-- isSuffixOf :: Eq a => [a] -> [a] -> Bool\r-- isSuffixOf :: String -> String -> Bool \ron isSuffixOf(suffix, main)\r\tif class of suffix is string then\r\t\t(offset of suffix in main) = 1 + (length of main) - (length of suffix)\r\telse\r\t\tset lngSuffix to length of suffix\r\t\tif lngSuffix = 0 then\r\t\t\ttrue\r\t\telse\r\t\t\tset lngMain to length of main\r\t\t\tset lngDelta to lngMain - lngSuffix\r\t\t\tif lngDelta < 0 or lngMain = 0 then\r\t\t\t\tfalse\r\t\t\telse\r\t\t\t\trepeat with i from 1 to lngSuffix\r\t\t\t\t\tif item i of suffix ≠ item (lngDelta + i) of main then return false\r\t\t\t\tend repeat\r\t\t\t\ttrue\r\t\t\tend if\r\t\tend if\r\tend if\rend isSuffixOf",
  "isUpper": "-- isUpper :: Char -> Bool\ron isUpper(c)\r\tset d to (id of c) - 65 -- id of \"A\"\r\td ≥ 0 and d < 26\rend isUpper",
  "iterateUntil": "-- iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]\ron iterateUntil(p, f, x)\r\tscript\r\t\tproperty mp : mReturn(p)'s |λ|\r\t\tproperty mf : mReturn(f)'s |λ|\r\t\tproperty lst : {x}\r\t\ton |λ|(v)\r\t\t\trepeat until mp(v)\r\t\t\t\tset v to mf(v)\r\t\t\t\tset end of lst to v\r\t\t\tend repeat\r\t\t\treturn lst\r\t\tend |λ|\r\tend script\r\t|λ|(x) of result\rend iterateUntil",
  "jsonLog": "-- jsonLog :: a -> IO ()\non jsonLog(e)\n\tlog showJSON(e)\nend jsonLog",
  "jsonParseLR": "-- jsonParseLR :: String -> Either String a\ron jsonParseLR(s)\r\tset ca to current application\r\tset {x, e} to ca's NSJSONSerialization's ¬\r\t\tJSONObjectWithData:((ca's NSString's stringWithString:s)'s ¬\r\t\t\tdataUsingEncoding:(ca's NSUTF8StringEncoding)) ¬\r\t\t\toptions:0 |error|:(reference)\r\t\r\tif x is missing value then\r\t\t|Left|(e's localizedDescription() as string)\r\telse\r\t\tif 1 = (x's isKindOfClass:(ca's NSArray)) as integer then\r\t\t\t|Right|(x as list)\r\t\telse\r\t\t\t|Right|(item 1 of (x as list))\r\t\tend if\r\tend if\rend jsonParseLR",
  "Just": "-- Just :: a -> Just a\ron Just(x)\r\t{type: \"Maybe\", Nothing:false, Just:x}\rend Just",
  "justifyLeft": "-- justifyLeft :: Int -> Char -> String -> String\ron justifyLeft(n, cFiller, strText)\r\tif n > length of strText then\r\t\ttext 1 thru n of (strText & replicate(n, cFiller))\r\telse\r\t\tstrText\r\tend if\rend justifyLeft",
  "justifyRight": "-- justifyRight :: Int -> Char -> String -> String\ron justifyRight(n, cFiller, strText)\r\tif n > length of strText then\r\t\ttext -n thru -1 of ((replicate(n, cFiller) as text) & strText)\r\telse\r\t\tstrText\r\tend if\rend justifyRight",
  "keys": "-- keys :: Dict -> [String]\ron keys(rec)\r\t(current application's NSDictionary's dictionaryWithDictionary:rec)'s allKeys() as list\rend keys",
  "kleisliCompose": "-- Kleisli composition LR\n-- kleisliCompose (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)\ron kleisliCompose(f, g)\r\tscript\r\t\ton |λ|(x)\r\t\t\tbind(mReturn(f)'s |λ|(x), g)\r\t\tend |λ|\r\tend script\rend kleisliCompose",
  "last": "-- last :: [a] -> a\ron |last|(xs)\r\t\titem -1 of xs\rend |last|",
  "lastMay": "-- lastMay :: [a] -> Maybe a\ron lastMay(xs)\r\tif length of xs > 0 then\r\t\tJust(item -1 of xs)\r\telse\r\t\tNothing()\r\tend if\rend lastMay",
  "lcm": "-- lcm :: Int -> Int -> Int\ron lcm(x, y)\r\tif (x = 0 or y = 0) then\r\t\t0\r\telse\r\t\tabs(floor(x / (gcd(x, y))) * y)\r\tend if\rend lcm",
  "Left": "-- Left :: a -> Either a b\ron |Left|(x)\r\t{type:\"Either\", |Left|:x, |Right|:missing value}\rend |Left|",
  "lefts": "-- lefts :: [Either a b] -> [a]\ron lefts(xs)\r\tscript\r\t\ton |λ|(x)\r\t\t\tif class of x is record then\r\t\t\t\tset ks to keys(x)\r\t\t\t\tks contains \"type\" and ks contains \"Left\"\r\t\t\telse\r\t\t\t\tfalse\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tfilter(result, xs)\rend lefts",
  "length": "-- length :: [a] -> Int\ron |length|(xs)\r\tlength of xs\rend |length|",
  "levelNodes": "-- levelNodes :: Tree a -> [[Tree a]]\ron levelNodes(tree)\r\tscript p\r\t\ton |λ|(xs)\r\t\t\tlength of xs < 1\r\t\tend |λ|\r\tend script\r\t\r\tscript f\r\t\ton |λ|(xs)\r\t\t\tscript nest\r\t\t\t\ton |λ|(Node)\r\t\t\t\t\tnest of Node\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tconcatMap(nest, xs)\r\t\tend |λ|\r\tend script\r\t\r\titerateUntil(p, f, {tree})\rend levelNodes",
  "levels": "-- levels :: Tree a -> [[a]]\ron levels(tree)\r\tscript nextLayer\r\t\ton |λ|(xs)\r\t\t\tscript\r\t\t\t\ton |λ|(x)\r\t\t\t\t\tnest of x\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tconcatMap(result, xs)\r\t\tend |λ|\r\tend script\r\t\r\tscript roots\r\t\ton |λ|(xs)\r\t\t\tscript\r\t\t\t\ton |λ|(x)\r\t\t\t\t\troot of x\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tmap(result, xs)\r\t\tend |λ|\r\tend script\r\t\r\tmap(roots, iterateUntil(my isNull, nextLayer, {tree}))\rend levels",
  "liftA2": "-- Lift a binary function to actions.\n-- e.g.\n-- liftA2(mult, {1, 2, 3}, {4, 5, 6}) \n--> {4, 5, 6, 8, 10, 12, 12, 15, 18}\n-- liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\ron liftA2(f, a, b)\r    set c to class of a\r    if c is list then\r        liftA2List(f, a, b)\r    else if c is record and keys(a) contains \"type\" then\r        set t to type of a\r        if t = \"Either\" then\r            liftA2LR(f, a, b)\r        else if t = \"Maybe\" then\r            liftA2Maybe(f, a, b)\r        else if t = \"Tuple\" then\r            liftA2Tuple(f, a, b)\r        else\r            missing value\r        end if\r    else\r        missing value\r    end if\rend liftA2",
  "liftA2List": "-- liftA2List :: (a -> b -> c) -> [a] -> [b] -> [c]\ron liftA2List(f, xs, ys)\r\tscript\r\t\tproperty g : mReturn(f)'s |λ|\r\t\ton |λ|(x)\r\t\t\tscript\r\t\t\t\ton |λ|(y)\r\t\t\t\t\t{g(x, y)}\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tconcatMap(result, ys)\r\t\tend |λ|\r\tend script\r\tconcatMap(result, xs)\rend liftA2List",
  "liftA2LR": "-- liftA2LR :: (a -> b -> c) -> Either d a -> Either d b -> Either d c\ron liftA2LR(f, a, b)\r\tset x to |Right| of a\r\tset y to |Right| of b\r\tif x is missing value then\r\t\ta\r\telse if y is missing value then\r\t\tb\r\telse\r\t\t|Right|(|λ|(x, y) of mReturn(f))\r\tend if\rend liftA2LR",
  "liftA2Maybe": "-- liftA2Maybe :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\ron liftA2Maybe(f, a, b)\r\tif Nothing of a then\r\t\ta\r\telse if Nothing of b then\r\t\tb\r\telse\r\t\tJust(|λ|(Just of a, Just of b) of mReturn(f))\r\tend if\rend liftA2Maybe",
  "liftA2Tuple": "-- liftA2Tuple :: Monoid m => (a -> b -> c) -> (m, a) -> (m, b) -> (m, c)\ron liftA2Tuple(f, a, b)\r\tTuple(mappend(|1| of a, |1| of b), mReturn(f)'s |λ|(|2| of a, |2| of b))\rend liftA2Tuple",
  "liftM2": "--  liftM2 (+) [0,1] [0,2] = [0,2,1,3]\n-- liftM2 :: (a -> b -> c) -> [a] -> [b] -> [c]\ron liftM2(f, a, b)\r\tap(map(curry(f), a), b)\rend liftM2",
  "liftMmay": "-- liftMmay :: (a -> b) -> (Maybe a -> Maybe b)\ron liftMmay(f)\r\tscript\r\t\ton |λ|(mb)\r\t\t\tif Nothing of mb then\r\t\t\t\tmb\r\t\t\telse\r\t\t\t\ttell mReturn(f) to |λ|(Just of mb)\r\t\t\tend if\r\t\tend |λ|\r\tend script\rend liftMmay",
  "lines": "-- lines :: String -> [String]\ron |lines|(xs)\r\tparagraphs of xs\rend |lines|",
  "listDirectory": "-- listDirectory :: FilePath -> [FilePath]\ron listDirectory(strPath)\r\tset ca to current application\r\tunwrap(ca's NSFileManager's defaultManager()'s ¬\r\t\tcontentsOfDirectoryAtPath:(unwrap(stringByStandardizingPath of ¬\r\t\t\twrap(strPath))) |error|:(missing value))\rend listDirectory",
  "listFromTuple": "-- listFromTuple (a, a ...) -> [a]\ron listFromTuple(tpl)\r\tscript\r\t\ton |λ|(k)\r\t\t\tJust of lookupDict(k, tpl)\r\t\tend |λ|\r\tend script -- All keys except 'type' at end\r\tmap(result, items 1 thru -2 of sort(keys(tpl)))\rend listFromTuple",
  "listToMaybe": "-- The listToMaybe function returns Nothing on \r-- an empty list or Just the head of the list.\n-- listToMaybe :: [a] -> Maybe a\ron listToMaybe(xs)\r\tif xs ≠ {} then\r\t\tJust(item 1 of xs)\r\telse\r\t\tNothing()\r\tend if\rend listToMaybe",
  "log": "-- log :: Float -> Float\ron |log|(n)\r\tJust of evalJSMay((\"Math.log(\" & n as string) & \")\")\rend |log|",
  "lookup": "-- use framework \"Foundation\"\n-- use scripting additions\n-- lookup :: Eq a => a -> Container -> Maybe b\ron lookup(k, m)\r\tset c to class of m\r\tif c is list then\r\t\tlookupTuples(k, m)\r\telse if c = record then\r\t\tlookupDict(k, m)\r\telse\r\t\tNothing()\r\tend if\rend lookup",
  "lookupDict": "-- lookupDict :: a -> Dict -> Maybe b\ron lookupDict(k, dct)\r\tset ca to current application\r\tset v to (ca's NSDictionary's dictionaryWithDictionary:dct)'s objectForKey:k\r\tif v ≠ missing value then\r\t\tJust(item 1 of ((ca's NSArray's arrayWithObject:v) as list))\r\telse\r\t\tNothing()\r\tend if\rend lookupDict",
  "lookupTuples": "-- lookupTuples :: Eq a => a -> [(a, b)] -> Maybe b\ron lookupTuples(k, xs)\r\tscript keyMatch\r\t\ton |λ|(x)\r\t\t\tk = fst(x)\r\t\tend |λ|\r\tend script\r\t\r\tscript harvestMay\r\t\ton |λ|(kv)\r\t\t\tJust(snd(kv))\r\t\tend |λ|\r\tend script\r\t\r\tbindMay(find(keyMatch, xs), harvestMay)\rend lookupTuples",
  "LT": "-- LT :: Ordering\nproperty |LT| : {type:\"Ordering\", value:-1}",
  "map": "-- map :: (a -> b) -> [a] -> [b]\ron map(f, xs)\r\ttell mReturn(f)\r\t\tset lng to length of xs\r\t\tset lst to {}\r\t\trepeat with i from 1 to lng\r\t\t\tset end of lst to |λ|(item i of xs, i, xs)\r\t\tend repeat\r\t\treturn lst\r\tend tell\rend map",
  "mapAccumL": "-- 'The mapAccumL function behaves like a combination of map and foldl; \n-- it applies a function to each element of a list, passing an \n-- accumulating parameter from |Left| to |Right|, and returning a final \n-- value of this accumulator together with the new list.' (see Hoogle)\n-- mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\non mapAccumL(f, acc, xs)\n\tscript\n\t\ton |λ|(a, x, i)\n\t\t\ttell mReturn(f) to set pair to |λ|(|1| of a, x, i)\n\t\t\tTuple(|1| of pair, (|2| of a) & {|2| of pair})\n\t\tend |λ|\n\tend script\n\t\n\tfoldl(result, Tuple(acc, []), xs)\nend mapAccumL",
  "mapAccumL_Tree": "-- mapAccumL_Tree :: (acc -> x -> (acc, y)) -> acc -> Tree -> (acc, Tree)\ron mapAccumL_Tree(f, acc, tree)\r\tscript go\r\t\tproperty mf : mReturn(f)'s |λ|\r\t\ton |λ|(a, x)\r\t\t\tset pair to f(a, root of x)\r\t\t\tset tpl to mapAccumL(go, item 1 of pair, nest of x)\r\t\t\tTuple(item 1 of tpl, Node(item 2 of pair, item 2 of tpl))\r\t\tend |λ|\r\tend script\r\t|λ|(acc, tree) of go\rend mapAccumL_Tree",
  "mapAccumR": "-- 'The mapAccumR function behaves like a combination of map and foldr; \n--  it applies a function to each element of a list, passing an accumulating \n--  parameter from |Right| to |Left|, and returning a final value of this \n--  accumulator together with the new list.' (see Hoogle)\n-- mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\ron mapAccumR(f, acc, xs)\r\tscript\r\t\ton |λ|(x, a, i)\r\t\t\ttell mReturn(f) to set pair to |λ|(|1| of a, x, i)\r\t\t\tTuple(|1| of pair, (|2| of pair) & |2| of a)\r\t\tend |λ|\r\tend script\r\tfoldr(result, Tuple(acc, []), xs)\rend mapAccumR",
  "mapFromList": "-- mapFromList :: [(k, v)] -> Dict\ron mapFromList(kvs)\r\tset tpl to unzip(kvs)\r\tscript\r\t\ton |λ|(x)\r\t\t\tx as string\r\t\tend |λ|\r\tend script\r\t(current application's NSDictionary's ¬\r\t\tdictionaryWithObjects:(|2| of tpl) ¬\r\t\t\tforKeys:map(result, |1| of tpl)) as record\rend mapFromList",
  "mapKeys": "-- mapKeys :: (Key -> Key) -> IntMap a -> IntMap a\ron mapKeys(f, dct)\r\tscript\r\t\tproperty g : mReturn(f)\r\t\ton |λ|(kv)\r\t\t\tset {k, v} to kv\r\t\t\t{g's |λ|(k), v}\r\t\tend |λ|\r\tend script\r\tmap(result, zip(keys(dct), elems(dct)))\rend mapKeys",
  "mapMaybe": "-- The mapMaybe function is a version of map which can throw out\r-- elements. In particular, the functional argument returns\r-- something of type Maybe b. If this is Nothing, no element is\r-- added on to the result list. If it just Just b, then b is\r-- included in the result list.\n-- mapMaybe :: (a -> Maybe b) -> [a] -> [b]\ron mapMaybe(mf, xs)\r\tconcatMap(compose(mf, my maybeToList), xs)\rend mapMaybe",
  "mappend": "-- mappend (<>) :: Monoid a => a -> a -> a\ron mappend(a, b)\r\tif class of a is record and class of b is record then\r\t\tscript instanceMay\r\t\t\ton |λ|(strType)\r\t\t\t\tset mb to lookup(strType, ¬\r\t\t\t\t\t{Maybe:mappendMaybe, Ordering:mappendOrdering, Tuple:mappendTuple})\r\t\t\tend |λ|\r\t\tend script\r\t\tset mbi to bindMay(lookup(\"type\", a), instanceMay)\r\t\tif Nothing of mbi then\r\t\t\ta & b\r\t\telse\r\t\t\tmReturn(Just of mbi)'s |λ|(a, b)\r\t\tend if\r\telse\r\t\ta & b\r\tend if\rend mappend",
  "mappendComparing": "-- mappendComparing :: [(a -> b)] -> (a -> a -> Ordering)\ron mappendComparing(fs)\r\tscript\r\t\ton |λ|(x, y)\r\t\t\tscript\r\t\t\t\ton |λ|(ordr, f)\r\t\t\t\t\tif ordr ≠ 0 then\r\t\t\t\t\t\tordr\r\t\t\t\t\telse\r\t\t\t\t\t\ttell mReturn(f)\r\t\t\t\t\t\t\tcompare(|λ|(x), |λ|(y))\r\t\t\t\t\t\tend tell\r\t\t\t\t\tend if\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tfoldl(result, 0, fs)\r\t\tend |λ|\r\tend script\rend mappendComparing",
  "mappendComparing2": "-- mappendComparing2 :: [((a -> b), Bool)] -> (a -> a -> Ordering)\ron mappendComparing2(fBools)\r\tscript\r\t\ton |λ|(x, y)\r\t\t\tscript\r\t\t\t\ton |λ|(ord, fb)\r\t\t\t\t\tif ord ≠ |EQ| then\r\t\t\t\t\t\tord\r\t\t\t\t\telse\r\t\t\t\t\t\tset f to |1| of fb\r\t\t\t\t\t\ttell mReturn(f)\r\t\t\t\t\t\t\tif |2| of fb then\r\t\t\t\t\t\t\t\tcompare(|λ|(x), |λ|(y))\r\t\t\t\t\t\t\telse\r\t\t\t\t\t\t\t\tcompare(|λ|(y), |λ|(x))\r\t\t\t\t\t\t\tend if\r\t\t\t\t\t\tend tell\r\t\t\t\t\tend if\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tfoldl(result, 0, fBools)\r\t\tend |λ|\r\tend script\rend mappendComparing",
  "mappendMaybe": "-- mappendMaybe (<>) :: Maybe a -> Maybe a -> Maybe a\ron mappendMaybe(a, b)\r\tif Nothing of a then\r\t\tb\r\telse if Nothing of b then\r\t\ta\r\telse\r\t\tJust(mappend(Just of a, Just of b))\r\tend if\rend mappendMaybe",
  "mappendOrdering": "-- Ordering :: ( LT | EQ | GT ) | ( -1 | 0 | 1 )\n-- mappendOrdering (<>) :: Ordering -> Ordering -> Ordering\ron mappendOrdering(a, b)\r\tif my |EQ| = a then\r\t\tb\r\telse\r\t\ta\r\tend if\rend mappendOrdering",
  "mappendTuple": "-- mappendTuple (<>) :: (a, b) -> (a, b) -> (a, b)\ron mappendTuple(a, b)\r\tTuple(mappend(|1| of a, |1| of b), mappend(|2| of a, |2| of b))\rend mappendTuple",
  "max": "-- max :: Ord a => a -> a -> a\non max(x, y)\n    if x > y then\n        x\n    else\n        y\n    end if\nend max",
  "maximum": "-- maximum :: Ord a => [a] -> a\non maximum(xs)\n\tscript\n\t\ton |λ|(a, b)\n\t\t\tif a is missing value or b > a then\n\t\t\t\tb\n\t\t\telse\n\t\t\t\ta\n\t\t\tend if\n\t\tend |λ|\n\tend script\n\t\n\tfoldl(result, missing value, xs)\nend maximum",
  "maximumBy": "-- maximumBy :: (a -> a -> Ordering) -> [a] -> a\non maximumBy(f, xs)\n\tset cmp to mReturn(f)\n\tscript max\n\t\ton |λ|(a, b)\n\t\t\tif a is missing value or cmp's |λ|(a, b) < 0 then\n\t\t\t\tb\n\t\t\telse\n\t\t\t\ta\n\t\t\tend if\n\t\tend |λ|\n\tend script\n\t\n\tfoldl(max, missing value, xs)\nend maximumBy",
  "maximumByMay": "-- maximumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\ron maximumByMay(f, xs)\r\tset cmp to mReturn(f)\r\tscript max\r\t\ton |λ|(a, b)\r\t\t\tif a is missing value or cmp's |λ|(a, b) < 0 then\r\t\t\t\tb\r\t\t\telse\r\t\t\t\ta\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\tfoldl1May(max, xs)\rend maximumByMay",
  "maximumMay": "-- maximumMay :: Ord a => [a] -> Maybe a\ron maximumMay(xs)\r\tfoldl1May(max, xs)\rend maximumMay",
  "maybe": "-- | The 'maybe' function takes a default value, a function, and a 'Maybe'\n-- value.  If the 'Maybe' value is 'Nothing', the function returns the\n-- default value.  Otherwise, it applies the function to the value inside\n-- the 'Just' and returns the result.\n-- maybe :: b -> (a -> b) -> Maybe a -> b\ron maybe(n, f, mb)\r\tif Nothing of mb then\r\t\tn\r\telse\r\t\ttell mReturn(f) to |λ|(Just of mb)\r\tend if\rend maybe",
  "maybeToList": "-- The maybeToList function returns an empty list when given\n-- Nothing or a singleton list when not given Nothing.\n-- maybeToList :: Maybe a -> [a]\ron maybeToList(mb)\r\tif Nothing of mb then\r\t\t{}\r\telse\r\t\t{Just of mb}\r\tend if\rend maybeToList",
  "mean": "-- mean :: [Num] -> Num\ron mean(xs)\r\tscript\r\t\ton |λ|(a, x)\r\t\t\ta + x\r\t\tend |λ|\r\tend script\r\tfoldl(result, 0, xs) / (length of xs)\rend mean",
  "member": "-- member :: Key -> Dict -> Bool\ron member(k, dct)\r\t((current application's ¬\r\t\tNSDictionary's dictionaryWithDictionary:dct)'s ¬\r\t\tobjectForKey:k) is not missing value\rend member",
  "min": "-- min :: Ord a => a -> a -> a\non min(x, y)\n    if y < x then\n        y\n    else\n        x\n    end if\nend min",
  "minimum": "-- minimum :: Ord a => [a] -> a\ron minimum(xs)\r\tset lng to length of xs\r\tif lng < 1 then return missing value\r\tset m to item 1 of xs\r\trepeat with x in xs\r\t\tset v to contents of x\r\t\tif v < m then set m to v\r\tend repeat\r\treturn m\rend minimum",
  "minimumBy": "-- minimumBy :: (a -> a -> Ordering) -> [a] -> a\ron minimumBy(f, xs)\r\tset lng to length of xs\r\tif lng < 1 then\r\t\tmissing value\r\telse if lng > 1 then\r\t\ttell mReturn(f)\r\t\t\tset v to item 1 of xs\r\t\t\trepeat with x in xs\r\t\t\t\tif |λ|(x, v) < 0 then set v to contents of x\r\t\t\tend repeat\r\t\t\treturn v\r\t\tend tell\r\telse\r\t\titem 1 of xs\r\tend if\rend minimumBy",
  "minimumByMay": "-- minimumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\ron minimumByMay(f, xs)\r\tset lng to length of xs\r\tif lng < 1 then\r\t\tNothing()\r\telse if lng > 1 then\r\t\ttell mReturn(f)\r\t\t\tset v to item 1 of xs\r\t\t\trepeat with x in xs\r\t\t\t\tif |λ|(x, v) < 0 then set v to contents of x\r\t\t\tend repeat\r\t\t\treturn Just(v)\r\t\tend tell\r\telse\r\t\tJust(item 1 of xs)\r\tend if\rend minimumByMay",
  "minimumMay": "-- minimumMay :: [a] -> Maybe a\ron minimumMay(xs)\r\tset lng to length of xs\r\tif lng < 1 then\r\t\tNothing()\r\telse if lng > 1 then\r\t\tset m to item 1 of xs\r\t\trepeat with x in xs\r\t\t\tset v to contents of x\r\t\t\tif v < m then set m to v\r\t\tend repeat\r\t\tJust(m)\r\telse\r\t\tJust(item 1 of xs)\r\tend if\rend minimumMay",
  "mod": "-- Composable wrapper for built-in operator\n-- mod :: Int -> Int -> Int\ron |mod|(n, d)\r\tn mod d\rend |mod|",
  "modificationTime": "-- modificationTime :: FilePath -> Either String Date\ron modificationTime(fp)\r\tscript fs\r\t\ton |λ|(rec)\r\t\t\t|Right|(NSFileModificationDate of rec)\r\t\tend |λ|\r\tend script\r\tbindLR(my fileStatus(fp), fs)\rend modificationTime",
  "mReturn": "-- Lift 2nd class handler function into 1st class script wrapper \n-- mReturn :: First-class m => (a -> b) -> m (a -> b)\ron mReturn(f)\r\tif class of f is script then\r\t\tf\r\telse\r\t\tscript\r\t\t\tproperty |λ| : f\r\t\tend script\r\tend if\rend mReturn",
  "negate": "-- negate :: Num -> Num\ron |negate|(n)\r\t-n\rend |negate|",
  "newUUID": "-- use framework \"Foundation\"\r-- use scripting additions\n-- newUUID :: () -> IO UUID String\ron newUUID()\r\tcurrent application's NSUUID's UUID's UUIDString as string\rend newUUID",
  "Node": "-- Node :: a -> [Tree a] -> Tree a\ron Node(v, xs)\r\t{type:\"Node\", root:v, nest:xs}\rend Node",
  "not": "-- not :: Bool -> Bool\ron |not|(p)\r\tnot p\rend |not|",
  "notElem": "-- notElem :: Eq a => a -> [a] -> Bool\ron notElem(x, xs)\r\txs does not contain x\rend notElem",
  "Nothing": "-- Nothing :: () -> Nothing\ron Nothing()\r\t{type:\"Maybe\", Nothing:true}\rend Nothing",
  "nub": "-- nub :: [a] -> [a]\ron nub(xs)\r\tscript\r\t\ton |λ|(a, b)\r\t\t\ta = b\r\t\tend |λ|\r\tend script\r\tnubBy(result, xs)\rend nub",
  "nubBy": "-- nubBy :: (a -> a -> Bool) -> [a] -> [a]\ron nubBy(f, xs)\r\tset g to mReturn(f)'s |λ|\r\t\r\tscript notEq\r\t\tproperty fEq : g\r\t\ton |λ|(a)\r\t\t\tscript\r\t\t\t\ton |λ|(b)\r\t\t\t\t\tnot fEq(a, b)\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\tend |λ|\r\tend script\r\t\r\tscript go\r\t\ton |λ|(xs)\r\t\t\tif (length of xs) > 1 then\r\t\t\t\tset x to item 1 of xs\r\t\t\t\t{x} & go's |λ|(filter(notEq's |λ|(x), items 2 thru -1 of xs))\r\t\t\telse\r\t\t\t\txs\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\tgo's |λ|(xs)\rend nubBy",
  "odd": "-- odd :: Int -> Bool\ron odd(x)\r\tnot even(x)\rend odd",
  "on": "-- e.g. sortBy(|on|(compare, |length|), [\"epsilon\", \"mu\", \"gamma\", \"beta\"])\n-- on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\ron |on|(f, g)\r\tscript\r\t\ton |λ|(a, b)\r\t\t\ttell mReturn(g) to set {va, vb} to {|λ|(a), |λ|(b)}\r\t\t\ttell mReturn(f) to |λ|(va, vb)\r\t\tend |λ|\r\tend script\rend |on|",
  "or": "-- or :: [Bool] -> Bool\ron |or|(ps)\r\trepeat with p in ps\r\t\tif p then return true\r\tend repeat\r\treturn false\rend |or|",
  "ord": "-- ord :: Char -> Int\ron ord(c)\r\tid of c\rend ord",
  "Ordering": "-- Ordering :: Int -> Ordering\ron Ordering(e)\r\tif e > 0 then\r\t\tset v to 1\r\telse if e < 0 then\r\t\tset v to -1\r\telse\r\t\tset v to 0\r\tend if\r\t{type:\"Ordering\", value:v}\rend Ordering",
  "outdented": "-- All lines in the string outdented by the same amount\n-- (just enough to ensure that the least indented lines \n--  have no remaining indent)\n-- All relative indents are left unchanged\n-- outdented :: String -> String\ron outdented(s)\r\tset xs to |lines|(s)\r\tscript dent\r\t\ton |λ|(x)\r\t\t\tscript isSpace\r\t\t\t\ton |λ|(c)\r\t\t\t\t\tid of c = 32\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tlength of takeWhile(isSpace, x)\r\t\tend |λ|\r\tend script\r\tset n to |λ|(minimumBy(comparing(dent), xs)) of dent\r\tif n < 1 then\r\t\ts\r\telse\r\t\tunlines(map(|λ|(n) of curry(drop), xs))\r\tend if\rend outdented",
  "partition": "-- partition :: predicate -> List -> (Matches, nonMatches)\n-- partition :: (a -> Bool) -> [a] -> ([a], [a])\ron partition(f, xs)\r\ttell mReturn(f)\r\t\tset ys to {}\r\t\tset zs to {}\r\t\trepeat with x in xs\r\t\t\tset v to contents of x\r\t\t\tif |λ|(v) then\r\t\t\t\tset end of ys to v\r\t\t\telse\r\t\t\t\tset end of zs to v\r\t\t\tend if\r\t\tend repeat\r\tend tell\r\tTuple(ys, zs)\rend partition",
  "partitionEithers": "-- partitionEithers :: [Either a b] -> ([a], [b])\ron partitionEithers(xs)\r\tset ys to {}\r\tset zs to {}\r\trepeat with x in xs\r\t\tif isRight(x) then\r\t\t\tset end of zs to x\r\t\telse\r\t\t\tset end of ys to x\r\t\tend if\r\tend repeat\r\tTuple(ys, zs)\rend partitionEithers",
  "permutations": "-- permutations :: [a] -> [[a]]\non permutations(xs)\n\tscript firstElement\n\t\ton |λ|(x)\n\t\t\tscript tailElements\n\t\t\t\ton |λ|(ys)\n\t\t\t\t\t{{x} & ys}\n\t\t\t\tend |λ|\n\t\t\tend script\n\t\t\t\n\t\t\tconcatMap(tailElements, permutations(|delete|(x, xs)))\n\t\tend |λ|\n\tend script\n\t\n\tif length of xs > 0 then\n\t\tconcatMap(firstElement, xs)\n\telse\n\t\t{{}}\n\tend if\nend permutations",
  "permutationsWithRepetition": "-- permutationsWithRepetition :: Int -> [a] -> [[a]]\non permutationsWithRepetition(n, xs)\n\tif length of xs > 0 then\n\t\tfoldl1(curry(my cartesianProduct)'s |λ|(xs), replicate(n, xs))\n\telse\n\t\t{}\n\tend if\nend permutationsWithRepetition",
  "pi": "-- pi :: Float\rpi",
  "plus": "-- plus :: Num -> Num -> Num\ron plus(a, b)\r\ta + b\rend plus",
  "pred": "-- pred :: Enum a => a -> a\ron pred(x)\r\tif isChar(x) then\r\t\tchr(ord(x) - 1)\r\telse\r\t\t(-1) + x\r\tend if\rend pred",
  "product": "-- product :: [Num] -> Num\ron product(xs)\r\tscript multiply\r\t\ton |λ|(a, b)\r\t\t\ta * b\r\t\tend |λ|\r\tend script\r\t\r\tfoldl(multiply, 1, xs)\rend product",
  "properFraction": "-- properFraction :: Real -> (Int, Real)\ron properFraction(n)\r\tset i to (n div 1)\r\tTuple(i, n - i)\rend properFraction",
  "pureList": "-- pureList :: a -> [a]\ron pureList(x)\r\t\t{x}\rend pure",
  "pureLR": "-- pureLR :: a -> Either e a\ron pureLR(x)\r\t|Right|(x)\rend pureLR",
  "pureMay": "-- pureMay :: a -> Maybe a\ron pureMay(x)\r\tJust(x)\rend pureMay",
  "pureT": "-- pureT :: f a -> (a -> f a)\ron pureT(x)\r\tif class of x is record and keys(x) contains \"type\" then\r\t\tset t to type of x\r\t\tif t = \"Either\" then\r\t\t\tpureLR\r\t\telse if t = \"Maybe\" then\r\t\t\tpureMay\r\t\telse if t = \"Tree\" then\r\t\t\tpureTree\r\t\telse if t = \"Tuple\" then\r\t\t\tpureTuple\r\t\telse\r\t\t\tpureList\r\t\tend if\r\telse\r\t\tpureList\r\tend if\rend pureT",
  "pureTree": "-- pureTree :: a -> Tree a\ron pureTree(x)\r\tNode(x, [])\rend pureTree",
  "pureTuple": "-- pureTuple :: a -> (a, a)\ron pureTuple(x)\r\tTuple(\"\", x)\rend pureTuple",
  "quickSort": "-- Adequate for small sorts, but sort :: Ord a => [a] -> [a], (which uses the ObjC\n-- sortedArrayUsingSelector) is the one to use\n-- quickSort :: (Ord a) => [a] -> [a]\ron quickSort(xs)\r\tif length of xs > 1 then\r\t\tset h to item 1 of xs\r\t\tscript\r\t\t\ton |λ|(x)\r\t\t\t\tx ≤ h\r\t\t\tend |λ|\r\t\tend script\r\t\tset {less, more} to partition(result, rest of xs)\r\t\tquickSort(less) & h & quickSort(more)\r\telse\r\t\txs\r\tend if\rend quickSort",
  "quickSortBy": "-- quickSortBy(comparing(my |length|), {\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\", \"iota\", \"kappa\", \"lambda\", \"mu\"})\n-- quickSortBy :: (a -> a -> Ordering) -> [a] -> [a]\ron quickSortBy(cmp, xs)\r\tif length of xs > 1 then\r\t\tset h to item 1 of xs\r\t\tscript\r\t\t\ton |λ|(x)\r\t\t\t\tcmp's |λ|(x, h) ≠ 1\r\t\t\tend |λ|\r\t\tend script\r\t\tset {less, more} to partition(result, rest of xs)\r\t\tquickSortBy(cmp, less) & h & quickSortBy(cmp, more)\r\telse\r\t\txs\r\tend if\rend quickSortBy",
  "quot": "-- quot :: Int -> Int -> Int\non quot(m, n)\n\tm div n\nend quot",
  "quotRem": "-- quotRem :: Int -> Int -> (Int, Int)\ron quotRem(m, n)\r\tTuple(m div n, m mod n)\rend quotRem",
  "raise": "-- raise :: Num -> Int -> Num\ron raise(m, n)\r\tm ^ n\rend raise",
  "randomRInt": "-- randomRInt :: Int -> Int -> Int\ron randomRInt(low, high)\r\tfloor(low + ((random number) * (1 + (high - low))))\rend randomRInt",
  "range": "-- range :: Ix a => (a, a) -> [a]\ron range(ab)\r\tset {a, b} to {|1| of ab, |2| of ab}\r\tif class of a is list then\r\t\tset {xs, ys} to {a, b}\r\telse\r\t\tset {xs, ys} to {{a}, {b}}\r\tend if\r\tset lng to length of xs\r\t\r\tif lng = length of ys then\r\t\tif lng > 1 then\r\t\t\tscript\r\t\t\t\ton |λ|(_, i)\r\t\t\t\t\tenumFromTo(item i of xs, item i of ys)\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tsequence(map(result, xs))\r\t\telse\r\t\t\tenumFromTo(a, b)\r\t\tend if\r\telse\r\t\t{}\r\tend if\rend range",
  "Ratio": "-- Ratio :: Int -> Int -> Ratio\ron Ratio(n, d)\r\t{type:\"Ratio\", n:n, d:d}\rend Ratio",
  "read": "-- read :: Read a => String -> a\ron read (s)\r\trun script s\rend read",
  "readFile": "-- readFile :: FilePath -> IO String\ron readFile(strPath)\r\tset ca to current application\r\tset e to reference\r\tset {s, e} to (ca's NSString's ¬\r\t\tstringWithContentsOfFile:((ca's NSString's ¬\r\t\t\tstringWithString:strPath)'s ¬\r\t\t\tstringByStandardizingPath) ¬\r\t\t\tencoding:(ca's NSUTF8StringEncoding) |error|:(e))\r\tif e is missing value then\r\t\ts as string\r\telse\r\t\t(localizedDescription of e) as string\r\tend if\rend readFile",
  "readFileMay": "-- readFileMay :: FilePath -> Maybe String\ron readFileMay(strPath)\r\tset ca to current application\r\tset e to reference\r\tset {s, e} to (ca's NSString's ¬\r\t\tstringWithContentsOfFile:((ca's NSString's ¬\r\t\t\tstringWithString:strPath)'s ¬\r\t\t\tstringByStandardizingPath) ¬\r\t\t\tencoding:(ca's NSUTF8StringEncoding) |error|:(e))\r\tif e is missing value then\r\t\tJust(s as string)\r\telse\r\t\tNothing()\r\tend if\rend readFileMay",
  "readJSON": "-- readJSON :: String -> a\ron readJSON(strJSON)\r\tset ca to current application\r\tset {x, e} to ca's NSJSONSerialization's ¬\r\t\tJSONObjectWithData:((ca's NSString's stringWithString:strJSON)'s ¬\r\t\t\tdataUsingEncoding:(ca's NSUTF8StringEncoding)) ¬\r\t\t\toptions:0 |error|:(reference)\r\t\r\tif x is missing value then\r\t\terror e's localizedDescription() as text\r\telse\r\t\tif x's isKindOfClass:(ca's NSDictionary) then\r\t\t\tx as record\r\t\telse\r\t\t\tx as list\r\t\tend if\r\tend if\rend readJSON",
  "readJSONLR": "-- readJSONLR :: Read a => String -> Either String a\ron readJSONLR(strJSON)\r\tset ca to current application\r\tset {x, e} to ca's NSJSONSerialization's ¬\r\t\tJSONObjectWithData:((ca's NSString's stringWithString:strJSON)'s ¬\r\t\t\tdataUsingEncoding:(ca's NSUTF8StringEncoding)) ¬\r\t\t\toptions:0 |error|:(reference)\r\t\r\tif x is missing value then\r\t\t|Left|(e's localizedDescription() as text)\r\telse\r\t\tif x's isKindOfClass:(ca's NSDictionary) then\r\t\t\t|Right|(x as record)\r\t\telse\r\t\t\t|Right|(x as list)\r\t\tend if\r\tend if\rend readJSONLR",
  "readMay": "-- readMay :: Read a => String -> Maybe a\ron readMay(s)\r\ttry\r\t  Just(run script s)\r\ton error e\r\t\tNothing()\r\tend try\rend readMay",
  "recip": "-- recip :: Num -> Num\ron recip(n)\r\tif n ≠ 0 then\r\t\t1 / n\r\telse\r\t\tmissing value\r\tend if\rend recip",
  "recipMay": "-- recipMay :: Num -> Maybe Num\ron recipMay(n)\r\tif n ≠ 0 then\r\t\tJust(1 / n)\r\telse\r\t\tNothing()\r\tend if\rend recipMay",
  "regexMatches": "-- regexMatches :: String -> String -> [[String]]\ron regexMatches(strRegex, strHay)\r\tset ca to current application\r\t-- NSNotFound handling and and High Sierra workaround due to @sl1974\r\tset NSNotFound to a reference to 9.22337203685477E+18 + 5807\r\tset oRgx to ca's NSRegularExpression's regularExpressionWithPattern:strRegex ¬\r\t\toptions:((ca's NSRegularExpressionAnchorsMatchLines as integer)) ¬\r\t\t|error|:(missing value)\r\tset oString to ca's NSString's stringWithString:strHay\r\t\r\tscript matchString\r\t\ton |λ|(m)\r\t\t\tscript rangeMatched\r\t\t\t\ton |λ|(i)\r\t\t\t\t\ttell (m's rangeAtIndex:i)\r\t\t\t\t\t\tset intFrom to its location\r\t\t\t\t\t\tif NSNotFound ≠ intFrom then\r\t\t\t\t\t\t\ttext (intFrom + 1) thru (intFrom + (its |length|)) of strHay\r\t\t\t\t\t\telse\r\t\t\t\t\t\t\tmissing value\r\t\t\t\t\t\tend if\r\t\t\t\t\tend tell\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tmap(rangeMatched, ¬\r\t\t\t\tenumFromToInt(0, ((numberOfRanges of m) as integer) - 1))\r\t\tend |λ|\r\tend script\r\t\r\tmap(matchString, (oRgx's matchesInString:oString ¬\r\t\toptions:0 range:{location:0, |length|:oString's |length|()}) as list)\rend regexMatches",
  "rem": "-- rem :: Int -> Int -> Int\ron rem(m, n)\r\tm mod n\rend rem",
  "removeFile": "-- removeFile :: FilePath -> Either String String\ron removeFile(fp)\r\tset e to reference\r\tset {bln, obj} to current application's NSFileManager's ¬\r\t\tdefaultManager's removeItemAtPath:(fp) |error|:(e)\r\tif bln then\r\t\t|Right|(\"Removed: \" & fp)\r\telse\r\t\t|Left|(obj's localizedDescription as string)\r\tend if\rend removeFile",
  "replace": "-- replace :: String -> String -> String -> String\ron replace(strNeedle, strNew, strHayStack)\r\tset {dlm, my text item delimiters} to {my text item delimiters, strNeedle}\r\tset xs to text items of strHayStack\r\tset my text item delimiters to strNew\r\tset strReplaced to xs as text\r\tset my text item delimiters to dlm\r\treturn strReplaced\rend replace",
  "replicate": "-- Egyptian multiplication - progressively doubling a list, appending\n-- stages of doubling to an accumulator where needed for binary \n-- assembly of a target length\n-- replicate :: Int -> a -> [a]\ron replicate(n, a)\r\tset out to {}\r\tif n < 1 then return out\r\tset dbl to {a}\r\t\r\trepeat while (n > 1)\r\t\tif (n mod 2) > 0 then set out to out & dbl\r\t\tset n to (n div 2)\r\t\tset dbl to (dbl & dbl)\r\tend repeat\r\treturn out & dbl\rend replicate",
  "replicateM": "-- Instance for lists only here\n\n-- e.g. replicateM(3, {1, 2})) -> \n-- {{1, 1, 1}, {1, 1, 2}, {1, 2, 1}, {1, 2, 2}, {2, 1, 1}, \n--  {2, 1, 2}, {2, 2, 1}, {2, 2, 2}}\n-- replicateM :: Int -> [a] -> [[a]]\ron replicateM(n, xs)\r\tscript go\r\t\tscript cons\r\t\t\ton |λ|(a, bs)\r\t\t\t\t{a} & bs\r\t\t\tend |λ|\r\t\tend script\r\t\ton |λ|(x)\r\t\t\tif x ≤ 0 then\r\t\t\t\t{{}}\r\t\t\telse\r\t\t\t\tliftA2List(cons, xs, |λ|(x - 1))\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\ttell go to |λ|(n)\rend replicateM",
  "replicateString": "-- replicateString :: Int -> String -> String\non replicateString(n, s)\n    set out to \"\"\n    if n < 1 then return out\n    set dbl to s\n \n    repeat while (n > 1)\n        if (n mod 2) > 0 then set out to out & dbl\n        set n to (n div 2)\n        set dbl to (dbl & dbl)\n    end repeat\n    return out & dbl\nend replicateS",
  "reverse": "-- reverse :: [a] -> [a]\ron |reverse|(xs)\r\tif class of xs is text then\r\t\t(reverse of characters of xs) as text\r\telse\r\t\treverse of xs\r\tend if\rend |reverse|",
  "Right": "-- Right :: b -> Either a b\ron |Right|(x)\r\t{type:\"Either\", |Left|:missing value, |Right|:x}\rend |Right|",
  "rights": "-- rights :: [Either a b] -> [b]\ron rights(xs)\r\tscript\r\t\ton |λ|(x)\r\t\t\tif class of x is record then\r\t\t\t\tset ks to keys(x)\r\t\t\t\tks contains \"type\" and ks contains \"Right\"\r\t\t\telse\r\t\t\t\tfalse\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tfilter(result, xs)\rend rights",
  "rotate": "-- rotate :: Int -> [a] -> [a]\ron rotate(n, xs)\r\tset lng to length of xs\r\tif lng > 0 then\r\t\ttakeDropCycle(lng, n, xs)\r\telse\r\t\t{}\r\tend if\rend rotate",
  "round": "-- round :: a -> Int\ron |round|(n)\r\tround n\rend |round|",
  "safeMay": "-- safeMay :: (a -> Bool) -> (a -> b) -> Maybe b\ron safeMay(p, f, x)\r\tif p(x) then\r\t\tJust(f(x))\r\telse\r\t\tNothing()\r\tend if\rend safeMay",
  "scanl": "-- scanl :: (b -> a -> b) -> b -> [a] -> [b]\non scanl(f, startValue, xs)\n\ttell mReturn(f)\n\t\tset v to startValue\n\t\tset lng to length of xs\n\t\tset lst to {startValue}\n\t\trepeat with i from 1 to lng\n\t\t\tset v to |λ|(v, item i of xs, i, xs)\n\t\t\tset end of lst to v\n\t\tend repeat\n\t\treturn lst\n\tend tell\nend scanl",
  "scanl1": "-- scanl1 :: (a -> a -> a) -> [a] -> [a]\ron scanl1(f, xs)\r\tif length of xs > 0 then\r\t\tscanl(f, item 1 of xs, tail(xs))\r\telse\r\t\t{}\r\tend if\rend scanl",
  "scanr": "-- scanr :: (b -> a -> b) -> b -> [a] -> [b]\non scanr(f, startValue, xs)\n    tell mReturn(f)\n        set v to startValue\n        set lng to length of xs\n        set lst to {startValue}\n        repeat with i from lng to 1 by -1\n            set v to |λ|(v, item i of xs, i, xs)\n            set end of lst to v\n        end repeat\n        return reverse of lst\n    end tell\nend scanr",
  "scanr1": "-- scanr1 :: (a -> a -> a) -> [a] -> [a]\ron scanr1(f, xs)\r\tif length of xs > 0 then\r\t\tscanr(f, item -1 of xs, init(xs))\r\telse\r\t\t{}\r\tend if\rend scanr1",
  "secondArrow": "-- Lift a simple function to one which applies to a tuple, \n-- transforming only the second item of the tuple\n-- secondArrow :: (a -> b) -> ((c, a) -> (c, b))\ron secondArrow(f)\r\tscript\r\t\ton |λ|(xy)\r\t\t\tTuple(|1| of xy, mReturn(f)'s |λ|(|2| of xy))\r\t\tend |λ|\r\tend script\rend |second|",
  "sequenceAList": "-- sequenceAList :: Applicative f => [f a] -> f [a]\ron sequenceAList(us)\r\tif length of us > 0 then\r\t\tscript\r\t\t\ton |λ|(u, v)\r\t\t\t\tscript cons\r\t\t\t\t\ton |λ|(x)\r\t\t\t\t\t\tscript\r\t\t\t\t\t\t\ton |λ|(xs)\r\t\t\t\t\t\t\t\t{x} & xs\r\t\t\t\t\t\t\tend |λ|\r\t\t\t\t\t\tend script\r\t\t\t\t\tend |λ|\r\t\t\t\tend script\r\t\t\t\tap(fmap(cons, u), v)\r\t\t\tend |λ|\r\t\tend script\r\t\tfoldr(result, mReturn(pureT(item 1 of us))'s |λ|({}), us)\r\telse\r\t\tus\r\tend if\rend sequenceAList",
  "setCurrentDirectory": "-- setCurrentDirectory :: String -> IO ()\ron setCurrentDirectory(strPath)\r\tif doesDirectoryExist(strPath) then\r\t\tset ca to current application\r\t\tset oPath to (ca's NSString's stringWithString:strPath)'s ¬\r\t\t\tstringByStandardizingPath\r\t\tca's NSFileManager's defaultManager()'s ¬\r\t\t\tchangeCurrentDirectoryPath:oPath\r\tend if\rend setCurrentDirectory",
  "show": "-- show :: a -> String\ron show(e)\r\tset c to class of e\r\tif c = list then\r\t\tshowList(e)\r\telse if c = record then\r\t\tset mb to lookupDict(\"type\", e)\r\t\tif Nothing of mb then\r\t\t\tshowDict(e)\r\t\telse\r\t\t\tscript\r\t\t\t\ton |λ|(t)\r\t\t\t\t\tif \"Either\" = t then\r\t\t\t\t\t\tset f to my showLR\r\t\t\t\t\telse if \"Maybe\" = t then\r\t\t\t\t\t\tset f to my showMaybe\r\t\t\t\t\telse if \"Ordering\" = t then\r\t\t\t\t\t\tset f to my showOrdering\r\t\t\t\t\telse if \"Ratio\" = t then\r\t\t\t\t\t\tset f to my showRatio\r\t\t\t\t\telse if \"Tuple\" = t then\r\t\t\t\t\t\tset f to my showTuple\r\t\t\t\t\telse if \"Tuple3\" = t then\r\t\t\t\t\t\tset f to my showTuple3\r\t\t\t\t\telse if \"Tuple4\" = t then\r\t\t\t\t\t\tset f to my showTuple4\r\t\t\t\t\telse\r\t\t\t\t\t\tset f to my showDict\r\t\t\t\t\tend if\r\t\t\t\t\ttell mReturn(f) to |λ|(e)\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\ttell result to |λ|(Just of mb)\r\t\tend if\r\telse if c = date then\r\t\t\"\\\"\" & showDate(e) & \"\\\"\"\r\telse if c = text then\r\t\t\"'\" & e & \"'\"\r\telse if (c = integer or c = real) then\r\t\te as text\r\telse if c = class then\r\t\t\"null\"\r\telse\r\t\ttry\r\t\t\te as text\r\t\ton error\r\t\t\t(\"«\" & c as text) & \"»\"\r\t\tend try\r\tend if\rend show",
  "showBinary": "-- showBinary :: Int -> String\non showBinary(n)\n    script binaryChar\n        on |λ|(n)\n            text item (n + 1) of \"01\"\n        end |λ|\n    end script\n    showIntAtBase(2, binaryChar, n, \"\")\nend showBin",
  "showDate": "-- ISO 8601 UTC \n-- showDate :: Date -> String\ron showDate(dte)\r\t((dte - (time to GMT)) as «class isot» as string) & \".000Z\"\rend showDate",
  "showDict": "-- showDict :: Dict -> String\ron showDict(dct)\r  showJSON(dct)\rend showDict",
  "showHex": "-- showHex :: Int -> String\ron showHex(n)\r\tshowIntAtBase(16, mReturn(intToDigit), n, \"\")\rend showHex",
  "showIntAtBase": "-- showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\ron showIntAtBase(base, toChr, n, rs)\r\tscript showIt\r\t\ton |λ|(nd_, r)\r\t\t\tset {n, d} to nd_\r\t\t\tset r_ to toChr's |λ|(d) & r\r\t\t\tif n > 0 then\r\t\t\t\t|λ|(quotRem(n, base), r_)\r\t\t\telse\r\t\t\t\tr_\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t\r\tif base ≤ 1 then\r\t\t\"error: showIntAtBase applied to unsupported base\"\r\telse if n < 0 then\r\t\t\"error: showIntAtBase applied to negative number\"\r\telse\r\t\tshowIt's |λ|(quotRem(n, base), rs)\r\tend if\rend showIntAtBase",
  "showJSON": "-- showJSON :: a -> String\ron showJSON(x)\r\tset c to class of x\r\tif (c is list) or (c is record) then\r\t\tset ca to current application\r\t\tset {json, e} to ca's NSJSONSerialization's dataWithJSONObject:x options:1 |error|:(reference)\r\t\tif json is missing value then\r\t\t\te's localizedDescription() as text\r\t\telse\r\t\t\t(ca's NSString's alloc()'s initWithData:json encoding:(ca's NSUTF8StringEncoding)) as text\r\t\tend if\r\telse if c is date then\r\t\t\"\\\"\" & ((x - (time to GMT)) as «class isot» as string) & \".000Z\" & \"\\\"\"\r\telse if c is text then\r\t\t\"\\\"\" & x & \"\\\"\"\r\telse if (c is integer or c is real) then\r\t\tx as text\r\telse if c is class then\r\t\t\"null\"\r\telse\r\t\ttry\r\t\t\tx as text\r\t\ton error\r\t\t\t(\"«\" & c as text) & \"»\"\r\t\tend try\r\tend if\rend showJSON",
  "showList": "-- showList :: [a] -> String\ron showList(xs)\r  showJSON(xs)\rend showList",
  "showLog": "-- showLog :: a -> IO ()\ron showLog(e)\r\tlog show(e)\rend showLog",
  "showLR": "-- showLR :: Either a b -> String\ron showLR(lr)\r\tif isRight(lr) then\r\t\t\"Right(\" & unQuoted(show(|Right| of lr)) & \")\"\r\telse\r\t\t\"Left(\" & unQuoted(show(|Left| of lr)) & \")\"\r\tend if\rend showLR",
  "showMaybe": "-- showMaybe :: Maybe a -> String\ron showMaybe(mb)\r\tif Nothing of mb then\r\t\t\"Nothing\"\r\telse\r\t\t\"Just \" & unQuoted(show(Just of mb))\r\tend if\rend showMaybe",
  "showOrdering": "-- showOrdering :: Ordering -> String\ron showOrdering(e)\r\tset v to value of e\r\tif v > 0 then\r\t\t\"GT\"\r\telse if v < 0 then\r\t\t\"LT\"\r\telse\r\t\t\"EQ\"\r\tend if\rend showOrdering",
  "showRatio": "-- showRatio :: Ratio -> String\ron showRatio(r)\r\t(n of r as string) & \"/\" & (d of r as string)\rend showRatio",
  "showTuple": "-- showTuple :: Tuple -> String\ron showTuple(tpl)\r\t\"(\" & unQuoted(show(|1| of tpl)) & \", \" & unQuoted(show(|2| of tpl)) & \")\"\rend showTuple",
  "showTuple3": "-- showTuple3 :: Tuple3 -> String\ron showTuple3(tpl)\r\t\"(\" & unQuoted(show(|1| of tpl)) & \", \" & ¬\r\t\tunQuoted(show(|2| of tpl)) & \", \" & ¬\r\t\tunQuoted(show(|3| of tpl)) & \")\"\rend showTuple3",
  "showTuple4": "-- showTuple4 :: Tuple4 -> String\ron showTuple4(tpl)\r\t\"(\" & unQuoted(show(|1| of tpl)) & \", \" & ¬\r\t\tunQuoted(show(|2| of tpl)) & \", \" & ¬\r\t\tunQuoted(show(|3| of tpl)) & \", \" & ¬\r\t\tunQuoted(show(|4| of tpl)) & \")\"\rend showTuple4",
  "showUndefined": "-- showUndefined :: () -> String\ron showUndefined()\r\t\"⊥\"\rend showUndefined",
  "signum": "-- signum :: Num -> Num\ron signum(x)\r\tif x < 0 then\r\t\t-1\r\telse if x = 0 then\r\t\t0\r\telse\r\t\t1\r\tend if\rend signum",
  "snd": "-- snd :: (a, b) -> b\ron snd(tpl)\r\tif class of tpl is record then\r\t\t|2| of tpl\r\telse\r\t\titem 2 of tpl\r\tend if\rend snd",
  "snoc": "-- Mirror image of cons\n-- New copy of the list, with an atom added at the end\n-- snoc :: [a] -> a -> [a]\ron snoc(xs, x)\r\txs & {x}\rend snoc",
  "sort": "-- sort :: Ord a => [a] -> [a]\non sort(xs)\n\t((current application's NSArray's arrayWithArray:xs)'s ¬\n\t\tsortedArrayUsingSelector:\"compare:\") as list\nend sort",
  "sortBy": "-- Enough for small scale sorts.\n-- Use instead sortOn :: Ord b => (a -> b) -> [a] -> [a]\n-- which is equivalent to the more flexible sortBy(comparing(f), xs)\n-- and uses a much faster ObjC NSArray sort method\n-- sortBy :: (a -> a -> Ordering) -> [a] -> [a]\ron sortBy(f, xs)\r\tif length of xs > 1 then\r\t\tset h to item 1 of xs\r\t\tset f to mReturn(f)\r\t\tscript\r\t\t\ton |λ|(x)\r\t\t\t\tf's |λ|(x, h) ≤ 0\r\t\t\tend |λ|\r\t\tend script\r\t\tset lessMore to partition(result, rest of xs)\r\t\tsortBy(f, |1| of lessMore) & {h} & ¬\r\t\t\tsortBy(f, |2| of lessMore)\r\telse\r\t\txs\r\tend if\rend sortBy",
  "sortOn": "-- Sort a list by comparing the results of a key function applied to each\r-- element. sortOn f is equivalent to sortBy(comparing(f), xs), but has the\r-- performance advantage of only evaluating f once for each element in\r-- the input list. This is called the decorate-sort-undecorate paradigm,\r-- or Schwartzian transform.\r-- Elements are arranged from from lowest to highest.\r\r-- In this Applescript implementation, f can optionally be [(a -> b)]\r-- or [((a -> b), Bool)]) to specify a compound sort order\r\r--    xs:  List of items to be sorted. \r--          (The items can be records, lists, or simple values).\r--\r--    f:    A single (a -> b) function (Applescript handler),\r--          or a list of such functions.\r--          if the argument is a list, any function can \r--          optionally be followed by a bool. \r--          (False -> descending sort)\r--\r--          (Subgrouping in the list is optional and ignored)\r--          Each function (Item -> Value) in the list should \r--          take an item (of the type contained by xs) \r--          as its input and return a simple orderable value \r--          (Number, String, or Date).\r--\r--          The sequence of key functions and optional \r--          direction bools defines primary to N-ary sort keys.\n-- sortOn :: Ord b => (a -> b) -> [a] -> [a]\r-- sortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\ron sortOn(f, xs)\r    script keyBool\r        on |λ|(x, a)\r            if class of x is boolean then\r                {asc:x, fbs:fbs of a}\r            else\r                {asc:true, fbs:({Tuple(x, asc of a)} & fbs of a)}\r            end if\r        end |λ|\r    end script\r    set {fs, bs} to {|1|, |2|} of unzip(fbs of foldr(keyBool, ¬\r        {asc:true, fbs:{}}, flatten({f})))\r    \r    set intKeys to length of fs\r    set ca to current application\r    script dec\r        property gs : map(my mReturn, fs)\r        on |λ|(x)\r            set nsDct to (ca's NSMutableDictionary's ¬\r                dictionaryWithDictionary:{val:x})\r            repeat with i from 1 to intKeys\r                (nsDct's setValue:((item i of gs)'s |λ|(x)) ¬\r                    forKey:(character id (96 + i)))\r            end repeat\r            nsDct as record\r        end |λ|\r    end script\r    \r    script descrip\r        on |λ|(bool, i)\r            ca's NSSortDescriptor's ¬\r                sortDescriptorWithKey:(character id (96 + i)) ¬\r                    ascending:bool\r        end |λ|\r    end script\r    \r    script undec\r        on |λ|(x)\r            val of x\r        end |λ|\r    end script\r    \r    map(undec, ((ca's NSArray's arrayWithArray:map(dec, xs))'s ¬\r        sortedArrayUsingDescriptors:map(descrip, bs)) as list)\rend sortOn",
  "span": "-- span, applied to a predicate p and a list xs, returns a tuple of xs of elements that satisfy p and second element is the remainder of the list:\n-- \n-- > span (< 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])\n-- > span (< 9) [1,2,3] == ([1,2,3],[])\n-- > span (< 0) [1,2,3] == ([],[1,2,3])\n-- \n-- span p xs is equivalent to (takeWhile p xs, dropWhile p xs) \n-- span :: (a -> Bool) -> [a] -> ([a],[a])\non span(f, xs)\n\tset lng to length of xs\n\tset i to 0\n\ttell mReturn(f)\n\t\trepeat while i < lng and |λ|(item (i + 1) of xs)\n\t\t\tset i to i + 1\n\t\tend repeat\n\tend tell\n\tsplitAt(i, xs)\nend span",
  "splitArrow": "-- Compose a function (from a tuple to a tuple), \n-- (with separate transformations for fst and snd)\n-- splitArrow (***) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))\ron splitArrow(f, g)\r\tscript\r\t\ton |λ|(xy)\r\t\t\tTuple(mReturn(f)'s |λ|(|1| of xy), mReturn(g)'s |λ|(|2| of xy))\r\t\tend |λ|\r\tend script\rend splitArrow",
  "splitAt": "-- splitAt :: Int -> [a] -> ([a],[a])\ron splitAt(n, xs)\r\tif n > 0 and n < length of xs then\r\t\tif class of xs is text then\r\t\t\tTuple(items 1 thru n of xs as text, items (n + 1) thru -1 of xs as text)\r\t\telse\r\t\t\tTuple(items 1 thru n of xs, items (n + 1) thru -1 of xs)\r\t\tend if\r\telse\r\t\tif n < 1 then\r\t\t\tTuple({}, xs)\r\t\telse\r\t\t\tTuple(xs, {})\r\t\tend if\r\tend if\rend splitAt",
  "splitBy": "-- splitBy :: (a -> a -> Bool) -> [a] -> [[a]]\r-- splitBy :: (String -> String -> Bool) -> String -> [String]\ron splitBy(p, xs)\r\tif length of xs < 2 then\r\t\t{xs}\r\telse\r\t\tscript f\r\t\t\tproperty mp : |λ| of mReturn(p)\r\t\t\ton |λ|(a, x)\r\t\t\t\tset {acc, active, prev} to a\r\t\t\t\tif mp(prev, x) then\r\t\t\t\t\t{acc & {active}, {x}, x}\r\t\t\t\telse\r\t\t\t\t\t{acc, active & x, x}\r\t\t\t\tend if\r\t\t\tend |λ|\r\t\tend script\r\t\t\r\t\tset h to item 1 of xs\r\t\tset lstParts to foldl(f, {{}, {h}, h}, items 2 thru -1 of xs)\r\t\tif class of item 1 of xs = string then\r\t\t\tmap(concat, (item 1 of lstParts & {item 2 of lstParts}))\r\t\telse\r\t\t\titem 1 of lstParts & {item 2 of lstParts}\r\t\tend if\r\tend if\rend splitBy",
  "splitEvery": "-- splitEvery :: Int -> [a] -> [[a]]\ron splitEvery(n, xs)\r\tif length of xs ≤ n then\r\t\t{xs}\r\telse\r\t\tset grp_t to splitAt(n, xs)\r\t\t{|1| of grp_t} & splitEvery(n, |2| of grp_t)\r\tend if\rend splitEvery",
  "splitFileName": "-- Split a filename into directory and file. combine is the inverse.\n-- splitFileName :: FilePath -> (String, String)\ron splitFileName(strPath)\r\tif strPath ≠ \"\" then\r\t\tif last character of strPath ≠ \"/\" then\r\t\t\tset xs to splitOn(\"/\", strPath)\r\t\t\tset stem to init(xs)\r\t\t\tif stem ≠ {} then\r\t\t\t\tTuple(intercalate(\"/\", stem) & \"/\", |last|(xs))\r\t\t\telse\r\t\t\t\tTuple(\"./\", |last|(xs))\r\t\t\tend if\r\t\telse\r\t\t\tTuple(strPath, \"\")\r\t\tend if\r\telse\r\t\tTuple(\"./\", \"\")\r\tend if\rend splitFileName",
  "splitOn": "-- splitOn :: String -> String -> [String]\non splitOn(strDelim, strMain)\n    set {dlm, my text item delimiters} to {my text item delimiters, strDelim}\n    set xs to text items of strMain\n    set my text item delimiters to dlm\n    return xs\nend splitOn",
  "splitRegex": "-- splitRegex :: Regex -> String -> [String]\non splitRegex(strRegex, str)\n\tset lstMatches to regexMatches(strRegex, str)\n\tif length of lstMatches > 0 then\n\t\tscript preceding\n\t\t\ton |λ|(a, x)\n\t\t\t\tset iFrom to start of a\n\t\t\t\tset iLocn to (location of x)\n\t\t\t\t\n\t\t\t\tif iLocn > iFrom then\n\t\t\t\t\tset strPart to text (iFrom + 1) thru iLocn of str\n\t\t\t\telse\n\t\t\t\t\tset strPart to \"\"\n\t\t\t\tend if\n\t\t\t\t{parts:parts of a & strPart, start:iLocn + (length of x) - 1}\n\t\t\tend |λ|\n\t\tend script\n\t\t\n\t\tset recLast to foldl(preceding, {parts:[], start:0}, lstMatches)\n\t\t\n\t\tset iFinal to start of recLast\n\t\tif iFinal < length of str then\n\t\t\tparts of recLast & text (iFinal + 1) thru -1 of str\n\t\telse\n\t\t\tparts of recLast & \"\"\n\t\tend if\n\telse\n\t\t{str}\n\tend if\nend splitRegex",
  "sqrt": "-- sqrt :: Num -> Num\ron sqrt(n)\r\tif n ≥ 0 then\r\t\tn ^ (1 / 2)\r\telse\r\t\tmissing value\r\tend if\rend sqrt",
  "sqrtMay": "-- sqrtMay :: Num -> Maybe Num\ron sqrtMay(n)\r\tif n ≥ 0 then\r\t\tJust(n ^ (1 / 2))\r\telse\r\t\tNothing()\r\tend if\rend sqrtMay",
  "strip": "-- strip :: String -> String\ron strip(s)\r\tscript isSpace\r\t\ton |λ|(c)\r\t\t\tset i to id of c\r\t\t\ti = 32 or (i ≥ 9 and i ≤ 13)\r\t\tend |λ|\r\tend script\r\tdropWhile(isSpace, dropWhileEnd(isSpace, s))\rend strip",
  "stripEnd": "-- stripEnd :: String -> String\ron stripEnd(s)\r\tdropWhileEnd(my isSpace, s)\rend stripEnd",
  "stripPrefix": "-- stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]\r-- stripPrefix :: String -> String -> Maybe String\ron stripPrefix(pfx, s)\r\tset blnString to class of pfx is text\r\tif blnString then\r\t\tset {xs, ys} to {characters of pfx, characters of s}\r\telse\r\t\tset {xs, ys} to {pfx, s}\r\tend if\r\t\r\tscript\r\t\ton |λ|(xs, ys)\r\t\t\tif length of xs < 1 then\r\t\t\t\tif blnString then\r\t\t\t\t\tset v to intercalate(\"\", ys)\r\t\t\t\telse\r\t\t\t\t\tset v to ys\r\t\t\t\tend if\r\t\t\t\tJust(v)\r\t\t\telse\r\t\t\t\tif (length of ys < 1) or (item 1 of xs ≠ item 1 of ys) then\r\t\t\t\t\tNothing()\r\t\t\t\telse\r\t\t\t\t\t|λ|(tail(xs), tail(ys))\r\t\t\t\tend if\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t|λ|(xs, ys) of result\rend stripPrefix",
  "stripStart": "-- stripStart :: String -> String\ron stripStart(s)\r\tdropWhile(my isSpace, s)\rend stripStart",
  "subsequences": "-- subsequences([1,2,3]) -> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n-- subsequences(\"abc\") -> [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n-- subsequences :: [a] -> [[a]]\r-- subsequences :: String -> [String]\ron subsequences(xs)\r\tscript nonEmptySubsequences\r\t\ton |λ|(xxs)\r\t\t\tif length of xxs < 1 then\r\t\t\t\t{}\r\t\t\telse\r\t\t\t\tset {x, xs} to {item 1 of xxs, tail(xxs)}\r\t\t\r\t\t\t\tscript f\r\t\t\t\t\ton |λ|(ys, r)\r\t\t\t\t\t\tcons(ys, cons(cons(x, ys), r))\r\t\t\t\t\tend |λ|\r\t\t\t\tend script\r\t\t\t\t\r\t\t\t\tcons({x}, foldr(f, {}, |λ|(xs) of nonEmptySubsequences))\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tif class of xs is text then\r\t\tcons(\"\", map(my concat, |λ|(characters of xs) of nonEmptySubsequences))\r\telse\r\t\tcons([], |λ|(xs) of nonEmptySubsequences)\r\tend if\rend subsequences",
  "subtract": "-- subtract :: Num -> Num -> Num\ron subtract(x, y)\r\ty - x\rend subtract",
  "succ": "-- succ :: Enum a => a -> a\ron succ(x)\r\tif isChar(x) then\r\t\tchr(ord(x) + 1)\r\telse\r\t\t1 + x\r\tend if\rend succ",
  "sum": "-- sum :: [Num] -> Num\non sum(xs)\n\tscript add\n\t\ton |λ|(a, b)\n\t\t\ta + b\n\t\tend |λ|\n\tend script\n\t\n\tfoldl(add, 0, xs)\nend sum",
  "swap": "-- swap :: (a, b) -> (b, a)\ron swap(ab)\r\tif class of ab is record then\r\t\tTuple(|2| of ab, |1| of ab)\r\telse\r\t\t{item 2 of ab, item 1 of ab}\r\tend if\rend swap",
  "tail": "-- tail :: [a] -> [a]\ron tail(xs)\r\tif xs = {} then\r\t\tmissing value\r\telse\r\t\trest of xs\r\tend if\rend tailDef",
  "tailMay": "-- tailMay :: [a] -> Maybe [a]\ron tailMay(xs)\r\tif xs = {} then\r\t\tNothing()\r\telse\r\t\tJust(rest of xs)\r\tend if\rend tailMay",
  "tails": "-- tails :: [a] -> [[a]]\non tails(xs)\n\tif class of xs is text then\n\t\tset xs_ to characters of xs\n\telse\n\t\tset xs_ to xs\n\tend if\n\t\n\tscript\n\t\ton |λ|(_, i)\n\t\t\titems i thru -1 of xs_\n\t\tend |λ|\n\tend script\n\t\n\tmap(result, xs_) & {{}}\nend tails",
  "take": "-- take :: Int -> [a] -> [a]\ron take(n, xs)\r\tif class of xs is string then\r\t\tif n > 0 then\r\t\t\ttext 1 thru min(n, length of xs) of xs\r\t\telse\r\t\t\t\"\"\r\t\tend if\r\telse\r\t\tif n > 0 then\r\t\t\titems 1 thru min(n, length of xs) of xs\r\t\telse\r\t\t\t{}\r\t\tend if\r\tend if\rend take",
  "takeAround": "-- takeAround :: (a -> Bool) -> [a] -> [a]\ron takeAround(p, xs)\r\tset ys to takeWhile(p, xs)\r\tif length of ys < length of xs then\r\t\tys & takeWhileR(p, xs)\r\telse\r\t\tys\r\tend if\rend takeAround",
  "takeBaseName": "-- takeBaseName :: FilePath -> String\non takeBaseName(strPath)\n    if strPath ≠ \"\" then\n        if text -1 of strPath = \"/\" then\n            \"\"\n        else\n            set fn to item -1 of splitOn(\"/\", strPath)\n            if fn contains \".\" then\n                intercalateString(\".\", items 1 thru -2 of splitOn(\".\", fn))\n            else\n                fn\n            end if\n        end if\n    else\n        \"\"\n    end if\nend takeBaseName",
  "takeCycle": "-- takeCycle :: Int -> [a] -> [a]\ron takeCycle(n, xs)\r\tset lng to length of xs\r\tif lng ≥ n then\r\t\tset cycle to xs\r\telse\r\t\tset cycle to concat(replicate((n div lng) + 1, xs))\r\tend if\r\t\r\tif class of xs is string then\r\t\titems 1 thru n of cycle as string\r\telse\r\t\titems 1 thru n of cycle\r\tend if\rend takeCycle",
  "takeDirectory": "-- takeDirectory :: FilePath -> FilePath\ron takeDirectory(strPath)\r\tif strPath ≠ \"\" then\r\t\tif character -1 of strPath = \"/\" then\r\t\t\ttext 1 thru -2 of strPath\r\t\telse\r\t\t\tset xs to init(splitOn(\"/\", strPath))\r\t\t\tif xs ≠ {} then\r\t\t\t\tintercalate(\"/\", xs)\r\t\t\telse\r\t\t\t\t\".\"\r\t\t\tend if\r\t\tend if\r\telse\r\t\t\".\"\r\tend if\rend takeDirector",
  "takeDropCycle": "-- take N Members of an infinite cycle of xs, starting from index I\n-- takeDropCycle :: Int -> [a] -> [a]\ron takeDropCycle(n, i, xs)\r\tset lng to length of xs\r\tset m to n + i\r\t\r\tif lng ≥ m then\r\t\tset ys to xs\r\telse\r\t\tset ys to concat(replicate(ceiling(m / lng), xs))\r\tend if\r\t\r\tdrop(i, take(m, ys))\rend takeDropCycle",
  "takeExtension": "-- takeExtension :: FilePath -> String\ron takeExtension(strPath)\r\tset xs to splitOn(\".\", strPath)\r\tif length of xs > 1 then\r\t\t\".\" & item -1 of xs\r\telse\r\t\t\"\"\r\tend if\rend takeExtension",
  "takeFileName": "-- takeFileName :: FilePath -> FilePath\non takeFileName(strPath)\n    if strPath ≠ \"\" and character -1 of strPath ≠ \"/\" then\n        item -1 of splitOn(\"/\", strPath)\n    else\n        \"\"\n    end if\nend takeFileName",
  "takeIterate": "-- takeIterate n f x == [x, f x, f (f x), ...]\n-- takeIterate :: Int -> (a -> a) -> a -> [a]\ron takeIterate(n, f, x)\r\tset v to x\r\tset vs to {v}\r\ttell mReturn(f)\r\t\trepeat with i from 1 to n - 1\r\t\t\tset v to |λ|(v)\r\t\t\tset end of vs to v\r\t\tend repeat\r\tend tell\r\treturn vs\rend takeIterate",
  "takeWhile": "-- takeWhile :: (a -> Bool) -> [a] -> [a]\ron takeWhile(p, xs)\r\tset bln to false\r\ttell mReturn(p)\r\t\trepeat with i from 1 to length of xs\r\t\t\tif not |λ|(item i of xs) then\r\t\t\t\tset bln to true\r\t\t\t\texit repeat\r\t\t\tend if\r\t\tend repeat\r\tend tell\r\tif bln then\r\t\tif i > 1 then\r\t\t\titems 1 thru (i - 1) of xs\r\t\telse\r\t\t\t{}\r\t\tend if\r\telse\r\t\txs\r\tend if\rend takeWhile",
  "takeWhileR": "-- takeWhileR :: (a -> Bool) -> [a] -> [a]\ron takeWhileR(p, xs)\r\tset bln to false\r\ttell mReturn(p)\r\t\tset lng to length of xs\r\t\trepeat with i from lng to 1 by -1\r\t\t\tif not |λ|(item i of xs) then\r\t\t\t\tset bln to true\r\t\t\t\texit repeat\r\t\t\tend if\r\t\tend repeat\r\tend tell\r\tif bln then\r\t\tif i > 1 then\r\t\t\titems (1 + i) thru (-1) of xs\r\t\telse\r\t\t\t{}\r\t\tend if\r\telse\r\t\txs\r\tend if\rend takeWhileR",
  "tempFilePath": "-- tempFilePath :: String -> IO FilePath\ron tempFilePath(template)\r\t(current application's ¬\r\t\tNSTemporaryDirectory() as string) & ¬\r\t\ttakeBaseName(template) & ¬\r\t\ttext 3 thru -1 of ((random number) as string) & ¬\r\t\ttakeExtension(template)\rend tempFilePath",
  "then": "-- then (>>) :: Monad m => m a -> m b -> m b\ron |then|(ma, mb)\r\tset c to class of ma\r\tif c is list then\r\t\tthenList(ma, mb)\r\telse if c is record then\r\t\tif keys(ma) contains \"Maybe\" then\r\t\t\tthenMay(ma, mb)\r\t\telse\r\t\t\tthenIO(ma, mb)\r\t\tend if\r\telse\r\t\tthenIO(ma, mb)\r\tend if\rend |then|",
  "thenIO": "-- thenIO (>>) :: IO a -> IO b -> IO b\ron thenIO(ma, mb)\r\tmb\rend thenIO",
  "thenList": "-- thenList (>>) :: [a] -> [b] -> [b]\ron thenList(xs, ys)\r\tscript\r\t\ton |λ|(_)\r\t\t\tys\r\t\tend |λ|\r\tend script\r\tconcatMap(result, xs)\rend thenList",
  "thenMay": "-- thenMay (>>) :: Maybe a -> Maybe b -> Maybe b\ron thenMay(ma, mb)\r\tif Nothing of ma then\r\t\tma\r\telse\r\t\tmb\r\tend if\rend thenMay ",
  "toListTree": "-- toListTree :: Tree a -> [a]\ron toListTree(tree)\r\tscript go\r\t\ton |λ|(x)\r\t\t\t{root of x} & concatMap(go, nest of x)\r\t\tend |λ|\r\tend script\r\t|λ|(tree) of go\rend toListTree",
  "toLower": "-- toLower :: String -> String\non toLower(str)\n\tset ca to current application\n\t((ca's NSString's stringWithString:(str))'s ¬\n\t\tlowercaseStringWithLocale:(ca's NSLocale's currentLocale())) as text\nend toLower",
  "toRatio": "-- toRatio :: Real -> Ratio\ron toRatio(n)\r\tapproxRatio(1.0E-12, n)\rend toRatio",
  "toSentence": "-- Sentence case - initial string capitalized and rest lowercase\n-- toSentence :: String -> String\ron toSentence(str)\r\tset ca to current application\r\tif length of str > 0 then\r\t\tset locale to ca's NSLocale's currentLocale()\r\t\tset ws to ca's NSString\r\t\t(((ws's stringWithString:(text 1 of str))'s ¬\r\t\t\tuppercaseStringWithLocale:(locale)) as text) & ¬\r\t\t\t((ws's stringWithString:(text 2 thru -1 of str))'s ¬\r\t\t\t\tlowercaseStringWithLocale:(locale)) as text\r\telse\r\t\tstr\r\tend if\rend toSentence",
  "toTitle": "-- NB this does not model any regional or cultural conventions.\n-- It simply simply capitalizes the first character of each word.\n-- toTitle :: String -> String\ron toTitle(str)\r\tset ca to current application\r\t((ca's NSString's stringWithString:(str))'s ¬\r\t\tcapitalizedStringWithLocale:(ca's NSLocale's currentLocale())) as text\rend toTitle",
  "toUpper": "-- toUpper :: String -> String\non toUpper(str)\n\tset ca to current application\n\t((ca's NSString's stringWithString:(str))'s ¬\n\t\tuppercaseStringWithLocale:(ca's NSLocale's currentLocale())) as text\nend toUpper",
  "transpose": "-- If some of the rows are shorter than the following rows, \n-- their elements are skipped:\n-- transpose({{10,11},{20},{},{30,31,32}}) -> {{10, 20, 30}, {11, 31}, {32}}\n-- transpose :: [[a]] -> [[a]]\ron transpose(xxs)\r\tset intMax to |length|(maximumBy(comparing(my |length|), xxs))\r\tset gaps to replicate(intMax, {})\r\tscript padded\r\t\ton |λ|(xs)\r\t\t\tset lng to |length|(xs)\r\t\t\tif lng < intMax then\r\t\t\t\tappend(xs, items (lng + 1) thru -1 of gaps)\r\t\t\telse\r\t\t\t\txs\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\tset rows to map(padded, xxs)\r\t\r\tscript cols\r\t\ton |λ|(_, iCol)\r\t\t\tscript cell\r\t\t\t\ton |λ|(row)\r\t\t\t\t\titem iCol of row\r\t\t\t\tend |λ|\r\t\t\tend script\r\t\t\tconcatMap(cell, rows)\r\t\tend |λ|\r\tend script\r\tmap(cols, item 1 of rows)\rend transpose",
  "traverseList": "--    1. Map each element of a structure to an action,\n--    2. evaluate these actions from |Left| to |Right|, and\n--    3. collect the results.\n-- \n--     traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)\n--     traverse_ f = foldr cons_f (pure [])\n--        where cons_f x a = ((:) <$> (f x)) <*> a\n-- traverseList :: (Applicative f) => (a -> f b) -> [a] -> f (t b)\non traverseList(f, xs)\n  sequenceAList(fmap(f, xs))\nend traverseList",
  "treeLeaves": "-- treeLeaves :: Tree -> [Tree]\ron treeLeaves(oNode)\r\tscript go\r\t\ton |λ|(x)\r\t\t\tset lst to nest of x\r\t\t\tif length of lst > 0 then\r\t\t\t\tconcatMap(my treeLeaves, lst)\r\t\t\telse\r\t\t\t\t{x}\r\t\t\tend if\r\t\tend |λ|\r\tend script\r\t|λ|(oNode) of go\rend treeLeaves",
  "truncate": "-- truncate :: Num -> Int\ron truncate(x)\r\titem 1 of properFraction(x)\rend truncate",
  "Tuple": "-- Tuple (,) :: a -> b -> (a, b)\ron Tuple(a, b)\r\t{type:\"Tuple\", |1|:a, |2|:b}\rend Tuple",
  "tupleFromArray": "-- tupleFromArray [a] -> (a, a ...)\ron tupleFromArray(xs)\r\tset lng to length of xs\r\tif lng > 1 then\r\t\tif lng > 2 then\r\t\t\tset strSuffix to lng as string\r\t\telse\r\t\t\tset strSuffix to \"\"\r\t\tend if\r\t\tscript kv\r\t\t\ton |λ|(a, x, i)\r\t\t\t\tinsertMap(a, (i as string), x)\r\t\t\tend |λ|\r\t\tend script\r\t\tfoldl(kv, {type:\"Tuple\" & strSuffix}, xs)\r\telse\r\t\tmissing value\r\tend if\rend tupleFromArray",
  "TupleN": "-- TupleN :: a -> b ...  -> (a, b ... )\ron TupleN(xs)\r\ttupleFromArray(xs)\rend Tuple",
  "typeName": "-- typeName :: a -> String\ron typeName(x)\r\tset mb to lookup((class of x) as string, ¬\r\t\t{|list|:\"List\", |integer|:\"Int\", |real|:\"Float\", |text|:¬\r\t\t\t\"String\", |string|:\"String\", |record|:¬\r\t\t\t\"Record\", |boolean|:\"Bool\", |handler|:\"Function\", |script|:\"Function\"})\r\tif Nothing of mb then\r\t\t\"Bottom\"\r\telse\r\t\tset k to Just of mb\r\t\tif k = \"Record\" then\r\t\t\tif keys(x) contains \"type\" then\r\t\t\t\ttype of x\r\t\t\telse\r\t\t\t\t\"Dict\"\r\t\t\tend if\r\t\telse\r\t\t\tk\r\t\tend if\r\tend if\rend typeName",
  "uncons": "-- uncons :: [a] -> Maybe (a, [a])\ron uncons(xs)\r\tif xs = {} then\r\t\tNothing()\r\telse\r\t\tif class of xs is string then\r\t\t\tset cs to text items of xs\r\t\t\tJust(Tuple(item 1 of cs, rest of cs))\r\t\telse\r\t\t\tJust(Tuple(item 1 of xs, rest of xs))\r\t\tend if\r\tend if\rend uncons",
  "uncurry": "-- Returns a function on a single tuple (containing 2 arguments)\n-- derived from an equivalent function with 2 distinct arguments\n-- uncurry :: (a -> b -> c) -> ((a, b) -> c)\ron uncurry(f)\r\tscript\r\t\tproperty mf : mReturn(f)'s |λ|\r\t\ton |λ|(pair)\r\t\t\tmf(|1| of pair, |2| of pair)\r\t\tend |λ|\r\tend script\rend uncurry",
  "unfoldForest": "-- | Build a forest from a list of seed values\n-- unfoldForest :: (b -> (a, [b])) -> [b] -> Forest\ron unfoldForest(f, xs)\r\tset g to mReturn(f)\r\tscript\r\t\ton |λ|(x)\r\t\t\tunfoldTree(g, x)\r\t\tend |λ|\r\tend script\r\tmap(result, xs)\rend unfoldForest",
  "unfoldl": "-- > unfoldl (\\b -> if b == 0 then Nothing else Just (b, b-1)) 10\n-- > [1,2,3,4,5,6,7,8,9,10]\n-- unfoldl :: (b -> Maybe (a, b)) -> b -> [a]\ron unfoldl(f, v)\r\tset xr to Tuple(v, v) -- (value, remainder)\r\tset xs to {}\r\ttell mReturn(f)\r\t\trepeat -- Function applied to remainder.\r\t\t\tset mb to |λ|(|2| of xr)\r\t\t\tif Nothing of mb then\r\t\t\t\texit repeat\r\t\t\telse -- New (value, remainder) tuple,\r\t\t\t\tset xr to Just of mb\r\t\t\t\t-- and value appended to output list.\r\t\t\t\tset xs to ({|1| of xr} & xs)\r\t\t\tend if\r\t\tend repeat\r\tend tell\r\treturn xs\rend unfoldl",
  "unfoldr": "-- > unfoldr (\\b -> if b == 0 then Nothing else Just (b, b-1)) 10\n-- > [10,9,8,7,6,5,4,3,2,1] \n-- unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\ron unfoldr(f, v)\r\tset xr to Tuple(v, v) -- (value, remainder)\r\tset xs to {}\r\ttell mReturn(f)\r\t\trepeat -- Function applied to remainder.\r\t\t\tset mb to |λ|(|2| of xr)\r\t\t\tif Nothing of mb then\r\t\t\t\texit repeat\r\t\t\telse -- New (value, remainder) tuple,\r\t\t\t\tset xr to Just of mb\r\t\t\t\t-- and value appended to output list.\r\t\t\t\tset end of xs to |1| of xr\r\t\t\tend if\r\t\tend repeat\r\tend tell\r\treturn xs\rend unfoldr",
  "unfoldTree": "-- | Build a tree from a seed value\n-- unfoldTree :: (b -> (a, [b])) -> b -> Tree a\ron unfoldTree(f, b)\r\tset g to mReturn(f)\r\tset tpl to g's |λ|(b)\r\tNode(|1| of tpl, unfoldForest(g, |2| of tpl))\rend unfoldTree",
  "union": "-- union :: [a] -> [a] -> [a]\ron union(xs, ys)\r\tscript flipDelete\r\t\ton |λ|(xs, x)\r\t\t\tmy |delete|(x, xs)\r\t\tend |λ|\r\tend script\r\t\r\tset sx to nub(xs)\r\tsx & foldl(flipDelete, nub(ys), sx)\rend union",
  "unionBy": "-- unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\ron unionBy(fnEq, xs, ys)\r\tscript flipDeleteByEq\r\t\ton |λ|(xs, x)\r\t\t\tdeleteBy(fnEq, x, xs)\r\t\tend |λ|\r\tend script\r\txs & foldl(flipDeleteByEq, nubBy(fnEq, ys), xs)\rend unionBy",
  "unlines": "-- unlines :: [String] -> String\ron unlines(xs)\r\tset {dlm, my text item delimiters} to ¬\r\t\t{my text item delimiters, linefeed}\r\tset str to xs as text\r\tset my text item delimiters to dlm\r\tstr\rend unlines",
  "unQuoted": "-- unQuoted :: String -> String\ron unQuoted(s)\r\tscript p\r\t\ton |λ|(x)\r\t\t\t--{34, 39} contains id of x\r\t\t\t34 = id of x\r\t\tend |λ|\r\tend script\r\tdropAround(p, s)\rend unQuoted",
  "unsnoc": "-- If the list is empty returns Nothing, otherwise returns \n-- Just the init and the last.\n-- unsnoc :: [a] -> Maybe ([a], a)\ron unsnoc(xs)\r\tset blnString to class of xs is string\r\tset lng to length of xs\r\tif lng = 0 then\r\t\tNothing()\r\telse\r\t\tset h to item -1 of xs\r\t\tif lng > 1 then\r\t\t\tif blnString then\r\t\t\t\tJust(Tuple(text 1 thru -2 of xs, h))\r\t\t\telse\r\t\t\t\tJust(Tuple(items 1 thru -2 of xs, h))\r\t\t\tend if\r\t\telse\r\t\t\tif blnString then\r\t\t\t\tJust(Tuple(\"\", h))\r\t\t\telse\r\t\t\t\tJust(Tuple({}, h))\r\t\t\tend if\r\t\tend if\r\tend if\rend unsnoc",
  "until": "-- until :: (a -> Bool) -> (a -> a) -> a -> a\ron |until|(p, f, x)\r\tset v to x\r\tset mp to mReturn(p)\r\tset mf to mReturn(f)\r\trepeat until mp's |λ|(v)\r\t\tset v to mf's |λ|(v)\r\tend repeat\rend |until|",
  "unwords": "-- unwords :: [String] -> String\ron unwords(xs)\r\tintercalate(space, xs)\rend unwords",
  "unwrap": "-- unwrap :: NSObject -> a\non unwrap(objCValue)\n\tif objCValue is missing value then\n\t\tmissing value\n\telse\n\t\tset ca to current application\n\t\titem 1 of ((ca's NSArray's arrayWithObject:objCValue) as list)\n\tend if\nend unwrap",
  "unzip": "-- unzip :: [(a,b)] -> ([a],[b])\ron unzip(xys)\r\tset xs to {}\r\tset ys to {}\r\trepeat with xy in xys\r\t\tset end of xs to |1| of xy\r\t\tset end of ys to |2| of xy\r\tend repeat\r\treturn Tuple(xs, ys)\rend unzip",
  "unzip3": "-- unzip3 :: [(a,b,c)] -> ([a],[b],[c])\ron unzip3(xyzs)\r\tset xs to {}\r\tset ys to {}\r\tset zs to {}\r\trepeat with xyz in xyzs\r\t\tset end of xs to |1| of xyz\r\t\tset end of ys to |2| of xyz\r\t\tset end of zs to |3| of xyz\r\tend repeat\r\treturn Tuple3(xs, ys, zs)\rend unzip3",
  "unzip4": "-- unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])\ron unzip4(wxyzs)\r\tset ws to {}\r\tset xs to {}\r\tset ys to {}\r\tset zs to {}\r\trepeat with wxyz in wxyzs\r\t\tset end of ws to |1| of wxyz\r\t\tset end of xs to |2| of wxyz\r\t\tset end of ys to |3| of wxyz\r\t\tset end of zs to |4| of wxyz\r\tend repeat\r\treturn Tuple4(ws, xs, ys, zs)\rend unzip4",
  "variance": "-- variance :: [Num] -> Num\ron variance(xs)\r\tset m to mean(xs)\r\tscript\r\t\ton |λ|(a, x)\r\t\t\ta + (x - m) ^ 2\r\t\tend |λ|\r\tend script\r\tfoldl(result, 0, xs) / ((length of xs) - 1)\rend variance",
  "words": "-- words :: String -> [String]\ron |words|(s)\r\twords of s\rend |words|",
  "wrap": "-- wrap :: a -> NSObject\non wrap(v)\n\tset ca to current application\n\tca's (NSArray's arrayWithObject:v)'s objectAtIndex:0\nend wrap",
  "writeFile": "-- use framework \"Foundation\"\n-- writeFile :: FilePath -> String -> IO ()\ron writeFile(strPath, strText)\r\tset ca to current application\r\t(ca's NSString's stringWithString:strText)'s ¬\r\t\twriteToFile:(stringByStandardizingPath of ¬\r\t\t\t(ca's NSString's stringWithString:strPath)) atomically:true ¬\r\t\t\tencoding:(ca's NSUTF8StringEncoding) |error|:(missing value)\rend writeFile",
  "writeFileLR": "-- writeFileLR :: FilePath -> Either String IO FilePath\ron writeFileLR(strPath, strText)\r\tset ca to current application\r\tset fp to stringByStandardizingPath of ¬\r\t\t(ca's NSString's stringWithString:strPath)\r\tset {bln, e} to (ca's NSString's stringWithString:strText)'s ¬\r\t\twriteToFile:(fp) atomically:true ¬\r\t\t\tencoding:(ca's NSUTF8StringEncoding) |error|:(reference)\r\tif bln and e is missing value then\r\t\t|Right|(fp as string)\r\telse\r\t\t|Left|(e's localizedDescription() as string)\r\tend if\rend writeFileLR",
  "writeTempFile": "use framework \"Foundation\"\r-- File name template -> string data -> temporary path\r-- (Random digit sequence inserted between template base and extension)\n-- writeTempFile :: String -> String -> IO FilePath\ron writeTempFile(template, txt)\r\tset strPath to (current application's ¬\r\t\tNSTemporaryDirectory() as string) & ¬\r\t\ttakeBaseName(template) & ¬\r\t\ttext 3 thru -1 of ((random number) as string) & ¬\r\t\ttakeExtension(template)\r\t-- Effect\r\twriteFile(strPath, txt)\r\t-- Value\r\tstrPath\rend writeTempFile",
  "zip": "-- zip :: [a] -> [b] -> [(a, b)]\ron zip(xs, ys)\r\tset lng to min(length of xs, length of ys)\r\tset lst to {}\r\trepeat with i from 1 to lng\r\t\tset end of lst to Tuple(item i of xs, item i of ys)\r\tend repeat\r\treturn lst\rend zip",
  "zip3": "-- zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\ron zip3(xs, ys, zs)\r\tscript\r\t\ton |λ|(x, i)\r\t\t\tTuple3(x, item i of ys, item i of zs)\r\t\tend |λ|\r\tend script\r\tmap(result, items 1 thru ¬\r\t\tminimum({length of xs, length of ys, length of zs}) of xs)\rend zip3",
  "zip4": "-- zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]\ron zip4(ws, xs, ys, zs)\r\tscript\r\t\ton |λ|(w, i)\r\t\t\tTuple4(w, item i of xs, item i of ys, item i of zs)\r\t\tend |λ|\r\tend script\r\tmap(result, items 1 thru ¬\r\t\tminimum({length of xs, length of ys, length of zs}) of xs)\rend zip4",
  "zipWith": "-- zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\non zipWith(f, xs, ys)\n\tset lng to min(length of xs, length of ys)\n\tif lng < 1 then return {}\n\tset lst to {}\n\ttell mReturn(f)\n\t\trepeat with i from 1 to lng\n\t\t\tset end of lst to |λ|(item i of xs, item i of ys)\n\t\tend repeat\n\t\treturn lst\n\tend tell\nend zipWith",
  "zipWith3": "-- zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\non zipWith3(f, xs, ys, zs)\n    set lng to minimum({length of xs, length of ys, length of zs})\n    if lng < 1 then return {}\n    set lst to {}\n    tell mReturn(f)\n        repeat with i from 1 to lng\n            set end of lst to |λ|(item i of xs, item i of ys, item i of zs)\n        end repeat\n        return lst\n    end tell\nend zipWith3",
  "zipWith4": "-- zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]\ron zipWith4(f, ws, xs, ys, zs)\r\tset lng to minimum({length of ws, length of xs, length of ys, length of zs})\r\tif lng < 1 then return {}\r\tset lst to {}\r\ttell mReturn(f)\r\t\trepeat with i from 1 to lng\r\t\t\tset end of lst to |λ|(item i of ws, item i of xs, item i of ys, item i of zs)\r\t\tend repeat\r\t\treturn lst\r\tend tell\rend zipWith4"
}