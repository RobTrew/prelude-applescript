{
  "abs": "-- Absolute value.\n-- abs :: Num -> Num\non abs(x)\n    if x < 0 then\n        -x\n    else\n        x\n    end if\nend abs",
  "all": "-- Applied to a predicate and a list, `all` determines if all elements \n-- of the list satisfy the predicate.\n-- all :: (a -> Bool) -> [a] -> Bool\non all(f, xs)\n    tell mReturn(f)\n        set lng to length of xs\n        repeat with i from 1 to lng\n            if not |λ|(item i of xs, i, xs) then return false\n        end repeat\n        true\n    end tell\nend all",
  "and": "-- Returns the conjunction of a Boolean \n-- list. For the result to be true, \n-- all values in the list must be true.\n-- and :: [Bool] -> Bool\non |and|(xs)\n    repeat with x in xs\n        if not (contents of x) then return false\n    end repeat\n    return true\nend |and|",
  "any": "-- Applied to a predicate and a list, \n-- |any| returns true if at least one element of the \n-- list satisfies the predicate.\n-- any :: (a -> Bool) -> [a] -> Bool\non |any|(f, xs)\n    tell mReturn(f)\n        set lng to length of xs\n        repeat with i from 1 to lng\n            if |λ|(item i of xs) then return true\n        end repeat\n        false\n    end tell\nend |any|",
  "ap": "-- Applies wrapped functions to wrapped values, \n-- for example applying a list of functions to a list of values\n-- or applying Just(f) to Just(x), Right(f) to Right(x), etc\n-- ap (<*>) :: Monad m => m (a -> b) -> m a -> m b\non ap(mf, mx)\n    if class of mx is list then\n        apList(mf, mx)\n    else if class of mf is record then\n        set ks to keys(mf)\n        if ks contains \"type\" then\n            set t to type of mx\n            if \"Either\" = t then\n                apEither(mf, mx)\n            else if \"Maybe\" = t then\n                apMaybe(mf, mx)\n            else if \"Tuple\" = t then\n                apTuple(mf, mx)\n            else if \"Node\" = t then\n                apTree(mf, mx)\n            else\n                missing value\n            end if\n        else\n            missing value\n        end if\n    end if\nend ap",
  "apList": "-- e.g. [(*2),(/2), sqrt] <*> [1,2,3]\n-- -->  ap([dbl, hlf, root], [1, 2, 3])\n-- -->  [2,4,6,0.5,1,1.5,1,1.4142135623730951,1.7320508075688772]\n\n-- Each member of a list of functions applied to\n-- each of a list of arguments, deriving a list of new values\n-- apList (<*>) :: [(a -> b)] -> [a] -> [b]\non apList(fs, xs)\n    set lst to {}\n    repeat with f in fs\n        tell mReturn(contents of f)\n            repeat with x in xs\n                set end of lst to |λ|(contents of x)\n            end repeat\n        end tell\n    end repeat\n    return lst\nend apList",
  "apLR": "-- apLR (<*>) :: Either e (a -> b) -> Either e a -> Either e b\non apLR(flr, lr)\n    if isRight(flr) then\n        if isRight(lr) then\n            |Right|(|λ|(|Right| of lr) of mReturn(|Right| of flr))\n        else\n            lr\n        end if\n    else\n        flr\n    end if\nend apLR",
  "apMaybe": "-- Maybe f applied to Maybe x, deriving a Maybe y\n-- apMaybe (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\non apMaybe(mf, mx)\n    if Nothing of mf or Nothing of mx then\n        Nothing()\n    else\n        Just(|λ|(Just of mx) of mReturn(Just of mf))\n    end if\nend apMaybe",
  "append": "-- Append two lists.\n-- append (++) :: [a] -> [a] -> [a]\n-- append (++) :: String -> String -> String\non append(xs, ys)\n    xs & ys\nend append",
  "appendFile": "-- Write a string to the end of a file. \n-- Returns true if the path exists \n-- and the write succeeded. \n-- Otherwise returns false.\n-- appendFile :: FilePath -> String -> IO Bool\non appendFile(strPath, txt)\n    set ca to current application\n    set oFullPath to (ca's NSString's stringWithString:strPath)'s ¬\n        stringByStandardizingPath\n    set {blnExists, intFolder} to (ca's NSFileManager's defaultManager()'s ¬\n        fileExistsAtPath:oFullPath isDirectory:(reference))\n    if blnExists then\n        if intFolder = 0 then\n            set oData to (ca's NSString's stringWithString:txt)'s ¬\n                dataUsingEncoding:(ca's NSUTF8StringEncoding)\n            set h to ca's NSFileHandle's fileHandleForWritingAtPath:oFullPath\n            h's seekToEndOfFile\n            h's writeData:oData\n            h's closeFile()\n            true\n        else\n            -- text appended to folder is undefined\n            false\n        end if\n    else\n        if doesDirectoryExist(takeDirectory(oFullPath as string)) then\n            writeFile(oFullPath, txt)\n            true\n        else\n            false\n        end if\n    end if\nend appendFile",
  "appendFileMay": "-- Write a string to the end of a file. \n-- Returns a Just FilePath value if the \n-- path exists and the write succeeded. \n-- Otherwise returns Nothing.\n-- appendFileMay :: FilePath -> String -> Maybe IO FilePath\non appendFileMay(strPath, txt)\n    set ca to current application\n    set oFullPath to (ca's NSString's stringWithString:strPath)'s ¬\n        stringByStandardizingPath\n    set strFullPath to oFullPath as string\n    set {blnExists, intFolder} to (ca's NSFileManager's defaultManager()'s ¬\n        fileExistsAtPath:oFullPath isDirectory:(reference))\n    if blnExists then\n        if intFolder = 0 then -- Not a directory\n            set oData to (ca's NSString's stringWithString:txt)'s ¬\n                dataUsingEncoding:(ca's NSUTF8StringEncoding)\n            set h to ca's NSFileHandle's fileHandleForWritingAtPath:oFullPath\n            h's seekToEndOfFile\n            h's writeData:oData\n            h's closeFile()\n            Just(strFullPath)\n        else\n            Nothing()\n        end if\n    else\n        if doesDirectoryExist(takeDirectory(strFullPath)) then\n            writeFile(oFullPath, txt)\n            Just(strFullPath)\n        else\n            Nothing()\n        end if\n    end if\nend appendFileMay",
  "apply": "-- apply ($) :: (a -> b) -> a -> b\non apply(f, x)\n    mReturn(f)'s |λ|(x)\nend apply",
  "approxRatio": "-- approxRatio :: Real -> Real -> Ratio\non approxRatio(epsilon, n)\n    if epsilon is missing value then\n        set e to 1 / 10000\n    else\n        set e to epsilon\n    end if\n    \n    script gcde\n        on |λ|(e, x, y)\n            script _gcd\n                on |λ|(a, b)\n                    if b < e then\n                        a\n                    else\n                        |λ|(b, a mod b)\n                    end if\n                end |λ|\n            end script\n            |λ|(abs(x), abs(y)) of _gcd\n        end |λ|\n    end script\n    \n    set c to |λ|(e, 1, n) of gcde\n    Ratio((n div c), (1 div c))\nend approxRatio",
  "apTree": "-- apTree (<*>) :: Tree (a -> b) -> Tree a -> Tree b\non apTree(tf, tx)\n    set fmap to curry(my fmapTree)\n    script go\n        on |λ|(t)\n            set f to root of t\n            Node(mReturn(f)'s |λ|(root of tx), ¬\n                map(fmap's |λ|(f), nest of tx) & ¬\n                map(go, nest of t))\n        end |λ|\n    end script\n    \n    return go's |λ|(tf)\nend apTree",
  "apTuple": "-- apTuple (<*>) :: Monoid m => (m, (a -> b)) -> (m, a) -> (m, b)\non apTuple(tf, tx)\n    Tuple(mappend(|1| of tf, |1| of tx), |λ|(|2| of tx) of mReturn(|2| of tf))\nend apTuple",
  "argvLength": "-- argvLength :: Function -> Int\non argvLength(h)\n    try\n        mReturn(h)'s |λ|()\n        0\n    on error errMsg\n        set {dlm, my text item delimiters} to {my text item delimiters, \",\"}\n        set xs to text items of errMsg\n        set my text item delimiters to dlm\n        length of xs\n    end try\nend argvLength",
  "assocs": "-- assocs :: Map k a -> [(k, a)]\non assocs(m)\n    set c to class of m\n    if c is list then\n      zip(enumFromTo(1, length of m), m)\n    else if c is record then\n        set dict to (current application's ¬\n            NSDictionary's ¬\n            dictionaryWithDictionary:(m))\n        zip((dict's allKeys()'s ¬\n            sortedArrayUsingSelector:\"compare:\") as list, ¬\n            dict's allValues() as list)\n    else\n        {}\n    end if\nend assocs",
  "bind": "-- bind (>>=) :: Monad m => m a -> (a -> m b) -> m b\non bind(m, mf)\n    set c to class of m\n    if c = list then\n        bindList(m, mf)\n    else if c = record then\n        set ks to keys(m)\n        if ks contains \"type\" then\n            set t to type of m\n            if t = \"Maybe\" then\n                bindMay(m, mf)\n            else if t = \"Either\" then\n                bindEither(m, mf)\n            else if t = \"Tuple\" then\n                bindTuple(m, mf)\n            else\n                Nothing()\n            end if\n        else\n            Nothing()\n        end if\n    else\n        Nothing()\n    end if\nend bind",
  "bindList": "-- bindList (>>=) :: [a] -> (a -> [b]) -> [b]\non bindList(xs, f)\n    set acc to {}\n    tell mReturn(f)\n        repeat with x in xs\n            set acc to acc & |λ|(contents of x)\n        end repeat\n    end tell\n    return acc\nend bindList",
  "bindLR": "-- bindLR (>>=) :: Either a -> (a -> Either b) -> Either b\non bindLR(m, mf)\n    if missing value is not |Right| of m then\n        mReturn(mf)'s |λ|(|Right| of m)\n    else\n        m\n    end if\nend bindLR",
  "bindMay": "-- bindMay (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b\non bindMay(mb, mf)\n    if Nothing of mb then\n        mb\n    else\n        tell mReturn(mf) to |λ|(Just of mb)\n    end if\nend bindMay",
  "bindTuple": "-- bindTuple (>>=) :: Monoid a => (a, a) -> (a -> (a, b)) -> (a, b)\non bindTuple(tpl, f)\n    set t2 to mReturn(f)'s |λ|(|2| of tpl)\n    Tuple(mappend(|1| of tpl, |1| of t2), |2| of t2)\nend bindTuple",
  "break": "-- break :: (a -> Bool) -> [a] -> ([a], [a])\non break(p, xs)\n    set bln to false\n    tell mReturn(p)\n        set lng to length of xs\n        repeat with i from 1 to lng\n            if |λ|(item i of xs) then\n                set bln to true\n                exit repeat\n            end if\n        end repeat\n    end tell\n    if bln then\n        if i > 1 then\n            Tuple(items 1 thru (i - 1) of xs, items i thru -1 of xs)\n        else\n            Tuple({}, xs)\n        end if\n    else\n        Tuple(xs, {})\n    end if\nend break",
  "breakOn": "-- non null needle -> haystack -> (prefix before match, match + rest)\n-- breakOn :: String -> String -> (String, String)\non breakOn(pat, src)\n    if pat ≠ \"\" then\n        set {dlm, my text item delimiters} to {my text item delimiters, pat}\n        \n        set lstParts to text items of src\n        set lngParts to length of lstParts\n        \n        if lngParts > 1 then\n            set tpl to Tuple(item 1 of lstParts, pat & ¬\n                ((items 2 thru -1 of lstParts) as text))\n        else\n            set tpl to Tuple(src, \"\")\n        end if\n        \n        set my text item delimiters to dlm\n        return tpl\n    else\n        missing value\n    end if\nend breakOn",
  "breakOnAll": "-- breakOnAll \"::\" \"\"\n-- ==> []\n-- breakOnAll \"/\" \"a/b/c/\"\n-- ==> [(\"a\", \"/b/c/\"), (\"a/b\", \"/c/\"), (\"a/b/c\", \"/\")]\n-- breakOnAll :: String -> String -> [(String, String)]\non breakOnAll(pat, src)\n    if pat ≠ \"\" then\n        script\n            on |λ|(a, _, i, xs)\n                if i > 1 then\n                    a & {Tuple(intercalate(pat, take(i - 1, xs)), ¬\n                        pat & intercalate(pat, drop(i - 1, xs)))}\n                else\n                    a\n                end if\n            end |λ|\n        end script\n        foldl(result, {}, splitOn(pat, src))\n    else\n        missing value\n    end if\nend breakOnAll",
  "breakOnMay": "-- needle -> haystack -> maybe (prefix before match, match + rest)\n-- breakOnMay :: String -> String -> Maybe (String, String)\non breakOnMay(pat, src)\n    if pat ≠ \"\" then\n        set {dlm, my text item delimiters} to {my text item delimiters, pat}\n        \n        set lstParts to text items of src\n        if length of lstParts > 1 then\n            set mbTuple to Just(Tuple(item 1 of lstParts, pat & ¬\n                ((items 2 thru -1 of lstParts) as text)))\n        else\n            set mbTuple to Just(Tuple(src, \"\"))\n        end if\n        \n        set my text item delimiters to dlm\n        return mbTuple\n    else\n        Nothing()\n    end if\nend breakOnMay",
  "cartesianProduct": "-- cartesianProduct :: [a] -> [b] -> [(a, b)]\non cartesianProduct(xs, ys)\n    script\n        on |λ|(x)\n            script\n                on |λ|(y)\n                    {Tuple(x, y)}\n                end |λ|\n            end script\n            concatMap(result, ys)\n        end |λ|\n    end script\n    concatMap(result, xs)\nend cartesianProduct",
  "caseOf": "-- List of (Predicate, value) tuples -> Default value -> Value to test -> Output value\n-- caseOf :: [(a -> Bool, b)] -> b -> a ->  b\non caseOf (pvs, otherwise, x)\n    repeat with tpl in pvs\n        if mReturn(|1| of tpl)'s |λ|(x) then return |2| of tpl\n    end repeat\n    return otherwise\nend caseOf",
  "catMaybes": "-- catMaybes :: [Maybe a] -> [a]\non catMaybes(mbs)\n    script emptyOrListed\n        on |λ|(m)\n            if Nothing of m then\n                {}\n            else\n                {Just of m}\n            end if\n        end |λ|\n    end script\n    concatMap(emptyOrListed, mbs)\nend catMaybes",
  "ceiling": "-- ceiling :: Num -> Int\non ceiling(x)\n    set nr to properFraction(x)\n    set n to |1| of nr\n    if (|2| of nr) > 0 then\n        n + 1\n    else\n        n\n    end if\nend ceiling",
  "center": "-- center :: Int -> Char -> String -> String\non |center|(n, cFiller, strText)\n    set lngFill to n - (length of strText)\n    if lngFill > 0 then\n        set strPad to replicate(lngFill div 2, cFiller) as text\n        set strCenter to strPad & strText & strPad\n        if lngFill mod 2 > 0 then\n            cFiller & strCenter\n        else\n            strCenter\n        end if\n    else\n        strText\n    end if\nend |center|",
  "chars": "-- chars :: String -> [Char]\non chars(s)\n    characters of s\nend chars",
  "chr": "-- chr :: Int -> Char\non chr(n)\n    character id n\nend chr",
  "chunksOf": "-- chunksOf :: Int -> [a] -> [[a]]\non chunksOf(k, xs)\n    script\n        on go(ys)\n            set ab to splitAt(k, ys)\n            set a to |1| of ab\n            if isNull(a) then\n                {}\n            else\n                {a} & go(|2| of ab)\n            end if\n        end go\n    end script\n    result's go(xs)\nend chunksOf",
  "compare": "-- Ordering  :: (-1 | 0 | 1)\n-- compare :: a -> a -> Ordering\non compare(a, b)\n    if a < b then\n        |LT|\n    else if a > b then\n        |GT|\n    else\n        |EQ|\n    end if\nend compare",
  "comparing": "-- comparing :: (a -> b) -> (a -> a -> Ordering)\non comparing(f)\n    script\n        on |λ|(a, b)\n            tell mReturn(f)\n                set fa to |λ|(a)\n                set fb to |λ|(b)\n                if fa < fb then\n                    -1\n                else if fa > fb then\n                    1\n                else\n                    0\n                end if\n            end tell\n        end |λ|\n    end script\nend comparing",
  "compose": "-- compose :: (b -> c) -> (a -> b) -> a -> c\non compose(f, g)\n    script\n        on |λ|(x)\n            |λ|(|λ|(x) of mReturn(g)) of mReturn(f)\n        end |λ|\n    end script\nend compose",
  "composeListLR": "-- composeListLR :: [(a -> a)] -> (a -> a)\non composeListLR(fs)\n    script\n        on |λ|(x)\n            script\n                on |λ|(a, f)\n                    mReturn(f)'s |λ|(a)\n                end |λ|\n            end script\n            \n            foldl(result, x, fs)\n        end |λ|\n    end script\nend composeListLR",
  "composeListRL": "-- composeListRL :: [(a -> a)] -> (a -> a)\non composeListRL(fs)\n    script\n        on |λ|(x)\n            script\n                on |λ|(f, a)\n                    mReturn(f)'s |λ|(a)\n                end |λ|\n            end script\n            \n            foldr(result, x, fs)\n        end |λ|\n    end script\nend composeListRL",
  "concat": "-- concat :: [[a]] -> [a]\n-- concat :: [String] -> String\non concat(xs)\n    if length of xs > 0 and class of (item 1 of xs) is string then\n        set acc to \"\"\n    else\n        set acc to {}\n    end if\n    repeat with i from 1 to length of xs\n        set acc to acc & item i of xs\n    end repeat\n    acc\nend concat",
  "concatMap": "-- concatMap :: (a -> [b]) -> [a] -> [b]\non concatMap(f, xs)\n    tell mReturn(f)\n        set lng to length of xs\n        set acc to {}\n        repeat with i from 1 to lng\n            set acc to acc & |λ|(item i of xs, i, xs)\n        end repeat\n    end tell\n    return acc\nend concatMap",
  "cons": "-- cons :: a -> [a] -> [a]\non cons(x, xs)\n    {x} & xs\nend cons",
  "const_": "-- const_ :: a -> b -> a\non const_(k, _)\n    k\nend const_",
  "createDirectoryIfMissingLR": "-- createDirectoryIfMissingLR :: Bool -> FilePath -> Either String String\non createDirectoryIfMissingLR(blnParents, fp)\n    if doesPathExist(fp) then\n        |Right|(\"Found: '\" & fp & \"'\")\n    else\n        set e to reference\n        set ca to current application\n        set oPath to (ca's NSString's stringWithString:(fp))'s ¬\n            stringByStandardizingPath\n        set {blnOK, e} to ca's NSFileManager's ¬\n            defaultManager's createDirectoryAtPath:(oPath) ¬\n            withIntermediateDirectories:(blnParents) ¬\n            attributes:(missing value) |error|:(e)\n        if blnOK then\n            |Right|(fp)\n        else\n            |Left|((localizedDescription of e) as string)\n        end if\n    end if\nend createDirectoryIfMissingLR",
  "curry": "-- curry :: ((a, b) -> c) -> a -> b -> c\non curry(f)\n    script\n        on |λ|(a)\n            script\n                on |λ|(b)\n                    |λ|(a, b) of mReturn(f)\n                end |λ|\n            end script\n        end |λ|\n    end script\nend curry",
  "curry2": "-- Not distinct, in Applescript, from the default curry.\n-- (In JavaScript we have a choice between two-argument and N-argument currying,\n-- but for want of a way of detecting arity at run-time, the arbitrary\n-- N-argument version seems hard to implement in Applescript)\n-- curry2 :: ((a, b) -> c) -> a -> b -> c\non curry2(f)\n    script\n        on |λ|(a)\n            script\n                on |λ|(b)\n                    |λ|(a, b) of mReturn(f)\n                end |λ|\n            end script\n        end |λ|\n    end script\nend curry",
  "delete": "-- delete :: Eq a => a -> [a] -> [a]\non |delete|(x, xs)\n    set mbIndex to elemIndex(x, xs)\n    set lng to length of xs\n    \n    if Nothing of mbIndex then\n        xs\n    else\n        if lng > 1 then\n            set i to Just of mbIndex\n            if i = 1 then\n                items 2 thru -1 of xs\n            else if i = lng then\n                items 1 thru -2 of xs\n            else\n                tell xs to items 1 thru (i - 1) & items (i + 1) thru -1\n            end if\n        else\n            {}\n        end if\n    end if\nend |delete|",
  "deleteAt": "-- deleteAt :: Int -> [a] -> [a]\non deleteAt(i, xs)\n    set lr to splitAt(i, xs)\n    set {l, r} to {|1| of lr, |2| of lr}\n    if length of r > 1 then\n        l & items 2 thru -1 of r\n    else\n        l\n    end if\nend deleteAt",
  "deleteBy": "-- deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]\non deleteBy(fnEq, x, xs)\n    if length of xs > 0 then\n        set mb to uncons(xs)\n        if Nothing of mb then\n            xs\n        else\n            set ht to Just of mb\n            set {h, t} to {|1| of ht, |2| of ht}\n            if |λ|(x, h) of mReturn(fnEq) then\n                t\n            else\n                {h} & deleteBy(fnEq, x, t)\n            end if\n        end if\n    else\n        {}\n    end if\nend deleteBy",
  "deleteFirst": "-- deleteFirst :: a -> [a] -> [a]\non deleteFirst(x, xs)\n    script Eq\n        on |λ|(a, b)\n            a = b\n        end |λ|\n    end script\n \n    deleteBy(Eq, x, xs)\nend |delete|",
  "deleteFirstsBy": "-- deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\non deleteFirstsBy(fnEq, xs, ys)\n    script\n        on |λ|(x, y)\n            deleteBy(fnEq, y, x)\n        end |λ|\n    end script\n    foldl(result, xs, ys)\nend deleteFirstsBy",
  "deleteMap": "-- deleteMap :: k -> Dict -> Dict\non deleteMap(k, rec)\n    set nsDct to (current application's ¬\n        NSMutableDictionary's dictionaryWithDictionary:rec)\n    nsDct's removeObjectForKey:(k)\n    nsDct as record\nend deleteMap",
  "difference": "-- difference :: Eq a => [a] -> [a] -> [a]\non difference(xs, ys)\n    script \n        on |λ|(a, y)\n            if a contains y then\n                my |delete|(y, a)\n            else\n                a\n            end if\n        end |λ|\n    end script\n \n    foldl(result, xs, ys)\nend difference",
  "div": "-- div :: Int -> Int -> Int\non |div|(a, b)\n    a div b\nend |div|",
  "doesDirectoryExist": "-- doesDirectoryExist :: FilePath -> IO Bool\non doesDirectoryExist(strPath)\n    set ca to current application\n    set oPath to (ca's NSString's stringWithString:strPath)'s ¬\n        stringByStandardizingPath\n    set {bln, int} to (ca's NSFileManager's defaultManager's ¬\n        fileExistsAtPath:oPath isDirectory:(reference))\n    bln and (int = 1)\nend doesDirectoryExist",
  "doesFileExist": "-- doesFileExist :: FilePath -> IO Bool\non doesFileExist(strPath)\n    set ca to current application\n    set oPath to (ca's NSString's stringWithString:strPath)'s ¬\n        stringByStandardizingPath\n    set {bln, int} to (ca's NSFileManager's defaultManager's ¬\n        fileExistsAtPath:oPath isDirectory:(reference))\n    bln and (int ≠ 1)\nend doesFileExist",
  "doesPathExist": "-- doesPathExist :: FilePath -> IO Bool\non doesPathExist(strPath)\n    set ca to current application\n    ca's NSFileManager's defaultManager's ¬\n        fileExistsAtPath:((ca's NSString's ¬\n            stringWithString:strPath)'s ¬\n            stringByStandardizingPath)\nend doesPathExist",
  "draw": "-- draw :: Tree String -> [String]\non draw(tree)\n    \n    -- shift :: String -> String -> [String] -> [String]\n    script shift\n        on |λ|(strFirst, strOther, xs)\n            zipWith(my append, ¬\n                cons(strFirst, replicate((length of xs) - 1, strOther)), xs)\n        end |λ|\n    end script\n    \n    -- drawSubTrees :: [Tree String] -> [String]\n    script drawSubTrees\n        on |λ|(xs)\n            set lng to length of xs\n            if lng > 0 then\n                if lng > 1 then\n                    cons(\"│\", append(shift's |λ|(\"├─ \", \"│  \", draw(item 1 of xs)), ¬\n                        |λ|(items 2 thru -1 of xs)))\n                else\n                    cons(\"│\", shift's |λ|(\"└─ \", \"   \", draw(item 1 of xs)))\n                end if\n            else\n                {}\n            end if\n        end |λ|\n    end script\n    \n    paragraphs of (root of tree) & |λ|(nest of tree) of drawSubTrees\nend draw",
  "drawForest": "-- drawForest :: [Tree String] -> String\non drawForest(trees)\n    intercalate(\"\\n\\n\", map(my drawTree, trees))\nend drawForest",
  "drawTree": "-- drawTree :: Tree String -> String\non drawTree(tree)\n    unlines(draw(tree))\nend drawTree",
  "drop": "-- drop :: Int -> [a] -> [a]\non drop(n, xs)\n    if n < length of xs then\n        if class of xs is text then\n            text (n + 1) thru -1 of xs\n        else\n            items (n + 1) thru -1 of xs\n        end if\n    else\n        {}\n    end if\nend drop",
  "dropAround": "-- dropAround :: (Char -> Bool) -> String -> String\non dropAround(p, s)\n    dropWhile(p, dropWhileEnd(p, s))\nend dropAround",
  "dropFileName": "-- dropFileName :: FilePath -> FilePath\non dropFileName(strPath)\n    if strPath ≠ \"\" then\n        if character -1 of strPath = \"/\" then\n            strPath\n        else\n            set xs to init(splitOn(\"/\", strPath))\n            if xs ≠ {} then\n                intercalate(\"/\", xs) & \"/\"\n            else\n                \"./\"\n            end if\n        end if\n    else\n        \"./\"\n    end if\nend dropFileName",
  "dropWhile": "-- dropWhile :: (a -> Bool) -> [a] -> [a]\non dropWhile(p, xs)\n    set lng to length of xs\n    set i to 1\n    tell mReturn(p)\n        repeat while i ≤ lng and |λ|(item i of xs)\n            set i to i + 1\n        end repeat\n    end tell\n    if i ≤ lng then\n        if class of xs ≠ string then\n            items i thru lng of xs\n        else\n            text i thru lng of xs\n        end if\n    else\n        {}\n    end if\nend dropWhile",
  "dropWhileEnd": "-- dropWhileEnd :: (Char -> Bool) -> String -> String\n-- dropWhileEnd :: (a -> Bool) -> [a] -> [a]\non dropWhileEnd(p, xs)\n    set i to length of xs\n    tell mReturn(p)\n        repeat while i > 0 and |λ|(item i of xs)\n            set i to i - 1\n        end repeat\n    end tell\n    if i > 0 then\n        if class of xs ≠ string then\n            items 1 thru i of xs\n        else\n            text 1 thru i of xs\n        end if\n    else\n        {}\n    end if\nend dropWhileEnd",
  "either": "-- either :: (a -> c) -> (b -> c) -> Either a b -> c\non either(lf, rf, e)\n    if isRight(e) then\n        tell mReturn(rf) to |λ|(|Right| of e)\n    else\n        tell mReturn(lf) to |λ|(|Left| of e)\n    end if\nend either",
  "elem": "-- elem :: Eq a => a -> [a] -> Bool\non elem(x, xs)\n    considering case\n        xs contains x\n    end considering\nend elem",
  "elemAtMay": "-- If x is a Dictionary then reads the Int as an index\n-- into the lexically sorted keys of the Dict, \n-- returning a Maybe (Key, Value) pair.\n-- If x is a list, then return a Maybe a \n-- (In either case, returns Nothing for an Int out of range)\n-- elemAtMay :: Int -> Dict -> Maybe (String, a)\n-- elemAtMay :: Int -> [a] -> Maybe a\non elemAtMay(i, x)\n    set bln to class of x is record\n    if bln then\n        set ks to keys(x)\n        if i ≤ |length|(ks) then\n            set k to item i of sort(ks)\n            script pair\n                on |λ|(v)\n                    Just(Tuple(k, v))\n                end |λ|\n            end script\n            bindMay(lookup(k, x), pair)\n        end if\n    else\n        if i ≤ |length|(x) then\n            Just(item i of x)\n        else\n            Nothing()\n        end if\n    end if\nend elemAtMay",
  "elemIndex": "-- elemIndex :: Eq a => a -> [a] -> Maybe Int\non elemIndex(x, xs)\n    set lng to length of xs\n    repeat with i from 1 to lng\n        if x = (item i of xs) then return Just(i)\n    end repeat\n    return Nothing()\nend elemIndex",
  "elemIndices": "-- elemIndices :: Eq a => a -> [a] -> [Int]\non elemIndices(x, xs)\n    script\n        on |λ|(y, i)\n            if y = x then\n                {i}\n            else\n                {}\n            end if\n        end |λ|\n    end script\n    concatMap(result, xs)\nend elemIndices",
  "elems": "-- elems :: Dict -> [a]\non elems(rec)\n    set ca to current application\n    (ca's NSDictionary's dictionaryWithDictionary:rec)'s allValues() as list\nend elems",
  "enumFromThenTo": "-- enumFromThenTo :: Enum a => a -> a -> a -> [a]\non enumFromThenTo(x1, x2, y)\n    if class of x1 is integer then\n        enumFromThenToInt(x1, x2, y)\n    else\n        enumFromThenToChar(x1, x2, y)\n    end if\nend enumFromThenTo",
  "enumFromThenToChar": "-- enumFromThenToChar :: Char -> Char -> Char -> [Char]\non enumFromThenToChar(x1, x2, y)\n    set {int1, int2, intY} to {id of x1, id of x2, id of y}\n    set xs to {}\n    repeat with i from int1 to intY by (int2 - int1)\n        set end of xs to character id i\n    end repeat\n    return xs\nend enumFromThenToChar",
  "enumFromThenToInt": "-- enumFromThenToInt :: Int -> Int -> Int -> [Int]\non enumFromThenToInt(x1, x2, y)\n    set xs to {}\n    repeat with i from x1 to y by (x2 - x1)\n        set end of xs to i\n    end repeat\n    return xs\nend enumFromThenToInt\n",
  "enumFromTo": "-- enumFromTo :: Enum a => a -> a -> [a]\non enumFromTo(m, n)\n    if class of m is integer then\n        enumFromToInt(m, n)\n    else\n        enumFromToChar(m, n)\n    end if\nend enumFromTo",
  "enumFromToChar": "-- enumFromToChar :: Char -> Char -> [Char]\non enumFromToChar(m, n)\n    set {intM, intN} to {id of m, id of n}\n    if intM ≤ intN then\n        set xs to {}\n        repeat with i from intM to intN\n            set end of xs to character id i\n        end repeat\n        return xs\n    else\n        {}\n    end if\nend enumFromToChar",
  "enumFromToInt": "-- enumFromToInt :: Int -> Int -> [Int]\non enumFromToInt(m, n)\n    if m ≤ n then\n        set lst to {}\n        repeat with i from m to n\n            set end of lst to i\n        end repeat\n        return lst\n    else\n        return {}\n    end if\nend enumFromToInt",
  "EQ": "-- EQ :: Ordering\nproperty |EQ| : {type:\"Ordering\", value:0}",
  "eq": "-- eq (==) :: Eq a => a -> a -> Bool\non eq(a, b)\n    a = b\nend eq",
  "evalJSMay": "-- use framework \"Foundation\"\n-- use framework \"JavaScriptCore\"\n\n-- gJSC can be declared in the global namespace,\n-- but unless the reference is released before the \n-- end of the script (e.g. `set gJSC to null`)\n-- it will persist, and\n-- Script Editor will be unable to save a .scpt file\n-- evalJSMay :: String -> Maybe a\non evalJSMay(strJS)\n    try -- NB if gJSC is global it must be released \n        -- (e.g. set to null) at end of script\n        gJSC's evaluateScript\n    on error\n        set gJSC to current application's JSContext's new()\n        log (\"new JSC\")\n    end try\n    set v to unwrap((gJSC's evaluateScript:(strJS))'s toObject())\n    if v is missing value then\n        Nothing()\n    else\n        Just(v)\n    end if\nend evalJSMay",
  "even": "-- even :: Int -> Bool\non even(x)\n    x mod 2 = 0\nend even",
  "exp": "-- exp :: Float -> Float\non exp(n)\n    Just of evalJSMay((\"Math.exp(\" & n as string) & \")\")\nend exp",
  "fanArrow": "-- Compose a function from a simple value to a tuple of\n-- the separate outputs of two different functions\n-- fanArrow (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))\non fanArrow(f, g)\n    script\n        on |λ|(x)\n            Tuple(mReturn(f)'s |λ|(x), mReturn(g)'s |λ|(x))\n        end |λ|\n    end script\nend fanArrow",
  "filePath": "-- filePath :: String -> FilePath\non filePath(s)\n    ((current application's ¬\n        NSString's stringWithString:s)'s ¬\n        stringByStandardizingPath()) as string\nend filePath",
  "filePathTree": "-- filePathTree :: filePath -> [Tree String] -> Tree FilePath\non filePathTree(fpAnchor, trees)\n    script go\n        on |λ|(fp)\n            script\n                on |λ|(tree)\n                    set strPath to fp & \"/\" & (root of tree)\n                    \n                    Node(strPath, map(go's |λ|(strPath), nest of tree))\n                end |λ|\n            end script\n        end |λ|\n    end script\n    \n    Node(fpAnchor, map(go's |λ|(fpAnchor), trees))\nend filePathTree",
  "fileSize": "-- fileSize :: FilePath -> Either String Int\non fileSize(fp)\n    script fs\n        on |λ|(rec)\n            |Right|(NSFileSize of rec)\n        end |λ|\n    end script\n    bindLR(my fileStatus(fp), fs)\nend fileSize",
  "fileStatus": "-- fileStatus :: FilePath -> Either String Dict\non fileStatus(fp)\n    set e to reference\n    set {v, e} to current application's NSFileManager's defaultManager's ¬\n        attributesOfItemAtPath:fp |error|:e\n    if v is not missing value then\n        |Right|(v as record)\n    else\n        |Left|((localizedDescription of e) as string)\n    end if\nend fileStatus",
  "filter": "-- filter :: (a -> Bool) -> [a] -> [a]\non filter(f, xs)\n    tell mReturn(f)\n        set lst to {}\n        set lng to length of xs\n        repeat with i from 1 to lng\n            set v to item i of xs\n            if |λ|(v, i, xs) then set end of lst to v\n        end repeat\n        return lst\n    end tell\nend filter",
  "find": "-- find :: (a -> Bool) -> [a] -> Maybe a\non find(p, xs)\n    tell mReturn(p)\n        set lng to length of xs\n        repeat with i from 1 to lng\n            if |λ|(item i of xs) then return Just(item i of xs)\n        end repeat\n        Nothing()\n    end tell\nend find",
  "findIndex": "-- Takes a predicate function and a list and\n-- returns Just( the 1-based index of the first\n-- element ) in the list satisfying the predicate\n-- or Nothing if there is no such element.\n-- findIndex(isSpace, \"hello world\")\n--> {type:\"Maybe\", Nothing:false, Just:6}\n\n-- findIndex(even, [3, 5, 7, 8, 9])\n--> {type:\"Maybe\", Nothing:false, Just:4}\n\n-- findIndex(isUpper, \"all lower case\")\n--> {type:\"Maybe\", Nothing:true}\n-- findIndex :: (a -> Bool) -> [a] -> Maybe Int\non findIndex(p, xs)\n    tell mReturn(p)\n        set lng to length of xs\n        repeat with i from 1 to lng\n            if |λ|(item i of xs) then return Just(i)\n        end repeat\n        return Nothing()\n    end tell\nend findIndex",
  "findIndexR": "-- findIndexR :: (a -> Bool) -> [a] -> Maybe Int\non findIndexR(f, xs)\n    tell mReturn(f)\n        set lng to length of xs\n        repeat with i from lng to 1 by -1\n            if |λ|(item i of xs) then return Just(i)\n        end repeat\n        return Nothing()\n    end tell\nend findIndexR",
  "findIndices": "-- findIndices :: (a -> Bool) -> [a] -> [Int]\non findIndices(p, xs)\n    script\n        property f : mReturn(p)'s |λ|\n        on |λ|(x, i)\n            if f(x) then\n                {i}\n            else\n                {}\n            end if\n        end |λ|\n    end script\n    concatMap(result, xs)\nend findIndices",
  "firstArrow": "-- Lift a simple function to one which applies to a tuple, \n-- transforming only the first item of the tuple\n-- firstArrow :: (a -> b) -> ((a, c) -> (b, c))\non firstArrow(f)\n    script\n        on |λ|(xy)\n            Tuple(mReturn(f)'s |λ|(|1| of xy), |2| of xy)\n        end |λ|\n    end script\nend |first|",
  "flatten": "-- flatten :: NestedList a -> [a]\non flatten(t)\n    if list is class of t then\n        concatMap(my flatten, t)\n    else\n        t\n    end if\nend flatten",
  "flattenTree": "-- The root elements of a tree in pre-order.\n-- flattenTree :: Tree a -> [a]\non flattenTree(node)\n    script go\n        on |λ|(x, xs)\n            {root of x} & foldr(go, xs, nest of x)\n        end |λ|\n    end script\n    go's |λ|(node, {})\nend flattenTree",
  "flip": "-- flip :: (a -> b -> c) -> b -> a -> c\non flip(f)\n    script\n        property g : f\n        on |λ|(x, y)\n            g(y, x)\n        end |λ|\n    end script\nend flip",
  "floor": "-- floor :: Num -> Int\non floor(x)\n    set nr to properFraction(x)\n    set n to |1| of nr\n    if (|2| of nr) < 0 then\n        n - 1\n    else\n        n\n    end if\nend floor",
  "fmap": "-- fmap (<$>) :: Functor f => (a -> b) -> f a -> f b\non fmap(f, fa)\n    if class of fa is record and keys(fa) contains \"type\" then\n        set t to type of fa\n        if \"Either\" = t then\n            set fm to my fmapLR\n        else if \"Maybe\" = t then\n            set fm to my fmapMay\n        else if \"Tree\" = t then\n            set fm to my fmapTree\n        else if \"Tuple\" = t then\n            set fm to my fmapTuple\n        else\n            set fm to my map\n        end if\n        |λ|(f, fa) of mReturn(fm)\n    else\n        map(f, fa)\n    end if\nend fmap",
  "fmapLR": "-- fmapLR (<$>) :: (a -> b) -> Either a a -> Either a b\non fmapLR(f, lr)\n    if isRight(lr) then\n        |Right|(|λ|(|Right| of lr) of mReturn(f))\n    else\n        lr\n    end if\nend fmapLR",
  "fmapMay": "-- fmapMay (<$>) :: (a -> b) -> Maybe a -> Maybe b\non fmapMay(f, mb)\n    if Nothing of mb then\n        mb\n    else\n        Just(|λ|(Just of mb) of mReturn(f))\n    end if\nend fmapMay",
  "fmapTree": "-- fmapTree :: (a -> b) -> Tree a -> Tree b\non fmapTree(f, tree)\n    script go\n        property g : |λ| of mReturn(f)\n        on |λ|(x)\n            set xs to nest of x\n            if xs ≠ {} then\n                set ys to map(go, xs)\n            else\n                set ys to xs\n            end if\n            Node(g(root of x), ys)\n        end |λ|\n    end script\n  |λ|(tree) of go\nend fmapTree",
  "fmapTuple": "-- fmapTuple (<$>) :: (a -> b) -> (a, a) -> (a, b)\non fmapTuple(f, tpl)\n    Tuple(|1| of tpl, |λ|(|2| of tpl) of mReturn(f))\nend fmapTuple",
  "foldl": "-- foldl :: (a -> b -> a) -> a -> [b] -> a\non foldl(f, startValue, xs)\n    tell mReturn(f)\n      set v to startValue\n      set lng to length of xs\n      repeat with i from 1 to lng\n          set v to |λ|(v, item i of xs, i, xs)\n      end repeat\n      return v\n      end tell\nend foldl",
  "foldl1": "-- foldl1 :: (a -> a -> a) -> [a] -> a\non foldl1(f, xs)\n    if length of xs > 1 then\n        tell mReturn(f)\n            set v to {item 1 of xs}\n            set lng to length of xs\n            repeat with i from 2 to lng\n                set v to |λ|(v, item i of xs, i, xs)\n            end repeat\n            return v\n        end tell\n    else\n        item 1 of xs\n    end if\nend foldl1",
  "foldl1May": "-- foldl1May :: (a -> a -> a) -> [a] -> Maybe a\non foldl1May(f, xs)\n    set lng to length of xs\n    if lng > 0 then\n        if lng > 1 then\n            tell mReturn(f)\n                set v to {item 1 of xs}\n                set lng to length of xs\n                repeat with i from 2 to lng\n                    set v to |λ|(v, item i of xs, i, xs)\n                end repeat\n                return Just(v)\n            end tell\n        else\n            Just(item 1 of xs)\n        end if\n    else\n        Nothing()\n    end if\nend foldl1May",
  "foldlTree": "-- foldlTree :: (b -> a -> b) -> b -> Tree a -> b\non foldlTree(f, acc, tree)\n    script go\n        property g : |λ| of mReturn(f)\n        on |λ|(a, x)\n            set xs to nest of x\n            if xs ≠ {} then\n                foldl(go, g(a, root of x), xs)\n            else\n                g(a, root of x)\n            end if\n        end |λ|\n    end script\n    |λ|(acc, tree) of go\nend foldlTree",
  "foldMapTree": "-- foldMapTree :: Monoid m => (a -> m) -> Tree a -> m\non foldMapTree(f, tree)\n    script go\n        property g : mReturn(f)'s |λ|\n        on |λ|(x)\n            if length of (nest of x) > 0 then\n                mappend(g(root of x), ¬\n                    foldl1(my mappend, (map(go, nest of x))))\n            else\n                g(root of x)\n            end if\n        end |λ|\n    end script\n    \n    |λ|(tree) of go\nend foldMapTree",
  "foldr": "-- foldr :: (a -> b -> b) -> b -> [a] -> b\non foldr(f, startValue, xs)\n    tell mReturn(f)\n        set v to startValue\n        set lng to length of xs\n        repeat with i from lng to 1 by -1\n            set v to |λ|(item i of xs, v, i, xs)\n        end repeat\n        return v\n    end tell\nend foldr",
  "foldr1": "-- foldr1 :: (a -> a -> a) -> [a] -> a\non foldr1(f, xs)\n    if length of xs > 1 then\n        tell mReturn(f)\n            set v to item -1 of xs\n            set lng to length of xs\n            repeat with i from lng - 1 to 1 by -1\n                set v to |λ|(item i of xs, v, i, xs)\n            end repeat\n            return v\n        end tell\n    else\n        xs\n    end if\nend foldr1",
  "foldr1May": "-- foldr1May :: (a -> a -> a) -> [a] -> Maybe a\non foldr1May(f, xs)\n    set lng to length of xs\n    if lng > 0 then\n        tell mReturn(f)\n            set v to item -1 of xs\n            repeat with i from lng - 1 to 1 by -1\n                set v to |λ|(item i of xs, v, i, xs)\n            end repeat\n            return Just(v)\n        end tell\n    else\n        Nothing()\n    end if\nend foldr1May",
  "foldTree": "-- foldTree :: (a -> [b] -> b) -> Tree a -> b\non foldTree(f, tree)\n    script go\n        property g : mReturn(f)'s |λ|\n        on |λ|(oNode)\n            g(root of oNode, map(go, nest of oNode))\n        end |λ|\n    end script\n    |λ|(tree) of go\nend foldTree",
  "fromEnum": "-- fromEnum :: Enum a => a -> Int\non fromEnum(x)\n    set c to class of x\n    if c is boolean then\n        if x then\n            1\n        else\n            0\n        end if\n    else if c is text then\n        if x ≠ \"\" then\n            id of x\n        else\n            missing value\n        end if\n    else\n        x as integer\n    end if\nend fromEnum",
  "fromLeft": "-- fromLeft :: a -> Either a b -> a\non fromLeft(def, lr)\n    if isLeft(lr) then\n        |Left| of lr\n    else\n        def\n    end if\nend fromLeft",
  "fromMaybe": "-- fromMaybe :: a -> Maybe a -> a\non fromMaybe(d, mb)\n    if Nothing of mb then\n        def\n    else\n        Just of mb\n    end if\nend fromMaybe",
  "fromRight": "-- fromRight :: b -> Either a b -> b\non fromRight(def, lr)\n    if isRight(lr) then\n        |Right| of lr\n    else\n        def\n    end if\nend fromRight",
  "fst": "-- fst :: (a, b) -> a\non fst(tpl)\n    if class of tpl is record then\n        |1| of tpl\n    else\n        item 1 of tpl\n    end if\nend fst",
  "gcd": "-- gcd :: Int -> Int -> Int\non gcd(a, b)\n    set x to abs(a)\n    set y to abs(b)\n    repeat until y = 0\n        if x > y then\n            set x to x - y\n        else\n            set y to y - x\n        end if\n    end repeat\n    return x\nend gcd",
  "genericIndexMay": "-- genericIndexMay :: [a] -> Int -> Maybe a\non genericIndexMay(xs, i)\n    if i < (length of xs) and i ≥ 0 then\n        Just(item (i + 1) of xs)\n    else\n        Nothing()\n    end if\nend genericIndexMay",
  "getCurrentDirectory": "-- getCurrentDirectory :: IO FilePath\non getCurrentDirectory()\n    set ca to current application\n    ca's NSFileManager's defaultManager()'s currentDirectoryPath as string\nend getCurrentDirectory",
  "getDirectoryContents": "-- getDirectoryContents :: FilePath -> IO [FilePath]\non getDirectoryContents(strPath)\n    set ca to current application\n    (ca's NSFileManager's defaultManager()'s ¬\n        contentsOfDirectoryAtPath:(stringByStandardizingPath of (¬\n            ca's NSString's stringWithString:(strPath))) ¬\n            |error|:(missing value)) as list\nend getDirectoryContents",
  "getFinderDirectory": "-- getFinderDirectory :: IO FilePath\non getFinderDirectory()\n    tell application \"Finder\" to POSIX path of (insertion location as alias)\nend getFinderDirectory",
  "getHomeDirectory": "-- getHomeDirectory :: IO FilePath\non getHomeDirectory()\n    current application's NSHomeDirectory() as string\nend getHomeDirectory",
  "getTemporaryDirectory": "-- getTemporaryDirectory :: IO FilePath\non getTemporaryDirectory()\n    current application's NSTemporaryDirectory() as string\nend getTemporaryDirectory",
  "group": "-- group :: Eq a => [a] -> [[a]]\non group(xs)\n    script eq\n        on |λ|(a, b)\n            a = b\n        end |λ|\n    end script\n    \n    groupBy(eq, xs)\nend group",
  "groupBy": "-- Typical usage: groupBy(on(eq, f), xs)\n-- groupBy :: (a -> a -> Bool) -> [a] -> [[a]]\non groupBy(f, xs)\n    set mf to mReturn(f)\n    \n    script enGroup\n        on |λ|(a, x)\n            if length of (active of a) > 0 then\n                set h to item 1 of active of a\n            else\n                set h to missing value\n            end if\n            \n            if h is not missing value and mf's |λ|(h, x) then\n                {active:(active of a) & {x}, sofar:sofar of a}\n            else\n                {active:{x}, sofar:(sofar of a) & {active of a}}\n            end if\n        end |λ|\n    end script\n    \n    if length of xs > 0 then\n        set dct to foldl(enGroup, {active:{item 1 of xs}, sofar:{}}, tail(xs))\n        if length of (active of dct) > 0 then\n            sofar of dct & {active of dct}\n        else\n            sofar of dct\n        end if\n    else\n        {}\n    end if\nend groupBy",
  "groupSortOn": "-- Sort and group a list by comparing the results of a key function\n-- applied to each element. groupSortOn f is equivalent to\n-- groupBy eq $ sortBy (comparing f),\n-- but has the performance advantage of only evaluating f once for each\n-- element in the input list.\n-- This is a decorate-(group.sort)-undecorate pattern, as in the\n-- so-called 'Schwartzian transform'.\n-- Groups are arranged from from lowest to highest.\n-- groupSortOn :: Ord b => (a -> b) -> [a] -> [a]\n-- groupSortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\non groupSortOn(f, xs)\n    script keyBool\n        on |λ|(a, x)\n            if class of x is boolean then\n                {asc:x, fbs:fbs of a}\n            else\n                {asc:true, fbs:({Tuple(x, asc of a)} & fbs of a)}\n            end if\n        end |λ|\n    end script\n    set {fs, bs} to {|1|, |2|} of unzip(fbs of foldl(keyBool, ¬\n        {asc:true, fbs:{}}, flatten({f})))\n    \n    set intKeys to length of fs\n    set ca to current application\n    script dec\n        property gs : map(my mReturn, fs)\n        on |λ|(x)\n            set nsDct to (ca's NSMutableDictionary's ¬\n                dictionaryWithDictionary:{val:x})\n            repeat with i from 1 to intKeys\n                (nsDct's setValue:((item i of gs)'s |λ|(x)) ¬\n                    forKey:(character id (96 + i)))\n            end repeat\n            nsDct as record\n        end |λ|\n    end script\n    \n    script descrip\n        on |λ|(bool, i)\n            ca's NSSortDescriptor's ¬\n                sortDescriptorWithKey:(character id (96 + i)) ¬\n                    ascending:bool\n        end |λ|\n    end script\n    \n    script grpUndec\n        on |λ|(grp)\n            script\n                on |λ|(x)\n                    val of x\n                end |λ|\n            end script\n            map(result, grp)\n        end |λ|\n    end script\n    \n    script aEq\n        on |λ|(p, q)\n            (a of p) = (a of q)\n        end |λ|\n    end script\n    \n    -- Sorted, grouped, undecorated\n    map(grpUndec, ¬\n        groupBy(aEq, ((ca's NSArray's arrayWithArray:map(dec, xs))'s ¬\n            sortedArrayUsingDescriptors:map(descrip, bs)) as list))\nend groupSortOn",
  "GT": "-- GT :: Ordering\nproperty |GT| : {type:\"Ordering\", value:1}",
  "head": "-- head :: [a] -> a\non head(xs)\n    if xs = {} then\n        missing value\n    else\n        item 1 of xs\n    end if\nend head",
  "headMay": "-- headMay :: [a] -> Maybe a\non headMay(xs)\n    if xs = {} then\n        Nothing()\n    else\n        Just(item 1 of xs)\n    end if\nend headMay",
  "id": "-- id :: a -> a\non |id|(x)\n    x\nend |id|",
  "indented": "-- indented :: String -> String -> String\non indented(strIndent, s)\n    script\n        on |λ|(x)\n            if x ≠ \"\" then\n                strIndent & x\n            else\n                x\n            end if\n        end |λ|\n    end script\n    unlines(map(result, |lines|(s)))\nend indented",
  "index": "-- index (!!) :: [a] -> Int -> a\non |index|(xs, i)\n    item i of xs\nend |index|",
  "init": "-- init :: [a] -> [a]\n-- init :: [String] -> [String]\non init(xs)\n    set blnString to class of xs = string\n    set lng to length of xs\n    \n    if lng > 1 then\n        if blnString then\n            text 1 thru -2 of xs\n        else\n            items 1 thru -2 of xs\n        end if\n    else if lng > 0 then\n        if blnString then\n            \"\"\n        else\n            {}\n        end if\n    else\n        missing value\n    end if\nend init\n",
  "initMay": "-- initMay :: [a] -> Maybe [a]\n-- initMay :: [String] -> Maybe [String]\non initMay(xs)\n    set blnString to class of xs = string\n    set lng to length of xs\n    if lng > 1 then\n        if blnString then\n            Just(text 1 thru -2 of xs)\n        else\n            Just(items 1 thru -2 of xs)\n        end if\n    else if lng > 0 then\n        if blnString then\n            Just(\"\")\n        else\n            Just({})\n        end if\n    else\n        Nothing()\n    end if\nend initMay",
  "inits": "-- inits :: [a] -> [[a]]\n-- inits :: String -> [String]\non inits(xs)\n    script elemInit\n        on |λ|(_, i, xs)\n            items 1 thru i of xs\n        end |λ|\n    end script\n    \n    script charInit\n        on |λ|(_, i, xs)\n            text 1 thru i of xs\n        end |λ|\n    end script\n    \n    if class of xs is string then\n        {\"\"} & map(charInit, xs)\n    else\n        {{}} & map(elemInit, xs)\n    end if\nend inits",
  "insert": "-- insert :: Ord a => a -> [a] -> [a]\non insert(x, ys)\n    insertBy(my compare, x, ys)\nend insert",
  "insertBy": "-- insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\non insertBy(cmp, x, ys)\n    set lng to length of ys\n    if lng > 0 then\n        tell mReturn(cmp)\n            set bln to false\n            repeat with i from 1 to lng\n                if |λ|(item i of ys, x) > 0 then\n                    set bln to true\n                    exit repeat\n                end if\n            end repeat\n        end tell\n        if bln then\n            if i > 1 then\n                items 1 thru (i - 1) of ys & x & items i thru -1 of ys\n            else\n                {x} & ys\n            end if\n        else\n            ys & x\n        end if\n    else\n        {x}\n    end if\nend insertBy",
  "insertMap": "-- insertMap :: Dict -> String -> a -> Dict\non insertMap(rec, k, v)\n    set ca to current application\n    set nsDct to (ca's NSMutableDictionary's dictionaryWithDictionary:rec)\n    nsDct's setValue:v forKey:(k as string)\n    nsDct as record\nend insertMap",
  "intercalate": "-- intercalate :: [a] -> [[a]] -> [a]\n-- intercalate :: String -> [String] -> String\non intercalate(sep, xs)\n  concat(intersperse(sep, xs))\nend intercalate",
  "intercalateS": "-- intercalateS :: String -> [String] -> String\non intercalateS(sep, xs)\n    set {dlm, my text item delimiters} to {my text item delimiters, sep}\n    set s to xs as text\n    set my text item delimiters to dlm\n    return s\nend intercalateS",
  "intersect": "-- intersect :: (Eq a) => [a] -> [a] -> [a]\non intersect(xs, ys)\n    if length of xs < length of ys then\n        set {shorter, longer} to {xs, ys}\n    else\n        set {longer, shorter} to {xs, ys}\n    end if\n    if shorter ≠ {} then\n        set lst to {}\n        repeat with x in shorter\n            if longer contains x then set end of lst to contents of x\n        end repeat\n        lst\n    else\n        {}\n    end if\nend intersect",
  "intersectBy": "-- intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\non intersectBy(eq, xs, ys)\n    if length of xs > 0 and length of ys > 0 then\n        set p to curry(eq)\n        script matchFound\n            on |λ|(x)\n                any(p's |λ|(x), ys)\n            end |λ|\n        end script\n        \n        filter(matchFound, xs)\n    else\n        {}\n    end if\nend intersectBy",
  "intersectionBy": "-- intersectionBy:: (a -> a -> Bool) -> [[a]] -> [a]\non intersectionBy(fnEq, xs)\n    script\n        property eq : mReturn(fnEq)\n        on |λ|(a, x)\n            intersectBy(eq, a, x)\n        end |λ|\n    end script\n    foldr1(result, xs)\nend intersectionBy",
  "intersperse": "-- intersperse(0, [1,2,3]) -> [1, 0, 2, 0, 3]\n-- intersperse :: a -> [a] -> [a]\n-- intersperse :: Char -> String -> String\non intersperse(sep, xs)\n    set lng to length of xs\n    if lng > 1 then\n        set acc to {item 1 of xs}\n        repeat with i from 2 to lng\n            set acc to acc & {sep, item i of xs}\n        end repeat\n        if class of xs is string then\n            concat(acc)\n        else\n            acc\n        end if\n    else\n        xs\n    end if\nend intersperse",
  "intToDigit": "-- intToDigit :: Int -> Char\non intToDigit(n)\n    if n ≥ 0 and n < 16 then\n        character (n + 1) of \"0123456789ABCDEF\"\n    else\n        \"?\"\n    end if\nend intToDigit",
  "isAlpha": "-- isAlpha :: Char -> Bool\non isAlpha(c)\n    set ca to current application\n    set oRgx to ca's NSRegularExpression's ¬\n        regularExpressionWithPattern:(\"[A-Za-z0-9\\\\u00C0-\\\\u00FF]\") ¬\n            options:(ca's NSRegularExpressionAnchorsMatchLines as integer) ¬\n            |error|:(missing value)\n    set oString to ca's NSString's stringWithString:c\n    0 < (oRgx's numberOfMatchesInString:oString options:0 ¬\n        range:{location:0, |length|:1})\nend isAlpha",
  "isChar": "-- isChar :: a -> Bool\non isChar(x)\n    class of x is string and length of x is 1\nend isChar",
  "isDigit": "-- isDigit :: Char -> Bool\non isDigit(c)\n    set d to (id of c) - 48 -- id of \"0\"\n    d ≥ 0 and d ≤ 9\nend isDigit",
  "isInfixOf": "-- isInfixOf :: Eq a => [a] -> [a] -> Bool\n-- isInfixOf :: String -> String -> Bool\non isInfixOf(needle, haystack)\n    haystack contains needle\nend isInfixOf",
  "isLeft": "-- isLeft :: Either a b -> Bool\non isLeft(x)\n    set dct to current application's ¬\n        NSDictionary's dictionaryWithDictionary:x\n    (dct's objectForKey:\"type\") as text = \"Either\" and ¬\n        (dct's objectForKey:\"Right\") as list = {missing value}\nend isLeft",
  "isLower": "-- isLower :: Char -> Bool\non isLower(c)\n    set d to (id of c) - 97 -- id of \"a\"\n    d ≥ 0 and d < 26\nend isLower",
  "isMaybe": "use framework \"Foundation\"\nuse scripting additions\n-- isMaybe :: a -> Bool\non isMaybe(x)\n    if class of x is record then\n        set ca to current application\n        set v to ((ca's NSDictionary's ¬\n            dictionaryWithDictionary:x)'s ¬\n            objectForKey:\"type\")\n        v is not missing value ¬\n            and (v's isKindOfClass:(ca's NSString)) ¬\n            and (v as string = \"Maybe\")\n    else\n      false\n    end if\nend isMaybe",
  "isNull": "-- isNull :: [a] -> Bool\n-- isNull :: String -> Bool\non isNull(xs)\n    if class of xs is string then\n        xs = \"\"\n    else\n        xs = {}\n    end if\nend isNull",
  "iso8601Local": "-- iso8601Local :: Date -> String\non iso8601Local(dte)\n    (dte as «class isot» as string)\nend iso8601Local",
  "isPrefixOf": "-- isPrefixOf takes two lists or strings and returns \n--  true if and only if the first is a prefix of the second.\n-- isPrefixOf :: [a] -> [a] -> Bool\n-- isPrefixOf :: String -> String -> Bool\non isPrefixOf(xs, ys)\n  set intX to length of xs\n    if intX < 1 then\n        true\n    else if intX > length of ys then\n        false\n    else if class of xs is string then\n        (offset of xs in ys) = 1\n    else\n        set {xxt, yyt} to {Just of uncons(xs), Just of uncons(ys)}\n        ((|1| of xxt) = (|1| of yyt)) and isPrefixOf(|2| of xxt, |2| of yyt)\n    end if\nend isPrefixOf",
  "isRight": "-- isRight :: Either a b -> Bool\non isRight(x)\n    set dct to current application's ¬\n        NSDictionary's dictionaryWithDictionary:x\n    (dct's objectForKey:\"type\") as text = \"Either\" and ¬\n        (dct's objectForKey:\"Left\") as list = {missing value}\nend isRight",
  "isSortedBy": "-- The 'isSortedBy' function returns true iff the predicate returns true\n-- for all adjacent pairs of elements in the list.\n-- isSortedBy :: (a -> a -> Bool) -> [a] -> Bool\non isSortedBy(cmp, xs)\n    script LE\n        on |λ|(x)\n            x < 1\n        end |λ|\n    end script\n    (length of xs < 2) or all(LE, zipWith(cmp, xs, tail(xs)))\nend isSortedBy",
  "isSpace": "-- isSpace :: Char -> Bool\non isSpace(c)\n    set i to id of c\n    i = 32 or (i ≥ 9 and i ≤ 13)\nend isSpace",
  "isSubsequenceOf": "-- isSubsequenceOf :: Eq a => [a] -> [a] -> Bool\n-- isSubsequenceOf :: String -> String -> Bool\non isSubsequenceOf(xs, ys)\n    script iss\n        on |λ|(a, b)\n            if a ≠ {} then\n                if b ≠ {} then\n                    if item 1 of a = item 1 of b then\n                        |λ|(rest of a, rest of b)\n                    else\n                        |λ|(a, rest of b)\n                    end if\n                else\n                    false\n                end if\n            else\n                true\n            end if\n        end |λ|\n    end script\n    \n    if class of xs = string then\n        tell iss to |λ|(characters of xs, characters of ys)\n    else\n        tell iss to |λ|(xs, ys)\n    end if\nend isSubsequenceOf",
  "isSuffixOf": "-- isSuffixOf :: Eq a => [a] -> [a] -> Bool\n-- isSuffixOf :: String -> String -> Bool \non isSuffixOf(suffix, main)\n    if class of suffix is string then\n        (offset of suffix in main) = 1 + (length of main) - (length of suffix)\n    else\n        set lngSuffix to length of suffix\n        if lngSuffix = 0 then\n            true\n        else\n            set lngMain to length of main\n            set lngDelta to lngMain - lngSuffix\n            if lngDelta < 0 or lngMain = 0 then\n                false\n            else\n                repeat with i from 1 to lngSuffix\n                    if item i of suffix ≠ item (lngDelta + i) of main then return false\n                end repeat\n                true\n            end if\n        end if\n    end if\nend isSuffixOf",
  "isUpper": "-- isUpper :: Char -> Bool\non isUpper(c)\n    set d to (id of c) - 65 -- id of \"A\"\n    d ≥ 0 and d < 26\nend isUpper",
  "iterateUntil": "-- iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]\non iterateUntil(p, f, x)\n    script\n        property mp : mReturn(p)'s |λ|\n        property mf : mReturn(f)'s |λ|\n        property lst : {x}\n        on |λ|(v)\n            repeat until mp(v)\n                set v to mf(v)\n                set end of lst to v\n            end repeat\n            return lst\n        end |λ|\n    end script\n    |λ|(x) of result\nend iterateUntil",
  "jsonLog": "-- jsonLog :: a -> IO ()\non jsonLog(e)\n    log showJSON(e)\nend jsonLog",
  "jsonParseLR": "-- jsonParseLR :: String -> Either String a\non jsonParseLR(s)\n    set ca to current application\n    set {x, e} to ca's NSJSONSerialization's ¬\n        JSONObjectWithData:((ca's NSString's stringWithString:s)'s ¬\n            dataUsingEncoding:(ca's NSUTF8StringEncoding)) ¬\n            options:0 |error|:(reference)\n    \n    if x is missing value then\n        |Left|(e's localizedDescription() as string)\n    else\n        if 1 = (x's isKindOfClass:(ca's NSArray)) as integer then\n            |Right|(x as list)\n        else\n            |Right|(item 1 of (x as list))\n        end if\n    end if\nend jsonParseLR",
  "Just": "-- Just :: a -> Just a\non Just(x)\n    {type: \"Maybe\", Nothing:false, Just:x}\nend Just",
  "justifyLeft": "-- justifyLeft :: Int -> Char -> String -> String\non justifyLeft(n, cFiller, strText)\n    if n > length of strText then\n        text 1 thru n of (strText & replicate(n, cFiller))\n    else\n        strText\n    end if\nend justifyLeft",
  "justifyRight": "-- justifyRight :: Int -> Char -> String -> String\non justifyRight(n, cFiller, strText)\n    if n > length of strText then\n        text -n thru -1 of ((replicate(n, cFiller) as text) & strText)\n    else\n        strText\n    end if\nend justifyRight",
  "keys": "-- keys :: Dict -> [String]\non keys(rec)\n    (current application's NSDictionary's dictionaryWithDictionary:rec)'s allKeys() as list\nend keys",
  "kleisliCompose": "-- Kleisli composition LR\n-- kleisliCompose (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)\non kleisliCompose(f, g)\n    script\n        on |λ|(x)\n            bind(mReturn(f)'s |λ|(x), g)\n        end |λ|\n    end script\nend kleisliCompose",
  "last": "-- last :: [a] -> a\non |last|(xs)\n        item -1 of xs\nend |last|",
  "lastMay": "-- lastMay :: [a] -> Maybe a\non lastMay(xs)\n    if length of xs > 0 then\n        Just(item -1 of xs)\n    else\n        Nothing()\n    end if\nend lastMay",
  "lcm": "-- lcm :: Int -> Int -> Int\non lcm(x, y)\n    if (x = 0 or y = 0) then\n        0\n    else\n        abs(floor(x / (gcd(x, y))) * y)\n    end if\nend lcm",
  "Left": "-- Left :: a -> Either a b\non |Left|(x)\n    {type:\"Either\", |Left|:x, |Right|:missing value}\nend |Left|",
  "lefts": "-- lefts :: [Either a b] -> [a]\non lefts(xs)\n    script\n        on |λ|(x)\n            if class of x is record then\n                set ks to keys(x)\n                ks contains \"type\" and ks contains \"Left\"\n            else\n                false\n            end if\n        end |λ|\n    end script\n    filter(result, xs)\nend lefts",
  "length": "-- length :: [a] -> Int\non |length|(xs)\n    length of xs\nend |length|",
  "levelNodes": "-- levelNodes :: Tree a -> [[Tree a]]\non levelNodes(tree)\n    script p\n        on |λ|(xs)\n            length of xs < 1\n        end |λ|\n    end script\n    \n    script f\n        on |λ|(xs)\n            script nest\n                on |λ|(Node)\n                    nest of Node\n                end |λ|\n            end script\n            concatMap(nest, xs)\n        end |λ|\n    end script\n    \n    iterateUntil(p, f, {tree})\nend levelNodes",
  "levels": "-- levels :: Tree a -> [[a]]\non levels(tree)\n    script nextLayer\n        on |λ|(xs)\n            script\n                on |λ|(x)\n                    nest of x\n                end |λ|\n            end script\n            concatMap(result, xs)\n        end |λ|\n    end script\n    \n    script roots\n        on |λ|(xs)\n            script\n                on |λ|(x)\n                    root of x\n                end |λ|\n            end script\n            map(result, xs)\n        end |λ|\n    end script\n    \n    map(roots, iterateUntil(my isNull, nextLayer, {tree}))\nend levels",
  "liftA2": "-- Lift a binary function to actions.\n-- e.g.\n-- liftA2(mult, {1, 2, 3}, {4, 5, 6}) \n--> {4, 5, 6, 8, 10, 12, 12, 15, 18}\n-- liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\non liftA2(f, a, b)\n    set c to class of a\n    if c is list then\n        liftA2List(f, a, b)\n    else if c is record and keys(a) contains \"type\" then\n        set t to type of a\n        if \"Either\" = t then\n            liftA2LR(f, a, b)\n        else if \"Maybe\" = t then\n            liftA2Maybe(f, a, b)\n        else if \"Tuple\" = t then\n            liftA2Tuple(f, a, b)\n        else if \"Node\" = t then\n            liftA2Tree(f, a, b)\n        else\n            missing value\n        end if\n    else\n        missing value\n    end if\nend liftA2",
  "liftA2List": "-- liftA2List :: (a -> b -> c) -> [a] -> [b] -> [c]\non liftA2List(f, xs, ys)\n    script\n        property g : mReturn(f)'s |λ|\n        on |λ|(x)\n            script\n                on |λ|(y)\n                    {g(x, y)}\n                end |λ|\n            end script\n            concatMap(result, ys)\n        end |λ|\n    end script\n    concatMap(result, xs)\nend liftA2List",
  "liftA2LR": "-- liftA2LR :: (a -> b -> c) -> Either d a -> Either d b -> Either d c\non liftA2LR(f, a, b)\n    set x to |Right| of a\n    set y to |Right| of b\n    if x is missing value then\n        a\n    else if y is missing value then\n        b\n    else\n        |Right|(|λ|(x, y) of mReturn(f))\n    end if\nend liftA2LR",
  "liftA2Maybe": "-- liftA2Maybe :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\non liftA2Maybe(f, a, b)\n    if Nothing of a then\n        a\n    else if Nothing of b then\n        b\n    else\n        Just(|λ|(Just of a, Just of b) of mReturn(f))\n    end if\nend liftA2Maybe",
  "liftA2Tree": "-- liftA2Tree :: Tree (a -> b -> c) -> Tree a -> Tree b -> Tree c\non liftA2Tree(f, tx, ty)\n    \n    script fx\n        on |λ|(y)\n            mReturn(f)'s |λ|(root of tx, y)\n        end |λ|\n    end script\n    \n    script fmapT\n        on |λ|(t)\n            fmapTree(fx, t)\n        end |λ|\n    end script\n    \n    script liftA2T\n        on |λ|(t)\n            liftA2Tree(f, t, ty)\n        end |λ|\n    end script\n    \n    Node(mReturn(f)'s |λ|(root of tx, root of ty), ¬\n        map(fmapT, nest of ty) & map(liftA2T, nest of tx))\nend liftA2Tree",
  "liftA2Tuple": "-- liftA2Tuple :: Monoid m => (a -> b -> c) -> (m, a) -> (m, b) -> (m, c)\non liftA2Tuple(f, a, b)\n    Tuple(mappend(|1| of a, |1| of b), mReturn(f)'s |λ|(|2| of a, |2| of b))\nend liftA2Tuple",
  "liftM2": "--  liftM2 (+) [0,1] [0,2] = [0,2,1,3]\n-- liftM2 :: (a -> b -> c) -> [a] -> [b] -> [c]\non liftM2(f, a, b)\n    liftA2(f, a, b)\nend liftM2",
  "liftMmay": "-- liftMmay :: (a -> b) -> (Maybe a -> Maybe b)\non liftMmay(f)\n    script\n        on |λ|(mb)\n            if Nothing of mb then\n                mb\n            else\n                tell mReturn(f) to |λ|(Just of mb)\n            end if\n        end |λ|\n    end script\nend liftMmay",
  "lines": "-- lines :: String -> [String]\non |lines|(xs)\n    paragraphs of xs\nend |lines|",
  "listDirectory": "-- listDirectory :: FilePath -> [FilePath]\non listDirectory(strPath)\n    set ca to current application\n    unwrap(ca's NSFileManager's defaultManager()'s ¬\n        contentsOfDirectoryAtPath:(unwrap(stringByStandardizingPath of ¬\n            wrap(strPath))) |error|:(missing value))\nend listDirectory",
  "listFromTuple": "-- listFromTuple (a, a ...) -> [a]\non listFromTuple(tpl)\n    script\n        on |λ|(k)\n            Just of lookupDict(k, tpl)\n        end |λ|\n    end script -- All keys except 'type' at end\n    map(result, items 1 thru -2 of sort(keys(tpl)))\nend listFromTuple",
  "listToMaybe": "-- The listToMaybe function returns Nothing on \n-- an empty list or Just the head of the list.\n-- listToMaybe :: [a] -> Maybe a\non listToMaybe(xs)\n    if xs ≠ {} then\n        Just(item 1 of xs)\n    else\n        Nothing()\n    end if\nend listToMaybe",
  "log": "-- log :: Float -> Float\non |log|(n)\n    Just of evalJSMay((\"Math.log(\" & n as string) & \")\")\nend |log|",
  "lookup": "-- use framework \"Foundation\"\n-- use scripting additions\n-- lookup :: Eq a => a -> Container -> Maybe b\non lookup(k, m)\n    set c to class of m\n    if c is list then\n        lookupTuples(k, m)\n    else if c = record then\n        lookupDict(k, m)\n    else\n        Nothing()\n    end if\nend lookup",
  "lookupDict": "-- lookupDict :: a -> Dict -> Maybe b\non lookupDict(k, dct)\n    set ca to current application\n    set v to (ca's NSDictionary's dictionaryWithDictionary:dct)'s objectForKey:k\n    if v ≠ missing value then\n        Just(item 1 of ((ca's NSArray's arrayWithObject:v) as list))\n    else\n        Nothing()\n    end if\nend lookupDict",
  "lookupTuples": "-- lookupTuples :: Eq a => a -> [(a, b)] -> Maybe b\non lookupTuples(k, xs)\n    script keyMatch\n        on |λ|(x)\n            k = fst(x)\n        end |λ|\n    end script\n    \n    script harvestMay\n        on |λ|(kv)\n            Just(snd(kv))\n        end |λ|\n    end script\n    \n    bindMay(find(keyMatch, xs), harvestMay)\nend lookupTuples",
  "LT": "-- LT :: Ordering\nproperty |LT| : {type:\"Ordering\", value:-1}",
  "map": "-- map :: (a -> b) -> [a] -> [b]\non map(f, xs)\n    tell mReturn(f)\n        set lng to length of xs\n        set lst to {}\n        repeat with i from 1 to lng\n            set end of lst to |λ|(item i of xs, i, xs)\n        end repeat\n        return lst\n    end tell\nend map",
  "mapAccumL": "-- 'The mapAccumL function behaves like a combination of map and foldl; \n-- it applies a function to each element of a list, passing an \n-- accumulating parameter from |Left| to |Right|, and returning a final \n-- value of this accumulator together with the new list.' (see Hoogle)\n-- mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\non mapAccumL(f, acc, xs)\n    script\n        on |λ|(a, x, i)\n            tell mReturn(f) to set pair to |λ|(|1| of a, x, i)\n            Tuple(|1| of pair, (|2| of a) & {|2| of pair})\n        end |λ|\n    end script\n    \n    foldl(result, Tuple(acc, []), xs)\nend mapAccumL",
  "mapAccumL_Tree": "-- mapAccumL_Tree :: (acc -> x -> (acc, y)) -> acc -> Tree -> (acc, Tree)\non mapAccumL_Tree(f, acc, tree)\n    script go\n        property mf : mReturn(f)'s |λ|\n        on |λ|(a, x)\n            set pair to f(a, root of x)\n            set tpl to mapAccumL(go, item 1 of pair, nest of x)\n            Tuple(item 1 of tpl, Node(item 2 of pair, item 2 of tpl))\n        end |λ|\n    end script\n    |λ|(acc, tree) of go\nend mapAccumL_Tree",
  "mapAccumR": "-- 'The mapAccumR function behaves like a combination of map and foldr; \n--  it applies a function to each element of a list, passing an accumulating \n--  parameter from |Right| to |Left|, and returning a final value of this \n--  accumulator together with the new list.' (see Hoogle)\n-- mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\non mapAccumR(f, acc, xs)\n    script\n        on |λ|(x, a, i)\n            tell mReturn(f) to set pair to |λ|(|1| of a, x, i)\n            Tuple(|1| of pair, (|2| of pair) & |2| of a)\n        end |λ|\n    end script\n    foldr(result, Tuple(acc, []), xs)\nend mapAccumR",
  "mapFromList": "-- mapFromList :: [(k, v)] -> Dict\non mapFromList(kvs)\n    set tpl to unzip(kvs)\n    script\n        on |λ|(x)\n            x as string\n        end |λ|\n    end script\n    (current application's NSDictionary's ¬\n        dictionaryWithObjects:(|2| of tpl) ¬\n            forKeys:map(result, |1| of tpl)) as record\nend mapFromList",
  "mapKeys": "-- mapKeys :: (Key -> Key) -> IntMap a -> IntMap a\non mapKeys(f, dct)\n    script\n        property g : mReturn(f)\n        on |λ|(kv)\n            set {k, v} to kv\n            {g's |λ|(k), v}\n        end |λ|\n    end script\n    map(result, zip(keys(dct), elems(dct)))\nend mapKeys",
  "mapMaybe": "-- The mapMaybe function is a version of map which can throw out\n-- elements. In particular, the functional argument returns\n-- something of type Maybe b. If this is Nothing, no element is\n-- added on to the result list. If it just Just b, then b is\n-- included in the result list.\n-- mapMaybe :: (a -> Maybe b) -> [a] -> [b]\non mapMaybe(mf, xs)\n    concatMap(compose(mf, my maybeToList), xs)\nend mapMaybe",
  "mappend": "-- mappend (<>) :: Monoid a => a -> a -> a\non mappend(a, b)\n    if class of a is record and class of b is record then\n        script instanceMay\n            on |λ|(strType)\n                set mb to lookup(strType, ¬\n                    {Maybe:mappendMaybe, Ordering:mappendOrdering, Tuple:mappendTuple})\n            end |λ|\n        end script\n        set mbi to bindMay(lookup(\"type\", a), instanceMay)\n        if Nothing of mbi then\n            a & b\n        else\n            mReturn(Just of mbi)'s |λ|(a, b)\n        end if\n    else\n        a & b\n    end if\nend mappend",
  "mappendComparing": "-- mappendComparing :: [(a -> b)] -> (a -> a -> Ordering)\non mappendComparing(fs)\n    script\n        on |λ|(x, y)\n            script\n                on |λ|(ordr, f)\n                    if ordr ≠ 0 then\n                        ordr\n                    else\n                        tell mReturn(f)\n                            compare(|λ|(x), |λ|(y))\n                        end tell\n                    end if\n                end |λ|\n            end script\n            foldl(result, 0, fs)\n        end |λ|\n    end script\nend mappendComparing",
  "mappendComparing2": "-- mappendComparing2 :: [((a -> b), Bool)] -> (a -> a -> Ordering)\non mappendComparing2(fBools)\n    script\n        on |λ|(x, y)\n            script\n                on |λ|(ord, fb)\n                    if ord ≠ |EQ| then\n                        ord\n                    else\n                        set f to |1| of fb\n                        tell mReturn(f)\n                            if |2| of fb then\n                                compare(|λ|(x), |λ|(y))\n                            else\n                                compare(|λ|(y), |λ|(x))\n                            end if\n                        end tell\n                    end if\n                end |λ|\n            end script\n            foldl(result, 0, fBools)\n        end |λ|\n    end script\nend mappendComparing",
  "mappendMaybe": "-- mappendMaybe (<>) :: Maybe a -> Maybe a -> Maybe a\non mappendMaybe(a, b)\n    if Nothing of a then\n        b\n    else if Nothing of b then\n        a\n    else\n        Just(mappend(Just of a, Just of b))\n    end if\nend mappendMaybe",
  "mappendOrdering": "-- Ordering :: ( LT | EQ | GT ) | ( -1 | 0 | 1 )\n-- mappendOrdering (<>) :: Ordering -> Ordering -> Ordering\non mappendOrdering(a, b)\n    if my |EQ| = a then\n        b\n    else\n        a\n    end if\nend mappendOrdering",
  "mappendTuple": "-- mappendTuple (<>) :: (a, b) -> (a, b) -> (a, b)\non mappendTuple(a, b)\n    Tuple(mappend(|1| of a, |1| of b), mappend(|2| of a, |2| of b))\nend mappendTuple",
  "max": "-- max :: Ord a => a -> a -> a\non max(x, y)\n    if x > y then\n        x\n    else\n        y\n    end if\nend max",
  "maximum": "-- maximum :: Ord a => [a] -> a\non maximum(xs)\n    script\n        on |λ|(a, b)\n            if a is missing value or b > a then\n                b\n            else\n                a\n            end if\n        end |λ|\n    end script\n    \n    foldl(result, missing value, xs)\nend maximum",
  "maximumBy": "-- maximumBy :: (a -> a -> Ordering) -> [a] -> a\non maximumBy(f, xs)\n    set cmp to mReturn(f)\n    script max\n        on |λ|(a, b)\n            if a is missing value or cmp's |λ|(a, b) < 0 then\n                b\n            else\n                a\n            end if\n        end |λ|\n    end script\n    \n    foldl(max, missing value, xs)\nend maximumBy",
  "maximumByMay": "-- maximumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\non maximumByMay(f, xs)\n    set cmp to mReturn(f)\n    script max\n        on |λ|(a, b)\n            if a is missing value or cmp's |λ|(a, b) < 0 then\n                b\n            else\n                a\n            end if\n        end |λ|\n    end script\n    \n    foldl1May(max, xs)\nend maximumByMay",
  "maximumMay": "-- maximumMay :: Ord a => [a] -> Maybe a\non maximumMay(xs)\n    foldl1May(max, xs)\nend maximumMay",
  "maybe": "-- | The 'maybe' function takes a default value, a function, and a 'Maybe'\n-- value.  If the 'Maybe' value is 'Nothing', the function returns the\n-- default value.  Otherwise, it applies the function to the value inside\n-- the 'Just' and returns the result.\n-- maybe :: b -> (a -> b) -> Maybe a -> b\non maybe(n, f, mb)\n    if Nothing of mb then\n        n\n    else\n        tell mReturn(f) to |λ|(Just of mb)\n    end if\nend maybe",
  "maybeToList": "-- The maybeToList function returns an empty list when given\n-- Nothing or a singleton list when not given Nothing.\n-- maybeToList :: Maybe a -> [a]\non maybeToList(mb)\n    if Nothing of mb then\n        {}\n    else\n        {Just of mb}\n    end if\nend maybeToList",
  "mean": "-- mean :: [Num] -> Num\non mean(xs)\n    script\n        on |λ|(a, x)\n            a + x\n        end |λ|\n    end script\n    foldl(result, 0, xs) / (length of xs)\nend mean",
  "member": "-- member :: Key -> Dict -> Bool\non member(k, dct)\n    ((current application's ¬\n        NSDictionary's dictionaryWithDictionary:dct)'s ¬\n        objectForKey:k) is not missing value\nend member",
  "min": "-- min :: Ord a => a -> a -> a\non min(x, y)\n    if y < x then\n        y\n    else\n        x\n    end if\nend min",
  "minimum": "-- minimum :: Ord a => [a] -> a\non minimum(xs)\n    set lng to length of xs\n    if lng < 1 then return missing value\n    set m to item 1 of xs\n    repeat with x in xs\n        set v to contents of x\n        if v < m then set m to v\n    end repeat\n    return m\nend minimum",
  "minimumBy": "-- minimumBy :: (a -> a -> Ordering) -> [a] -> a\non minimumBy(f, xs)\n    set lng to length of xs\n    if lng < 1 then\n        missing value\n    else if lng > 1 then\n        tell mReturn(f)\n            set v to item 1 of xs\n            repeat with x in xs\n                if |λ|(x, v) < 0 then set v to contents of x\n            end repeat\n            return v\n        end tell\n    else\n        item 1 of xs\n    end if\nend minimumBy",
  "minimumByMay": "-- minimumByMay :: (a -> a -> Ordering) -> [a] -> Maybe a\non minimumByMay(f, xs)\n    set lng to length of xs\n    if lng < 1 then\n        Nothing()\n    else if lng > 1 then\n        tell mReturn(f)\n            set v to item 1 of xs\n            repeat with x in xs\n                if |λ|(x, v) < 0 then set v to contents of x\n            end repeat\n            return Just(v)\n        end tell\n    else\n        Just(item 1 of xs)\n    end if\nend minimumByMay",
  "minimumMay": "-- minimumMay :: [a] -> Maybe a\non minimumMay(xs)\n    set lng to length of xs\n    if lng < 1 then\n        Nothing()\n    else if lng > 1 then\n        set m to item 1 of xs\n        repeat with x in xs\n            set v to contents of x\n            if v < m then set m to v\n        end repeat\n        Just(m)\n    else\n        Just(item 1 of xs)\n    end if\nend minimumMay",
  "mod": "-- Composable wrapper for built-in operator\n-- mod :: Int -> Int -> Int\non |mod|(n, d)\n    n mod d\nend |mod|",
  "modificationTime": "-- modificationTime :: FilePath -> Either String Date\non modificationTime(fp)\n    script fs\n        on |λ|(rec)\n            |Right|(NSFileModificationDate of rec)\n        end |λ|\n    end script\n    bindLR(my fileStatus(fp), fs)\nend modificationTime",
  "mReturn": "-- Lift 2nd class handler function into 1st class script wrapper \n-- mReturn :: First-class m => (a -> b) -> m (a -> b)\non mReturn(f)\n    if class of f is script then\n        f\n    else\n        script\n            property |λ| : f\n        end script\n    end if\nend mReturn",
  "negate": "-- negate :: Num -> Num\non |negate|(n)\n    -n\nend |negate|",
  "newUUID": "-- use framework \"Foundation\"\n-- use scripting additions\n-- newUUID :: () -> IO UUID String\non newUUID()\n    current application's NSUUID's UUID's UUIDString as string\nend newUUID",
  "Node": "-- Node :: a -> [Tree a] -> Tree a\non Node(v, xs)\n    {type:\"Node\", root:v, nest:xs}\nend Node",
  "not": "-- not :: Bool -> Bool\non |not|(p)\n    not p\nend |not|",
  "notElem": "-- notElem :: Eq a => a -> [a] -> Bool\non notElem(x, xs)\n    xs does not contain x\nend notElem",
  "Nothing": "-- Nothing :: () -> Nothing\non Nothing()\n    {type:\"Maybe\", Nothing:true}\nend Nothing",
  "nub": "-- nub :: [a] -> [a]\non nub(xs)\n    script\n        on |λ|(a, b)\n            a = b\n        end |λ|\n    end script\n    nubBy(result, xs)\nend nub",
  "nubBy": "-- nubBy :: (a -> a -> Bool) -> [a] -> [a]\non nubBy(f, xs)\n    set g to mReturn(f)'s |λ|\n    \n    script notEq\n        property fEq : g\n        on |λ|(a)\n            script\n                on |λ|(b)\n                    not fEq(a, b)\n                end |λ|\n            end script\n        end |λ|\n    end script\n    \n    script go\n        on |λ|(xs)\n            if (length of xs) > 1 then\n                set x to item 1 of xs\n                {x} & go's |λ|(filter(notEq's |λ|(x), items 2 thru -1 of xs))\n            else\n                xs\n            end if\n        end |λ|\n    end script\n    \n    go's |λ|(xs)\nend nubBy",
  "odd": "-- odd :: Int -> Bool\non odd(x)\n    not even(x)\nend odd",
  "on": "-- e.g. sortBy(|on|(compare, |length|), [\"epsilon\", \"mu\", \"gamma\", \"beta\"])\n-- on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\non |on|(f, g)\n    script\n        on |λ|(a, b)\n            tell mReturn(g) to set {va, vb} to {|λ|(a), |λ|(b)}\n            tell mReturn(f) to |λ|(va, vb)\n        end |λ|\n    end script\nend |on|",
  "or": "-- or :: [Bool] -> Bool\non |or|(ps)\n    repeat with p in ps\n        if p then return true\n    end repeat\n    return false\nend |or|",
  "ord": "-- ord :: Char -> Int\non ord(c)\n    id of c\nend ord",
  "Ordering": "-- Ordering :: Int -> Ordering\non Ordering(e)\n    if e > 0 then\n        set v to 1\n    else if e < 0 then\n        set v to -1\n    else\n        set v to 0\n    end if\n    {type:\"Ordering\", value:v}\nend Ordering",
  "outdented": "-- All lines in the string outdented by the same amount\n-- (just enough to ensure that the least indented lines \n--  have no remaining indent)\n-- All relative indents are left unchanged\n-- outdented :: String -> String\non outdented(s)\n    set xs to |lines|(s)\n    script dent\n        on |λ|(x)\n            script isSpace\n                on |λ|(c)\n                    id of c = 32\n                end |λ|\n            end script\n            length of takeWhile(isSpace, x)\n        end |λ|\n    end script\n    set n to |λ|(minimumBy(comparing(dent), xs)) of dent\n    if n < 1 then\n        s\n    else\n        unlines(map(|λ|(n) of curry(drop), xs))\n    end if\nend outdented",
  "partition": "-- partition :: predicate -> List -> (Matches, nonMatches)\n-- partition :: (a -> Bool) -> [a] -> ([a], [a])\non partition(f, xs)\n    tell mReturn(f)\n        set ys to {}\n        set zs to {}\n        repeat with x in xs\n            set v to contents of x\n            if |λ|(v) then\n                set end of ys to v\n            else\n                set end of zs to v\n            end if\n        end repeat\n    end tell\n    Tuple(ys, zs)\nend partition",
  "partitionEithers": "-- partitionEithers :: [Either a b] -> ([a], [b])\non partitionEithers(xs)\n    set ys to {}\n    set zs to {}\n    repeat with x in xs\n        if isRight(x) then\n            set end of zs to x\n        else\n            set end of ys to x\n        end if\n    end repeat\n    Tuple(ys, zs)\nend partitionEithers",
  "permutations": "-- permutations :: [a] -> [[a]]\non permutations(xs)\n    script firstElement\n        on |λ|(x)\n            script tailElements\n                on |λ|(ys)\n                    {{x} & ys}\n                end |λ|\n            end script\n            \n            concatMap(tailElements, permutations(|delete|(x, xs)))\n        end |λ|\n    end script\n    \n    if length of xs > 0 then\n        concatMap(firstElement, xs)\n    else\n        {{}}\n    end if\nend permutations",
  "permutationsWithRepetition": "-- permutationsWithRepetition :: Int -> [a] -> [[a]]\non permutationsWithRepetition(n, xs)\n    if length of xs > 0 then\n        foldl1(curry(my cartesianProduct)'s |λ|(xs), replicate(n, xs))\n    else\n        {}\n    end if\nend permutationsWithRepetition",
  "pi": "-- pi :: Float\npi",
  "plus": "-- plus :: Num -> Num -> Num\non plus(a, b)\n    a + b\nend plus",
  "postorder": "-- Root elements of tree flattened bottom-up\n-- into a postorder list.\n-- postorder :: Tree a -> [a]\non postorder(node)\n    script go\n        on |λ|(xs, x)\n            foldl(go, xs, nest of x) & {root of x}\n        end |λ|\n    end script\n    go's |λ|({}, node)\nend postorder",
  "pred": "-- pred :: Enum a => a -> a\non pred(x)\n    if isChar(x) then\n        chr(ord(x) - 1)\n    else\n        (-1) + x\n    end if\nend pred",
  "product": "-- product :: [Num] -> Num\non product(xs)\n    script multiply\n        on |λ|(a, b)\n            a * b\n        end |λ|\n    end script\n    \n    foldl(multiply, 1, xs)\nend product",
  "properFraction": "-- properFraction :: Real -> (Int, Real)\non properFraction(n)\n    set i to (n div 1)\n    Tuple(i, n - i)\nend properFraction",
  "pureList": "-- pureList :: a -> [a]\non pureList(x)\n        {x}\nend pure",
  "pureLR": "-- pureLR :: a -> Either e a\non pureLR(x)\n    |Right|(x)\nend pureLR",
  "pureMay": "-- pureMay :: a -> Maybe a\non pureMay(x)\n    Just(x)\nend pureMay",
  "pureT": "-- Given a type name string, returns a \n-- specialised 'pure', where\n-- 'pure' lifts a value into a particular functor.\n-- pureT :: String -> f a -> (a -> f a)\non pureT(t, x)\n    if \"List\" = t then\n        pureList(x)\n    else if \"Either\" = t then\n        pureLR(x)\n    else if \"Maybe\" = t then\n        pureMay(x)\n    else if \"Tree\" = t then\n        pureTree(x)\n    else if \"Tuple\" = t then\n        pureTuple(x)\n    else\n        pureList(x)\n    end i",
  "pureTree": "-- pureTree :: a -> Tree a\non pureTree(x)\n    Node(x, [])\nend pureTree",
  "pureTuple": "-- pureTuple :: a -> (a, a)\non pureTuple(x)\n    Tuple(\"\", x)\nend pureTuple",
  "quickSort": "-- Adequate for small sorts, but sort :: Ord a => [a] -> [a], (which uses the ObjC\n-- sortedArrayUsingSelector) is the one to use\n-- quickSort :: (Ord a) => [a] -> [a]\non quickSort(xs)\n    if length of xs > 1 then\n        set h to item 1 of xs\n        script\n            on |λ|(x)\n                x ≤ h\n            end |λ|\n        end script\n        set {less, more} to partition(result, rest of xs)\n        quickSort(less) & h & quickSort(more)\n    else\n        xs\n    end if\nend quickSort",
  "quickSortBy": "-- quickSortBy(comparing(my |length|), {\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\", \"iota\", \"kappa\", \"lambda\", \"mu\"})\n-- quickSortBy :: (a -> a -> Ordering) -> [a] -> [a]\non quickSortBy(cmp, xs)\n    if length of xs > 1 then\n        set h to item 1 of xs\n        script\n            on |λ|(x)\n                cmp's |λ|(x, h) ≠ 1\n            end |λ|\n        end script\n        set {less, more} to partition(result, rest of xs)\n        quickSortBy(cmp, less) & h & quickSortBy(cmp, more)\n    else\n        xs\n    end if\nend quickSortBy",
  "quot": "-- quot :: Int -> Int -> Int\non quot(m, n)\n    m div n\nend quot",
  "quotRem": "-- quotRem :: Int -> Int -> (Int, Int)\non quotRem(m, n)\n    Tuple(m div n, m mod n)\nend quotRem",
  "raise": "-- raise :: Num -> Int -> Num\non raise(m, n)\n    m ^ n\nend raise",
  "randomRInt": "-- randomRInt :: Int -> Int -> Int\non randomRInt(low, high)\n    floor(low + ((random number) * (1 + (high - low))))\nend randomRInt",
  "range": "-- range :: Ix a => (a, a) -> [a]\non range(ab)\n    set {a, b} to {|1| of ab, |2| of ab}\n    if class of a is list then\n        set {xs, ys} to {a, b}\n    else\n        set {xs, ys} to {{a}, {b}}\n    end if\n    set lng to length of xs\n    \n    if lng = length of ys then\n        if lng > 1 then\n            script\n                on |λ|(_, i)\n                    enumFromTo(item i of xs, item i of ys)\n                end |λ|\n            end script\n            sequence(map(result, xs))\n        else\n            enumFromTo(a, b)\n        end if\n    else\n        {}\n    end if\nend range",
  "Ratio": "-- Ratio :: Int -> Int -> Ratio\non Ratio(n, d)\n    {type:\"Ratio\", n:n, d:d}\nend Ratio",
  "read": "-- read :: Read a => String -> a\non read (s)\n    run script s\nend read",
  "readFile": "-- readFile :: FilePath -> IO String\non readFile(strPath)\n    set ca to current application\n    set e to reference\n    set {s, e} to (ca's NSString's ¬\n        stringWithContentsOfFile:((ca's NSString's ¬\n            stringWithString:strPath)'s ¬\n            stringByStandardizingPath) ¬\n            encoding:(ca's NSUTF8StringEncoding) |error|:(e))\n    if e is missing value then\n        s as string\n    else\n        (localizedDescription of e) as string\n    end if\nend readFile",
  "readFileLR": "-- readFileLR :: FilePath -> Either String String\non readFileLR(strPath)\n    set ca to current application\n    set e to reference\n    set {s, e} to (ca's NSString's ¬\n        stringWithContentsOfFile:((ca's NSString's ¬\n            stringWithString:strPath)'s ¬\n            stringByStandardizingPath) ¬\n            encoding:(ca's NSUTF8StringEncoding) |error|:(e))\n    if e is missing value then\n        |Right|(s as string)\n    else\n        |Left|(message of e)\n    end if\nend readFileLR",
  "readJSON": "-- readJSON :: String -> a\non readJSON(strJSON)\n    set ca to current application\n    set {x, e} to ca's NSJSONSerialization's ¬\n        JSONObjectWithData:((ca's NSString's stringWithString:strJSON)'s ¬\n            dataUsingEncoding:(ca's NSUTF8StringEncoding)) ¬\n            options:0 |error|:(reference)\n    \n    if x is missing value then\n        error e's localizedDescription() as text\n    else\n        if x's isKindOfClass:(ca's NSDictionary) then\n            x as record\n        else\n            x as list\n        end if\n    end if\nend readJSON",
  "readJSONLR": "-- readJSONLR :: Read a => String -> Either String a\non readJSONLR(strJSON)\n    set ca to current application\n    set {x, e} to ca's NSJSONSerialization's ¬\n        JSONObjectWithData:((ca's NSString's stringWithString:strJSON)'s ¬\n            dataUsingEncoding:(ca's NSUTF8StringEncoding)) ¬\n            options:0 |error|:(reference)\n    \n    if x is missing value then\n        |Left|(e's localizedDescription() as text)\n    else\n        if x's isKindOfClass:(ca's NSDictionary) then\n            |Right|(x as record)\n        else\n            |Right|(x as list)\n        end if\n    end if\nend readJSONLR",
  "readMay": "-- readMay :: Read a => String -> Maybe a\non readMay(s)\n    try\n      Just(run script s)\n    on error e\n        Nothing()\n    end try\nend readMay",
  "recip": "-- recip :: Num -> Num\non recip(n)\n    if n ≠ 0 then\n        1 / n\n    else\n        missing value\n    end if\nend recip",
  "recipMay": "-- recipMay :: Num -> Maybe Num\non recipMay(n)\n    if n ≠ 0 then\n        Just(1 / n)\n    else\n        Nothing()\n    end if\nend recipMay",
  "regexMatches": "-- regexMatches :: String -> String -> [[String]]\non regexMatches(strRegex, strHay)\n    set ca to current application\n    -- NSNotFound handling and and High Sierra workaround due to @sl1974\n    set NSNotFound to a reference to 9.22337203685477E+18 + 5807\n    set oRgx to ca's NSRegularExpression's regularExpressionWithPattern:strRegex ¬\n        options:((ca's NSRegularExpressionAnchorsMatchLines as integer)) ¬\n        |error|:(missing value)\n    set oString to ca's NSString's stringWithString:strHay\n    \n    script matchString\n        on |λ|(m)\n            script rangeMatched\n                on |λ|(i)\n                    tell (m's rangeAtIndex:i)\n                        set intFrom to its location\n                        if NSNotFound ≠ intFrom then\n                            text (intFrom + 1) thru (intFrom + (its |length|)) of strHay\n                        else\n                            missing value\n                        end if\n                    end tell\n                end |λ|\n            end script\n            map(rangeMatched, ¬\n                enumFromToInt(0, ((numberOfRanges of m) as integer) - 1))\n        end |λ|\n    end script\n    \n    map(matchString, (oRgx's matchesInString:oString ¬\n        options:0 range:{location:0, |length|:oString's |length|()}) as list)\nend regexMatches",
  "rem": "-- rem :: Int -> Int -> Int\non rem(m, n)\n    m mod n\nend rem",
  "removeFile": "-- removeFile :: FilePath -> Either String String\non removeFile(fp)\n    set e to reference\n    set {bln, obj} to current application's NSFileManager's ¬\n        defaultManager's removeItemAtPath:(fp) |error|:(e)\n    if bln then\n        |Right|(\"Removed: \" & fp)\n    else\n        |Left|(obj's localizedDescription as string)\n    end if\nend removeFile",
  "replace": "-- replace :: String -> String -> String -> String\non replace(strNeedle, strNew, strHayStack)\n    set {dlm, my text item delimiters} to {my text item delimiters, strNeedle}\n    set xs to text items of strHayStack\n    set my text item delimiters to strNew\n    set strReplaced to xs as text\n    set my text item delimiters to dlm\n    return strReplaced\nend replace",
  "replicate": "-- Egyptian multiplication - progressively doubling a list, appending\n-- stages of doubling to an accumulator where needed for binary \n-- assembly of a target length\n-- replicate :: Int -> a -> [a]\non replicate(n, a)\n    set out to {}\n    if n < 1 then return out\n    set dbl to {a}\n    \n    repeat while (n > 1)\n        if (n mod 2) > 0 then set out to out & dbl\n        set n to (n div 2)\n        set dbl to (dbl & dbl)\n    end repeat\n    return out & dbl\nend replicate",
  "replicateM": "-- Instance for lists only here\n\n-- e.g. replicateM(3, {1, 2})) -> \n-- {{1, 1, 1}, {1, 1, 2}, {1, 2, 1}, {1, 2, 2}, {2, 1, 1}, \n--  {2, 1, 2}, {2, 2, 1}, {2, 2, 2}}\n-- replicateM :: Int -> [a] -> [[a]]\non replicateM(n, xs)\n    script go\n        script cons\n            on |λ|(a, bs)\n                {a} & bs\n            end |λ|\n        end script\n        on |λ|(x)\n            if x ≤ 0 then\n                {{}}\n            else\n                liftA2List(cons, xs, |λ|(x - 1))\n            end if\n        end |λ|\n    end script\n    \n    tell go to |λ|(n)\nend replicateM",
  "replicateString": "-- replicateString :: Int -> String -> String\non replicateString(n, s)\n    set out to \"\"\n    if n < 1 then return out\n    set dbl to s\n \n    repeat while (n > 1)\n        if (n mod 2) > 0 then set out to out & dbl\n        set n to (n div 2)\n        set dbl to (dbl & dbl)\n    end repeat\n    return out & dbl\nend replicateS",
  "reverse": "-- reverse :: [a] -> [a]\non |reverse|(xs)\n    if class of xs is text then\n        (reverse of characters of xs) as text\n    else\n        reverse of xs\n    end if\nend |reverse|",
  "Right": "-- Right :: b -> Either a b\non |Right|(x)\n    {type:\"Either\", |Left|:missing value, |Right|:x}\nend |Right|",
  "rights": "-- rights :: [Either a b] -> [b]\non rights(xs)\n    script\n        on |λ|(x)\n            if class of x is record then\n                set ks to keys(x)\n                ks contains \"type\" and ks contains \"Right\"\n            else\n                false\n            end if\n        end |λ|\n    end script\n    filter(result, xs)\nend rights",
  "rotate": "-- rotate :: Int -> [a] -> [a]\non rotate(n, xs)\n    set lng to length of xs\n    if lng > 0 then\n        takeDropCycle(lng, n, xs)\n    else\n        {}\n    end if\nend rotate",
  "round": "-- round :: a -> Int\non |round|(n)\n    round n\nend |round|",
  "safeMay": "-- safeMay :: (a -> Bool) -> (a -> b) -> Maybe b\non safeMay(p, f, x)\n    if p(x) then\n        Just(f(x))\n    else\n        Nothing()\n    end if\nend safeMay",
  "scanl": "-- scanl :: (b -> a -> b) -> b -> [a] -> [b]\non scanl(f, startValue, xs)\n    tell mReturn(f)\n        set v to startValue\n        set lng to length of xs\n        set lst to {startValue}\n        repeat with i from 1 to lng\n            set v to |λ|(v, item i of xs, i, xs)\n            set end of lst to v\n        end repeat\n        return lst\n    end tell\nend scanl",
  "scanl1": "-- scanl1 :: (a -> a -> a) -> [a] -> [a]\non scanl1(f, xs)\n    if length of xs > 0 then\n        scanl(f, item 1 of xs, tail(xs))\n    else\n        {}\n    end if\nend scanl",
  "scanr": "-- scanr :: (b -> a -> b) -> b -> [a] -> [b]\non scanr(f, startValue, xs)\n    tell mReturn(f)\n        set v to startValue\n        set lng to length of xs\n        set lst to {startValue}\n        repeat with i from lng to 1 by -1\n            set v to |λ|(v, item i of xs, i, xs)\n            set end of lst to v\n        end repeat\n        return reverse of lst\n    end tell\nend scanr",
  "scanr1": "-- scanr1 :: (a -> a -> a) -> [a] -> [a]\non scanr1(f, xs)\n    if length of xs > 0 then\n        scanr(f, item -1 of xs, init(xs))\n    else\n        {}\n    end if\nend scanr1",
  "secondArrow": "-- Lift a simple function to one which applies to a tuple, \n-- transforming only the second item of the tuple\n-- secondArrow :: (a -> b) -> ((c, a) -> (c, b))\non secondArrow(f)\n    script\n        on |λ|(xy)\n            Tuple(|1| of xy, mReturn(f)'s |λ|(|2| of xy))\n        end |λ|\n    end script\nend |second|",
  "sequenceAList": "-- sequenceAList :: Applicative f => [f a] -> f [a]\non sequenceAList(us)\n    script |id|\n        on |λ|(x)\n            x\n        end |λ|\n    end script\n    traverseList(|id|, us)\nend sequenceAList",
  "setCurrentDirectory": "-- setCurrentDirectory :: String -> IO ()\non setCurrentDirectory(strPath)\n    if doesDirectoryExist(strPath) then\n        set ca to current application\n        set oPath to (ca's NSString's stringWithString:strPath)'s ¬\n            stringByStandardizingPath\n        ca's NSFileManager's defaultManager()'s ¬\n            changeCurrentDirectoryPath:oPath\n    end if\nend setCurrentDirectory",
  "show": "-- show :: a -> String\non show(e)\n    set c to class of e\n    if c = list then\n        showList(e)\n    else if c = record then\n        set mb to lookupDict(\"type\", e)\n        if Nothing of mb then\n            showDict(e)\n        else\n            script\n                on |λ|(t)\n                    if \"Either\" = t then\n                        set f to my showLR\n                    else if \"Maybe\" = t then\n                        set f to my showMaybe\n                    else if \"Ordering\" = t then\n                        set f to my showOrdering\n                    else if \"Ratio\" = t then\n                        set f to my showRatio\n                    else if \"Tuple\" = t then\n                        set f to my showTuple\n                    else if \"Tuple3\" = t then\n                        set f to my showTuple3\n                    else if \"Tuple4\" = t then\n                        set f to my showTuple4\n                    else\n                        set f to my showDict\n                    end if\n                    tell mReturn(f) to |λ|(e)\n                end |λ|\n            end script\n            tell result to |λ|(Just of mb)\n        end if\n    else if c = date then\n        \"\\\"\" & showDate(e) & \"\\\"\"\n    else if c = text then\n        \"'\" & e & \"'\"\n    else if (c = integer or c = real) then\n        e as text\n    else if c = class then\n        \"null\"\n    else\n        try\n            e as text\n        on error\n            (\"«\" & c as text) & \"»\"\n        end try\n    end if\nend show",
  "showBinary": "-- showBinary :: Int -> String\non showBinary(n)\n    script binaryChar\n        on |λ|(n)\n            text item (n + 1) of \"01\"\n        end |λ|\n    end script\n    showIntAtBase(2, binaryChar, n, \"\")\nend showBin",
  "showDate": "-- ISO 8601 UTC \n-- showDate :: Date -> String\non showDate(dte)\n    ((dte - (time to GMT)) as «class isot» as string) & \".000Z\"\nend showDate",
  "showDict": "-- showDict :: Dict -> String\non showDict(dct)\n  showJSON(dct)\nend showDict",
  "showHex": "-- showHex :: Int -> String\non showHex(n)\n    showIntAtBase(16, mReturn(intToDigit), n, \"\")\nend showHex",
  "showIntAtBase": "-- showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\non showIntAtBase(base, toChr, n, rs)\n    script showIt\n        on |λ|(nd_, r)\n            set {n, d} to nd_\n            set r_ to toChr's |λ|(d) & r\n            if n > 0 then\n                |λ|(quotRem(n, base), r_)\n            else\n                r_\n            end if\n        end |λ|\n    end script\n    \n    if base ≤ 1 then\n        \"error: showIntAtBase applied to unsupported base\"\n    else if n < 0 then\n        \"error: showIntAtBase applied to negative number\"\n    else\n        showIt's |λ|(quotRem(n, base), rs)\n    end if\nend showIntAtBase",
  "showJSON": "-- showJSON :: a -> String\non showJSON(x)\n    set c to class of x\n    if (c is list) or (c is record) then\n        set ca to current application\n        set {json, e} to ca's NSJSONSerialization's dataWithJSONObject:x options:1 |error|:(reference)\n        if json is missing value then\n            e's localizedDescription() as text\n        else\n            (ca's NSString's alloc()'s initWithData:json encoding:(ca's NSUTF8StringEncoding)) as text\n        end if\n    else if c is date then\n        \"\\\"\" & ((x - (time to GMT)) as «class isot» as string) & \".000Z\" & \"\\\"\"\n    else if c is text then\n        \"\\\"\" & x & \"\\\"\"\n    else if (c is integer or c is real) then\n        x as text\n    else if c is class then\n        \"null\"\n    else\n        try\n            x as text\n        on error\n            (\"«\" & c as text) & \"»\"\n        end try\n    end if\nend showJSON",
  "showList": "-- showList :: [a] -> String\non showList(xs)\n  showJSON(xs)\nend showList",
  "showLog": "-- showLog :: a -> IO ()\non showLog(e)\n    log show(e)\nend showLog",
  "showLR": "-- showLR :: Either a b -> String\non showLR(lr)\n    if isRight(lr) then\n        \"Right(\" & unQuoted(show(|Right| of lr)) & \")\"\n    else\n        \"Left(\" & unQuoted(show(|Left| of lr)) & \")\"\n    end if\nend showLR",
  "showMaybe": "-- showMaybe :: Maybe a -> String\non showMaybe(mb)\n    if Nothing of mb then\n        \"Nothing\"\n    else\n        \"Just \" & unQuoted(show(Just of mb))\n    end if\nend showMaybe",
  "showOrdering": "-- showOrdering :: Ordering -> String\non showOrdering(e)\n    set v to value of e\n    if v > 0 then\n        \"GT\"\n    else if v < 0 then\n        \"LT\"\n    else\n        \"EQ\"\n    end if\nend showOrdering",
  "showRatio": "-- showRatio :: Ratio -> String\non showRatio(r)\n    (n of r as string) & \"/\" & (d of r as string)\nend showRatio",
  "showTuple": "-- showTuple :: Tuple -> String\non showTuple(tpl)\n    \"(\" & unQuoted(show(|1| of tpl)) & \", \" & unQuoted(show(|2| of tpl)) & \")\"\nend showTuple",
  "showTuple3": "-- showTuple3 :: Tuple3 -> String\non showTuple3(tpl)\n    \"(\" & unQuoted(show(|1| of tpl)) & \", \" & ¬\n        unQuoted(show(|2| of tpl)) & \", \" & ¬\n        unQuoted(show(|3| of tpl)) & \")\"\nend showTuple3",
  "showTuple4": "-- showTuple4 :: Tuple4 -> String\non showTuple4(tpl)\n    \"(\" & unQuoted(show(|1| of tpl)) & \", \" & ¬\n        unQuoted(show(|2| of tpl)) & \", \" & ¬\n        unQuoted(show(|3| of tpl)) & \", \" & ¬\n        unQuoted(show(|4| of tpl)) & \")\"\nend showTuple4",
  "showUndefined": "-- showUndefined :: () -> String\non showUndefined()\n    \"⊥\"\nend showUndefined",
  "signum": "-- signum :: Num -> Num\non signum(x)\n    if x < 0 then\n        -1\n    else if x = 0 then\n        0\n    else\n        1\n    end if\nend signum",
  "snd": "-- snd :: (a, b) -> b\non snd(tpl)\n    if class of tpl is record then\n        |2| of tpl\n    else\n        item 2 of tpl\n    end if\nend snd",
  "snoc": "-- Mirror image of cons\n-- New copy of the list, with an atom added at the end\n-- snoc :: [a] -> a -> [a]\non snoc(xs, x)\n    xs & {x}\nend snoc",
  "sort": "-- sort :: Ord a => [a] -> [a]\non sort(xs)\n    ((current application's NSArray's arrayWithArray:xs)'s ¬\n        sortedArrayUsingSelector:\"compare:\") as list\nend sort",
  "sortBy": "-- Enough for small scale sorts.\n-- Use instead sortOn :: Ord b => (a -> b) -> [a] -> [a]\n-- which is equivalent to the more flexible sortBy(comparing(f), xs)\n-- and uses a much faster ObjC NSArray sort method\n-- sortBy :: (a -> a -> Ordering) -> [a] -> [a]\non sortBy(f, xs)\n    if length of xs > 1 then\n        set h to item 1 of xs\n        set f to mReturn(f)\n        script\n            on |λ|(x)\n                f's |λ|(x, h) ≤ 0\n            end |λ|\n        end script\n        set lessMore to partition(result, rest of xs)\n        sortBy(f, |1| of lessMore) & {h} & ¬\n            sortBy(f, |2| of lessMore)\n    else\n        xs\n    end if\nend sortBy",
  "sortOn": "-- Sort a list by comparing the results of a key function applied to each\n-- element. sortOn f is equivalent to sortBy(comparing(f), xs), but has the\n-- performance advantage of only evaluating f once for each element in\n-- the input list. This is called the decorate-sort-undecorate paradigm,\n-- or Schwartzian transform.\n-- Elements are arranged from from lowest to highest.\n\n-- In this Applescript implementation, f can optionally be [(a -> b)]\n-- or [((a -> b), Bool)]) to specify a compound sort order\n\n--    xs:  List of items to be sorted. \n--          (The items can be records, lists, or simple values).\n--\n--    f:    A single (a -> b) function (Applescript handler),\n--          or a list of such functions.\n--          if the argument is a list, any function can \n--          optionally be followed by a bool. \n--          (False -> descending sort)\n--\n--          (Subgrouping in the list is optional and ignored)\n--          Each function (Item -> Value) in the list should \n--          take an item (of the type contained by xs) \n--          as its input and return a simple orderable value \n--          (Number, String, or Date).\n--\n--          The sequence of key functions and optional \n--          direction bools defines primary to N-ary sort keys.\n-- sortOn :: Ord b => (a -> b) -> [a] -> [a]\n-- sortOn :: Ord b => [((a -> b), Bool)]  -> [a] -> [a]\non sortOn(f, xs)\n    script keyBool\n        on |λ|(x, a)\n            if class of x is boolean then\n                {asc:x, fbs:fbs of a}\n            else\n                {asc:true, fbs:({Tuple(x, asc of a)} & fbs of a)}\n            end if\n        end |λ|\n    end script\n    set {fs, bs} to {|1|, |2|} of unzip(fbs of foldr(keyBool, ¬\n        {asc:true, fbs:{}}, flatten({f})))\n    \n    set intKeys to length of fs\n    set ca to current application\n    script dec\n        property gs : map(my mReturn, fs)\n        on |λ|(x)\n            set nsDct to (ca's NSMutableDictionary's ¬\n                dictionaryWithDictionary:{val:x})\n            repeat with i from 1 to intKeys\n                (nsDct's setValue:((item i of gs)'s |λ|(x)) ¬\n                    forKey:(character id (96 + i)))\n            end repeat\n            nsDct as record\n        end |λ|\n    end script\n    \n    script descrip\n        on |λ|(bool, i)\n            ca's NSSortDescriptor's ¬\n                sortDescriptorWithKey:(character id (96 + i)) ¬\n                    ascending:bool\n        end |λ|\n    end script\n    \n    script undec\n        on |λ|(x)\n            val of x\n        end |λ|\n    end script\n    \n    map(undec, ((ca's NSArray's arrayWithArray:map(dec, xs))'s ¬\n        sortedArrayUsingDescriptors:map(descrip, bs)) as list)\nend sortOn",
  "span": "-- span, applied to a predicate p and a list xs, returns a tuple of xs of elements that satisfy p and second element is the remainder of the list:\n-- \n-- > span (< 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])\n-- > span (< 9) [1,2,3] == ([1,2,3],[])\n-- > span (< 0) [1,2,3] == ([],[1,2,3])\n-- \n-- span p xs is equivalent to (takeWhile p xs, dropWhile p xs) \n-- span :: (a -> Bool) -> [a] -> ([a], [a])\non span(f, xs)\n    set lng to length of xs\n    set i to 0\n    tell mReturn(f)\n        repeat while i < lng and |λ|(item (i + 1) of xs)\n            set i to i + 1\n        end repeat\n    end tell\n    splitAt(i, xs)\nend span",
  "splitArrow": "-- Compose a function (from a tuple to a tuple), \n-- (with separate transformations for fst and snd)\n-- splitArrow (***) :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))\non splitArrow(f, g)\n    script\n        on |λ|(xy)\n            Tuple(mReturn(f)'s |λ|(|1| of xy), mReturn(g)'s |λ|(|2| of xy))\n        end |λ|\n    end script\nend splitArrow",
  "splitAt": "-- splitAt :: Int -> [a] -> ([a],[a])\non splitAt(n, xs)\n    if n > 0 and n < length of xs then\n        if class of xs is text then\n            Tuple(items 1 thru n of xs as text, items (n + 1) thru -1 of xs as text)\n        else\n            Tuple(items 1 thru n of xs, items (n + 1) thru -1 of xs)\n        end if\n    else\n        if n < 1 then\n            Tuple({}, xs)\n        else\n            Tuple(xs, {})\n        end if\n    end if\nend splitAt",
  "splitBy": "-- splitBy :: (a -> a -> Bool) -> [a] -> [[a]]\n-- splitBy :: (String -> String -> Bool) -> String -> [String]\non splitBy(p, xs)\n    if length of xs < 2 then\n        {xs}\n    else\n        script f\n            property mp : |λ| of mReturn(p)\n            on |λ|(a, x)\n                set {acc, active, prev} to a\n                if mp(prev, x) then\n                    {acc & {active}, {x}, x}\n                else\n                    {acc, active & x, x}\n                end if\n            end |λ|\n        end script\n        \n        set h to item 1 of xs\n        set lstParts to foldl(f, {{}, {h}, h}, items 2 thru -1 of xs)\n        if class of item 1 of xs = string then\n            map(concat, (item 1 of lstParts & {item 2 of lstParts}))\n        else\n            item 1 of lstParts & {item 2 of lstParts}\n        end if\n    end if\nend splitBy",
  "splitEvery": "-- splitEvery :: Int -> [a] -> [[a]]\non splitEvery(n, xs)\n    if length of xs ≤ n then\n        {xs}\n    else\n        set grp_t to splitAt(n, xs)\n        {|1| of grp_t} & splitEvery(n, |2| of grp_t)\n    end if\nend splitEvery",
  "splitFileName": "-- Split a filename into directory and file. combine is the inverse.\n-- splitFileName :: FilePath -> (String, String)\non splitFileName(strPath)\n    if strPath ≠ \"\" then\n        if last character of strPath ≠ \"/\" then\n            set xs to splitOn(\"/\", strPath)\n            set stem to init(xs)\n            if stem ≠ {} then\n                Tuple(intercalate(\"/\", stem) & \"/\", |last|(xs))\n            else\n                Tuple(\"./\", |last|(xs))\n            end if\n        else\n            Tuple(strPath, \"\")\n        end if\n    else\n        Tuple(\"./\", \"\")\n    end if\nend splitFileName",
  "splitOn": "--    splitOn(\"\\r\\n\", \"a\\r\\nb\\r\\nd\\r\\ne\") --> [\"a\",\"b\",\"d\",\"e\"]\n--    splitOn(\"aaa\", \"aaaXaaaXaaaXaaa\") --> {\"\", \"X\", \"X\", \"X\", \"\"}\n--    splitOn(\"x\", \"x\") --> {\"\", \"\"}\n--  splitOn(5, {1, 5, 9, 2, 6, 5, 3, 5}) --> {{1}, {9, 2, 6}, {3}, {}}\n-- splitOn :: a -> [a] -> [[a]]\n-- splitOn :: String -> String -> [String]\non splitOn(needle, haystack)\n    if class of haystack is text then\n        set {dlm, my text item delimiters} to ¬\n            {my text item delimiters, needle}\n        set xs to text items of haystack\n        set my text item delimiters to dlm\n        return xs\n    else\n        script triage\n            on |λ|(a, x)\n                if needle = x then\n                    Tuple(|1| of a & {|2| of a}, {})\n                else\n                    Tuple(|1| of a, (|2| of a) & x)\n                end if\n            end |λ|\n        end script\n        \n        set tpl to foldl(triage, Tuple({}, {}), haystack)\n        return |1| of tpl & {|2| of tpl}\n    end if\nend splitOn",
  "splitRegex": "-- splitRegex :: Regex -> String -> [String]\non splitRegex(strRegex, str)\n    set lstMatches to regexMatches(strRegex, str)\n    if length of lstMatches > 0 then\n        script preceding\n            on |λ|(a, x)\n                set iFrom to start of a\n                set iLocn to (location of x)\n                \n                if iLocn > iFrom then\n                    set strPart to text (iFrom + 1) thru iLocn of str\n                else\n                    set strPart to \"\"\n                end if\n                {parts:parts of a & strPart, start:iLocn + (length of x) - 1}\n            end |λ|\n        end script\n        \n        set recLast to foldl(preceding, {parts:[], start:0}, lstMatches)\n        \n        set iFinal to start of recLast\n        if iFinal < length of str then\n            parts of recLast & text (iFinal + 1) thru -1 of str\n        else\n            parts of recLast & \"\"\n        end if\n    else\n        {str}\n    end if\nend splitRegex",
  "sqrt": "-- sqrt :: Num -> Num\non sqrt(n)\n    if n ≥ 0 then\n        n ^ (1 / 2)\n    else\n        missing value\n    end if\nend sqrt",
  "sqrtLR": "-- sqrtLR :: Num -> Either String Num\non sqrtLR(n)\n    if 0 ≤ n then\n        |Right|(n ^ (1 / 2))\n    else\n        |Left|(\"Square root of negative number: \" & n)\n    end if\nend sqrtLR",
  "sqrtMay": "-- sqrtMay :: Num -> Maybe Num\non sqrtMay(n)\n    if n ≥ 0 then\n        Just(n ^ (1 / 2))\n    else\n        Nothing()\n    end if\nend sqrtMay",
  "strip": "-- strip :: String -> String\non strip(s)\n    script isSpace\n        on |λ|(c)\n            set i to id of c\n            i = 32 or (i ≥ 9 and i ≤ 13)\n        end |λ|\n    end script\n    dropWhile(isSpace, dropWhileEnd(isSpace, s))\nend strip",
  "stripEnd": "-- stripEnd :: String -> String\non stripEnd(s)\n    dropWhileEnd(my isSpace, s)\nend stripEnd",
  "stripPrefix": "-- stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]\n-- stripPrefix :: String -> String -> Maybe String\non stripPrefix(pfx, s)\n    set blnString to class of pfx is text\n    if blnString then\n        set {xs, ys} to {characters of pfx, characters of s}\n    else\n        set {xs, ys} to {pfx, s}\n    end if\n    \n    script\n        on |λ|(xs, ys)\n            if length of xs < 1 then\n                if blnString then\n                    set v to intercalate(\"\", ys)\n                else\n                    set v to ys\n                end if\n                Just(v)\n            else\n                if (length of ys < 1) or (item 1 of xs ≠ item 1 of ys) then\n                    Nothing()\n                else\n                    |λ|(tail(xs), tail(ys))\n                end if\n            end if\n        end |λ|\n    end script\n    |λ|(xs, ys) of result\nend stripPrefix",
  "stripStart": "-- stripStart :: String -> String\non stripStart(s)\n    dropWhile(my isSpace, s)\nend stripStart",
  "subsequences": "-- subsequences([1,2,3]) -> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n-- subsequences(\"abc\") -> [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n-- subsequences :: [a] -> [[a]]\n-- subsequences :: String -> [String]\non subsequences(xs)\n    script nonEmptySubsequences\n        on |λ|(xxs)\n            if length of xxs < 1 then\n                {}\n            else\n                set {x, xs} to {item 1 of xxs, tail(xxs)}\n        \n                script f\n                    on |λ|(ys, r)\n                        cons(ys, cons(cons(x, ys), r))\n                    end |λ|\n                end script\n                \n                cons({x}, foldr(f, {}, |λ|(xs) of nonEmptySubsequences))\n            end if\n        end |λ|\n    end script\n    if class of xs is text then\n        cons(\"\", map(my concat, |λ|(characters of xs) of nonEmptySubsequences))\n    else\n        cons([], |λ|(xs) of nonEmptySubsequences)\n    end if\nend subsequences",
  "subtract": "-- subtract :: Num -> Num -> Num\non subtract(x, y)\n    y - x\nend subtract",
  "succ": "-- succ :: Enum a => a -> a\non succ(x)\n    if isChar(x) then\n        chr(ord(x) + 1)\n    else\n        1 + x\n    end if\nend succ",
  "sum": "-- sum :: [Num] -> Num\non sum(xs)\n    script add\n        on |λ|(a, b)\n            a + b\n        end |λ|\n    end script\n    \n    foldl(add, 0, xs)\nend sum",
  "swap": "-- swap :: (a, b) -> (b, a)\non swap(ab)\n    if class of ab is record then\n        Tuple(|2| of ab, |1| of ab)\n    else\n        {item 2 of ab, item 1 of ab}\n    end if\nend swap",
  "tail": "-- tail :: [a] -> [a]\non tail(xs)\n    if xs = {} then\n        missing value\n    else\n        rest of xs\n    end if\nend tailDef",
  "tailMay": "-- tailMay :: [a] -> Maybe [a]\non tailMay(xs)\n    if xs = {} then\n        Nothing()\n    else\n        Just(rest of xs)\n    end if\nend tailMay",
  "tails": "-- tails :: [a] -> [[a]]\non tails(xs)\n    if class of xs is text then\n        set xs_ to characters of xs\n    else\n        set xs_ to xs\n    end if\n    \n    script\n        on |λ|(_, i)\n            items i thru -1 of xs_\n        end |λ|\n    end script\n    \n    map(result, xs_) & {{}}\nend tails",
  "take": "-- take :: Int -> [a] -> [a]\non take(n, xs)\n    if class of xs is string then\n        if n > 0 then\n            text 1 thru min(n, length of xs) of xs\n        else\n            \"\"\n        end if\n    else\n        if n > 0 then\n            items 1 thru min(n, length of xs) of xs\n        else\n            {}\n        end if\n    end if\nend take",
  "takeAround": "-- takeAround :: (a -> Bool) -> [a] -> [a]\non takeAround(p, xs)\n    set ys to takeWhile(p, xs)\n    if length of ys < length of xs then\n        ys & takeWhileR(p, xs)\n    else\n        ys\n    end if\nend takeAround",
  "takeBaseName": "-- takeBaseName :: FilePath -> String\non takeBaseName(strPath)\n    if strPath ≠ \"\" then\n        if text -1 of strPath = \"/\" then\n            \"\"\n        else\n            set fn to item -1 of splitOn(\"/\", strPath)\n            if fn contains \".\" then\n                intercalateString(\".\", items 1 thru -2 of splitOn(\".\", fn))\n            else\n                fn\n            end if\n        end if\n    else\n        \"\"\n    end if\nend takeBaseName",
  "takeCycle": "-- takeCycle :: Int -> [a] -> [a]\non takeCycle(n, xs)\n    set lng to length of xs\n    if lng ≥ n then\n        set cycle to xs\n    else\n        set cycle to concat(replicate((n div lng) + 1, xs))\n    end if\n    \n    if class of xs is string then\n        items 1 thru n of cycle as string\n    else\n        items 1 thru n of cycle\n    end if\nend takeCycle",
  "takeDirectory": "-- takeDirectory :: FilePath -> FilePath\non takeDirectory(strPath)\n    if strPath ≠ \"\" then\n        if character -1 of strPath = \"/\" then\n            text 1 thru -2 of strPath\n        else\n            set xs to init(splitOn(\"/\", strPath))\n            if xs ≠ {} then\n                intercalate(\"/\", xs)\n            else\n                \".\"\n            end if\n        end if\n    else\n        \".\"\n    end if\nend takeDirector",
  "takeDropCycle": "-- take N Members of an infinite cycle of xs, starting from index I\n-- takeDropCycle :: Int -> [a] -> [a]\non takeDropCycle(n, i, xs)\n    set lng to length of xs\n    set m to n + i\n    \n    if lng ≥ m then\n        set ys to xs\n    else\n        set ys to concat(replicate(ceiling(m / lng), xs))\n    end if\n    \n    drop(i, take(m, ys))\nend takeDropCycle",
  "takeExtension": "-- takeExtension :: FilePath -> String\non takeExtension(strPath)\n    set xs to splitOn(\".\", strPath)\n    if length of xs > 1 then\n        \".\" & item -1 of xs\n    else\n        \"\"\n    end if\nend takeExtension",
  "takeFileName": "-- takeFileName :: FilePath -> FilePath\non takeFileName(strPath)\n    if strPath ≠ \"\" and character -1 of strPath ≠ \"/\" then\n        item -1 of splitOn(\"/\", strPath)\n    else\n        \"\"\n    end if\nend takeFileName",
  "takeIterate": "-- takeIterate n f x == [x, f x, f (f x), ...]\n-- takeIterate :: Int -> (a -> a) -> a -> [a]\non takeIterate(n, f, x)\n    set v to x\n    set vs to {v}\n    tell mReturn(f)\n        repeat with i from 1 to n - 1\n            set v to |λ|(v)\n            set end of vs to v\n        end repeat\n    end tell\n    return vs\nend takeIterate",
  "takeWhile": "-- takeWhile :: (a -> Bool) -> [a] -> [a]\non takeWhile(p, xs)\n    set bln to false\n    tell mReturn(p)\n        repeat with i from 1 to length of xs\n            if not |λ|(item i of xs) then\n                set bln to true\n                exit repeat\n            end if\n        end repeat\n    end tell\n    if bln then\n        if i > 1 then\n            items 1 thru (i - 1) of xs\n        else\n            {}\n        end if\n    else\n        xs\n    end if\nend takeWhile",
  "takeWhileR": "-- takeWhileR :: (a -> Bool) -> [a] -> [a]\non takeWhileR(p, xs)\n    set bln to false\n    tell mReturn(p)\n        set lng to length of xs\n        repeat with i from lng to 1 by -1\n            if not |λ|(item i of xs) then\n                set bln to true\n                exit repeat\n            end if\n        end repeat\n    end tell\n    if bln then\n        if i > 1 then\n            items (1 + i) thru (-1) of xs\n        else\n            {}\n        end if\n    else\n        xs\n    end if\nend takeWhileR",
  "tempFilePath": "-- tempFilePath :: String -> IO FilePath\non tempFilePath(template)\n    (current application's ¬\n        NSTemporaryDirectory() as string) & ¬\n        takeBaseName(template) & ¬\n        text 3 thru -1 of ((random number) as string) & ¬\n        takeExtension(template)\nend tempFilePath",
  "then": "-- then (>>) :: Monad m => m a -> m b -> m b\non |then|(ma, mb)\n    set c to class of ma\n    if c is list then\n        thenList(ma, mb)\n    else if c is record then\n        if keys(ma) contains \"Maybe\" then\n            thenMay(ma, mb)\n        else\n            thenIO(ma, mb)\n        end if\n    else\n        thenIO(ma, mb)\n    end if\nend |then|",
  "thenIO": "-- thenIO (>>) :: IO a -> IO b -> IO b\non thenIO(ma, mb)\n    mb\nend thenIO",
  "thenList": "-- thenList (>>) :: [a] -> [b] -> [b]\non thenList(xs, ys)\n    script\n        on |λ|(_)\n            ys\n        end |λ|\n    end script\n    concatMap(result, xs)\nend thenList",
  "thenMay": "-- thenMay (>>) :: Maybe a -> Maybe b -> Maybe b\non thenMay(ma, mb)\n    if Nothing of ma then\n        ma\n    else\n        mb\n    end if\nend thenMay ",
  "toListTree": "-- toListTree :: Tree a -> [a]\non toListTree(tree)\n    script go\n        on |λ|(x)\n            {root of x} & concatMap(go, nest of x)\n        end |λ|\n    end script\n    |λ|(tree) of go\nend toListTree",
  "toLower": "-- toLower :: String -> String\non toLower(str)\n    set ca to current application\n    ((ca's NSString's stringWithString:(str))'s ¬\n        lowercaseStringWithLocale:(ca's NSLocale's currentLocale())) as text\nend toLower",
  "toRatio": "-- toRatio :: Real -> Ratio\non toRatio(n)\n    approxRatio(1.0E-12, n)\nend toRatio",
  "toSentence": "-- Sentence case - initial string capitalized and rest lowercase\n-- toSentence :: String -> String\non toSentence(str)\n    set ca to current application\n    if length of str > 0 then\n        set locale to ca's NSLocale's currentLocale()\n        set ws to ca's NSString\n        (((ws's stringWithString:(text 1 of str))'s ¬\n            uppercaseStringWithLocale:(locale)) as text) & ¬\n            ((ws's stringWithString:(text 2 thru -1 of str))'s ¬\n                lowercaseStringWithLocale:(locale)) as text\n    else\n        str\n    end if\nend toSentence",
  "toTitle": "-- NB this does not model any regional or cultural conventions.\n-- It simply simply capitalizes the first character of each word.\n-- toTitle :: String -> String\non toTitle(str)\n    set ca to current application\n    ((ca's NSString's stringWithString:(str))'s ¬\n        capitalizedStringWithLocale:(ca's NSLocale's currentLocale())) as text\nend toTitle",
  "toUpper": "-- toUpper :: String -> String\non toUpper(str)\n    set ca to current application\n    ((ca's NSString's stringWithString:(str))'s ¬\n        uppercaseStringWithLocale:(ca's NSLocale's currentLocale())) as text\nend toUpper",
  "transpose": "-- If some of the rows are shorter than the following rows, \n-- their elements are skipped:\n-- transpose({{10,11},{20},{},{30,31,32}}) -> {{10, 20, 30}, {11, 31}, {32}}\n-- transpose :: [[a]] -> [[a]]\non transpose(xxs)\n    set intMax to |length|(maximumBy(comparing(my |length|), xxs))\n    set gaps to replicate(intMax, {})\n    script padded\n        on |λ|(xs)\n            set lng to |length|(xs)\n            if lng < intMax then\n                append(xs, items (lng + 1) thru -1 of gaps)\n            else\n                xs\n            end if\n        end |λ|\n    end script\n    set rows to map(padded, xxs)\n    \n    script cols\n        on |λ|(_, iCol)\n            script cell\n                on |λ|(row)\n                    item iCol of row\n                end |λ|\n            end script\n            concatMap(cell, rows)\n        end |λ|\n    end script\n    map(cols, item 1 of rows)\nend transpose",
  "traverseList": "--    1. Map each element of a structure to an action,\n--    2. evaluate these actions from left to right, and\n--    3. collect the results.\n-- \n--    traverse f = List.foldr cons_f (pure [])\n--      where cons_f x ys = liftA2 (:) (f x) ys\n-- traverseList :: (Applicative f) => (a -> f b) -> [a] -> f [b]\non traverseList(f, xs)\n    set lng to length of xs\n    if 0 < lng then\n        set mf to mReturn(f)\n        \n        set vLast to mf's |λ|(item -1 of xs)\n        if class of vLast is record and ¬\n            keys(vLast) contains \"type\" then\n            set t to type of vLast\n        else\n            set t to \"List\"\n        end if\n        \n        script cons_f\n            on |λ|(x, ys)\n                liftA2(my cons, mf's |λ|(x), ys)\n            end |λ|\n        end script\n        \n        foldr(cons_f, ¬\n            liftA2(my cons, vLast, pureT(t, [])), ¬\n            items 1 thru -2 of xs)\n    else\n        {}\n    end if\nend traverseList",
  "treeLeaves": "-- treeLeaves :: Tree -> [Tree]\non treeLeaves(oNode)\n    script go\n        on |λ|(x)\n            set lst to nest of x\n            if length of lst > 0 then\n                concatMap(my treeLeaves, lst)\n            else\n                {x}\n            end if\n        end |λ|\n    end script\n    |λ|(oNode) of go\nend treeLeaves",
  "truncate": "-- truncate :: Num -> Int\non truncate(x)\n    item 1 of properFraction(x)\nend truncate",
  "Tuple": "-- Tuple (,) :: a -> b -> (a, b)\non Tuple(a, b)\n    {type:\"Tuple\", |1|:a, |2|:b}\nend Tuple",
  "tupleFromArray": "-- tupleFromArray [a] -> (a, a ...)\non tupleFromArray(xs)\n    set lng to length of xs\n    if lng > 1 then\n        if lng > 2 then\n            set strSuffix to lng as string\n        else\n            set strSuffix to \"\"\n        end if\n        script kv\n            on |λ|(a, x, i)\n                insertMap(a, (i as string), x)\n            end |λ|\n        end script\n        foldl(kv, {type:\"Tuple\" & strSuffix}, xs)\n    else\n        missing value\n    end if\nend tupleFromArray",
  "TupleN": "-- TupleN :: a -> b ...  -> (a, b ... )\non TupleN(xs)\n    tupleFromArray(xs)\nend Tuple",
  "typeName": "-- typeName :: a -> String\non typeName(x)\n    set mb to lookup((class of x) as string, ¬\n        {|list|:\"List\", |integer|:\"Int\", |real|:\"Float\", |text|:¬\n            \"String\", |string|:\"String\", |record|:¬\n            \"Record\", |boolean|:\"Bool\", |handler|:\"Function\", |script|:\"Function\"})\n    if Nothing of mb then\n        \"Bottom\"\n    else\n        set k to Just of mb\n        if k = \"Record\" then\n            if keys(x) contains \"type\" then\n                type of x\n            else\n                \"Dict\"\n            end if\n        else\n            k\n        end if\n    end if\nend typeName",
  "uncons": "-- uncons :: [a] -> Maybe (a, [a])\non uncons(xs)\n    if xs = {} then\n        Nothing()\n    else\n        if class of xs is string then\n            set cs to text items of xs\n            Just(Tuple(item 1 of cs, rest of cs))\n        else\n            Just(Tuple(item 1 of xs, rest of xs))\n        end if\n    end if\nend uncons",
  "uncurry": "-- Returns a function on a single tuple (containing 2 arguments)\n-- derived from an equivalent function with 2 distinct arguments\n-- uncurry :: (a -> b -> c) -> ((a, b) -> c)\non uncurry(f)\n    script\n        property mf : mReturn(f)'s |λ|\n        on |λ|(pair)\n            mf(|1| of pair, |2| of pair)\n        end |λ|\n    end script\nend uncurry",
  "unfoldForest": "-- | Build a forest from a list of seed values\n-- unfoldForest :: (b -> (a, [b])) -> [b] -> [Tree]\non unfoldForest(f, xs)\n    set g to mReturn(f)\n    script\n        on |λ|(x)\n            unfoldTree(g, x)\n        end |λ|\n    end script\n    map(result, xs)\nend unfoldForest",
  "unfoldl": "-- > unfoldl (\\b -> if b == 0 then Nothing else Just (b, b-1)) 10\n-- > [1,2,3,4,5,6,7,8,9,10]\n-- unfoldl :: (b -> Maybe (a, b)) -> b -> [a]\non unfoldl(f, v)\n    set xr to Tuple(v, v) -- (value, remainder)\n    set xs to {}\n    tell mReturn(f)\n        repeat -- Function applied to remainder.\n            set mb to |λ|(|2| of xr)\n            if Nothing of mb then\n                exit repeat\n            else -- New (value, remainder) tuple,\n                set xr to Just of mb\n                -- and value appended to output list.\n                set xs to ({|1| of xr} & xs)\n            end if\n        end repeat\n    end tell\n    return xs\nend unfoldl",
  "unfoldr": "-- > unfoldr (\\b -> if b == 0 then Nothing else Just (b, b-1)) 10\n-- > [10,9,8,7,6,5,4,3,2,1] \n-- unfoldr :: (b -> Maybe (a, b)) -> b -> [a]\non unfoldr(f, v)\n    set xr to Tuple(v, v) -- (value, remainder)\n    set xs to {}\n    tell mReturn(f)\n        repeat -- Function applied to remainder.\n            set mb to |λ|(|2| of xr)\n            if Nothing of mb then\n                exit repeat\n            else -- New (value, remainder) tuple,\n                set xr to Just of mb\n                -- and value appended to output list.\n                set end of xs to |1| of xr\n            end if\n        end repeat\n    end tell\n    return xs\nend unfoldr",
  "unfoldTree": "-- | Build a tree from a seed value\n-- unfoldTree :: (b -> (a, [b])) -> b -> Tree a\non unfoldTree(f, b)\n    set g to mReturn(f)\n    set tpl to g's |λ|(b)\n    Node(|1| of tpl, unfoldForest(g, |2| of tpl))\nend unfoldTree",
  "union": "-- union :: [a] -> [a] -> [a]\non union(xs, ys)\n    script flipDelete\n        on |λ|(xs, x)\n            my |delete|(x, xs)\n        end |λ|\n    end script\n    \n    set sx to nub(xs)\n    sx & foldl(flipDelete, nub(ys), sx)\nend union",
  "unionBy": "-- unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]\non unionBy(fnEq, xs, ys)\n    script flipDeleteByEq\n        on |λ|(xs, x)\n            deleteBy(fnEq, x, xs)\n        end |λ|\n    end script\n    xs & foldl(flipDeleteByEq, nubBy(fnEq, ys), xs)\nend unionBy",
  "unlines": "-- unlines :: [String] -> String\non unlines(xs)\n    set {dlm, my text item delimiters} to ¬\n        {my text item delimiters, linefeed}\n    set str to xs as text\n    set my text item delimiters to dlm\n    str\nend unlines",
  "unQuoted": "-- unQuoted :: String -> String\non unQuoted(s)\n    script p\n        on |λ|(x)\n            --{34, 39} contains id of x\n            34 = id of x\n        end |λ|\n    end script\n    dropAround(p, s)\nend unQuoted",
  "unsnoc": "-- If the list is empty returns Nothing, otherwise returns \n-- Just the init and the last.\n-- unsnoc :: [a] -> Maybe ([a], a)\non unsnoc(xs)\n    set blnString to class of xs is string\n    set lng to length of xs\n    if lng = 0 then\n        Nothing()\n    else\n        set h to item -1 of xs\n        if lng > 1 then\n            if blnString then\n                Just(Tuple(text 1 thru -2 of xs, h))\n            else\n                Just(Tuple(items 1 thru -2 of xs, h))\n            end if\n        else\n            if blnString then\n                Just(Tuple(\"\", h))\n            else\n                Just(Tuple({}, h))\n            end if\n        end if\n    end if\nend unsnoc",
  "until": "-- until :: (a -> Bool) -> (a -> a) -> a -> a\non |until|(p, f, x)\n    set v to x\n    set mp to mReturn(p)\n    set mf to mReturn(f)\n    repeat until mp's |λ|(v)\n        set v to mf's |λ|(v)\n    end repeat\nend |until|",
  "unwords": "-- unwords :: [String] -> String\non unwords(xs)\n    intercalate(space, xs)\nend unwords",
  "unwrap": "-- unwrap :: NSObject -> a\non unwrap(objCValue)\n    if objCValue is missing value then\n        missing value\n    else\n        set ca to current application\n        item 1 of ((ca's NSArray's arrayWithObject:objCValue) as list)\n    end if\nend unwrap",
  "unzip": "-- unzip :: [(a,b)] -> ([a],[b])\non unzip(xys)\n    set xs to {}\n    set ys to {}\n    repeat with xy in xys\n        set end of xs to |1| of xy\n        set end of ys to |2| of xy\n    end repeat\n    return Tuple(xs, ys)\nend unzip",
  "unzip3": "-- unzip3 :: [(a,b,c)] -> ([a],[b],[c])\non unzip3(xyzs)\n    set xs to {}\n    set ys to {}\n    set zs to {}\n    repeat with xyz in xyzs\n        set end of xs to |1| of xyz\n        set end of ys to |2| of xyz\n        set end of zs to |3| of xyz\n    end repeat\n    return Tuple3(xs, ys, zs)\nend unzip3",
  "unzip4": "-- unzip4 :: [(a,b,c,d)] -> ([a],[b],[c],[d])\non unzip4(wxyzs)\n    set ws to {}\n    set xs to {}\n    set ys to {}\n    set zs to {}\n    repeat with wxyz in wxyzs\n        set end of ws to |1| of wxyz\n        set end of xs to |2| of wxyz\n        set end of ys to |3| of wxyz\n        set end of zs to |4| of wxyz\n    end repeat\n    return Tuple4(ws, xs, ys, zs)\nend unzip4",
  "variance": "-- variance :: [Num] -> Num\non variance(xs)\n    set m to mean(xs)\n    script\n        on |λ|(a, x)\n            a + (x - m) ^ 2\n        end |λ|\n    end script\n    foldl(result, 0, xs) / ((length of xs) - 1)\nend variance",
  "words": "-- words :: String -> [String]\non |words|(s)\n    words of s\nend |words|",
  "wrap": "-- wrap :: a -> NSObject\non wrap(v)\n    set ca to current application\n    ca's (NSArray's arrayWithObject:v)'s objectAtIndex:0\nend wrap",
  "writeFile": "-- use framework \"Foundation\"\n-- writeFile :: FilePath -> String -> IO ()\non writeFile(strPath, strText)\n    set ca to current application\n    (ca's NSString's stringWithString:strText)'s ¬\n        writeToFile:(stringByStandardizingPath of ¬\n            (ca's NSString's stringWithString:strPath)) atomically:true ¬\n            encoding:(ca's NSUTF8StringEncoding) |error|:(missing value)\nend writeFile",
  "writeFileLR": "-- writeFileLR :: FilePath -> Either String IO FilePath\non writeFileLR(strPath, strText)\n    set ca to current application\n    set fp to stringByStandardizingPath of ¬\n        (ca's NSString's stringWithString:strPath)\n    set {bln, e} to (ca's NSString's stringWithString:strText)'s ¬\n        writeToFile:(fp) atomically:true ¬\n            encoding:(ca's NSUTF8StringEncoding) |error|:(reference)\n    if bln and e is missing value then\n        |Right|(fp as string)\n    else\n        |Left|(e's localizedDescription() as string)\n    end if\nend writeFileLR",
  "writeTempFile": "use framework \"Foundation\"\n-- File name template -> string data -> temporary path\n-- (Random digit sequence inserted between template base and extension)\n-- writeTempFile :: String -> String -> IO FilePath\non writeTempFile(template, txt)\n    set strPath to (current application's ¬\n        NSTemporaryDirectory() as string) & ¬\n        takeBaseName(template) & ¬\n        text 3 thru -1 of ((random number) as string) & ¬\n        takeExtension(template)\n    -- Effect\n    writeFile(strPath, txt)\n    -- Value\n    strPath\nend writeTempFile",
  "zip": "-- zip :: [a] -> [b] -> [(a, b)]\non zip(xs, ys)\n    set lng to min(length of xs, length of ys)\n    set lst to {}\n    repeat with i from 1 to lng\n        set end of lst to Tuple(item i of xs, item i of ys)\n    end repeat\n    return lst\nend zip",
  "zip3": "-- zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\non zip3(xs, ys, zs)\n    script\n        on |λ|(x, i)\n            Tuple3(x, item i of ys, item i of zs)\n        end |λ|\n    end script\n    map(result, items 1 thru ¬\n        minimum({length of xs, length of ys, length of zs}) of xs)\nend zip3",
  "zip4": "-- zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]\non zip4(ws, xs, ys, zs)\n    script\n        on |λ|(w, i)\n            Tuple4(w, item i of xs, item i of ys, item i of zs)\n        end |λ|\n    end script\n    map(result, items 1 thru ¬\n        minimum({length of xs, length of ys, length of zs}) of xs)\nend zip4",
  "zipWith": "-- zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\non zipWith(f, xs, ys)\n    set lng to min(length of xs, length of ys)\n    if lng < 1 then return {}\n    set lst to {}\n    tell mReturn(f)\n        repeat with i from 1 to lng\n            set end of lst to |λ|(item i of xs, item i of ys)\n        end repeat\n        return lst\n    end tell\nend zipWith",
  "zipWith3": "-- zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\non zipWith3(f, xs, ys, zs)\n    set lng to minimum({length of xs, length of ys, length of zs})\n    if lng < 1 then return {}\n    set lst to {}\n    tell mReturn(f)\n        repeat with i from 1 to lng\n            set end of lst to |λ|(item i of xs, item i of ys, item i of zs)\n        end repeat\n        return lst\n    end tell\nend zipWith3",
  "zipWith4": "-- zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]\non zipWith4(f, ws, xs, ys, zs)\n    set lng to minimum({length of ws, length of xs, length of ys, length of zs})\n    if lng < 1 then return {}\n    set lst to {}\n    tell mReturn(f)\n        repeat with i from 1 to lng\n            set end of lst to |λ|(item i of ws, item i of xs, item i of ys, item i of zs)\n        end repeat\n        return lst\n    end tell\nend zipWith4"
}